#region OPEN SOURCE AGREEMENT
/*
	NASA OPEN SOURCE AGREEMENT VERSION 1.3

	THIS OPEN SOURCE AGREEMENT ("AGREEMENT") DEFINES THE RIGHTS OF USE,
	REPRODUCTION, DISTRIBUTION, MODIFICATION AND REDISTRIBUTION OF CERTAIN
	COMPUTER SOFTWARE ORIGINALLY RELEASED BY THE UNITED STATES GOVERNMENT
	AS REPRESENTED BY THE GOVERNMENT AGENCY LISTED BELOW ("GOVERNMENT
	AGENCY").  THE UNITED STATES GOVERNMENT, AS REPRESENTED BY GOVERNMENT
	AGENCY, IS AN INTENDED THIRD-PARTY BENEFICIARY OF ALL SUBSEQUENT
	DISTRIBUTIONS OR REDISTRIBUTIONS OF THE SUBJECT SOFTWARE.  ANYONE WHO
	USES, REPRODUCES, DISTRIBUTES, MODIFIES OR REDISTRIBUTES THE SUBJECT
	SOFTWARE, AS DEFINED HEREIN, OR ANY PART THEREOF, IS, BY THAT ACTION,
	ACCEPTING IN FULL THE RESPONSIBILITIES AND OBLIGATIONS CONTAINED IN
	THIS AGREEMENT.

	Government Agency: NASA_____________________________________
	Government Agency Original Software Designation: ______________
	Government Agency Original Software Title: ____________________
	User Registration Requested.  Please Visit http://__________________
	Government Agency Point of Contact for Original Software: ___________________
	________________________________________________


	1. DEFINITIONS

	A. "Contributor" means Government Agency, as the developer of the
	Original Software, and any entity that makes a Modification.
	B. "Covered Patents" mean patent claims licensable by a Contributor
	that are necessarily infringed by the use or sale of its Modification
	alone or when combined with the Subject Software.
	C. "Display" means the showing of a copy of the Subject Software,
	either directly or by means of an image, or any other device.
	D. "Distribution" means conveyance or transfer of the Subject
	Software, regardless of means, to another.
	E. "Larger Work" means computer software that combines Subject
	Software, or portions thereof, with software separate from the Subject
	Software that is not governed by the terms of this Agreement.
	F.  "Modification" means any alteration of, including addition to or
	deletion from, the substance or structure of either the Original
	Software or Subject Software, and includes derivative works, as that
	term is defined in the Copyright Statute, 17 USC 101.  However, the
	act of including Subject Software as part of a Larger Work does not in
	and of itself constitute a Modification.
	G. "Original Software" means the computer software first released
	under this Agreement by Government Agency with Government Agency
	designation ______________ and entitled
	_____________________________________________, including source code,
	object code and accompanying documentation, if any.
	H. "Recipient" means anyone who acquires the Subject Software under
	this Agreement, including all Contributors.
	I. "Redistribution" means Distribution of the Subject Software after a
	Modification has been made.
	J. "Reproduction" means the making of a counterpart, image or copy of
	the Subject Software.
	K. "Sale" means the exchange of the Subject Software for money or
	equivalent value.
	L. "Subject Software" means the Original Software, Modifications, or
	any respective parts thereof.
	M. "Use" means the application or employment of the Subject Software
	for any purpose.

	2. GRANT OF RIGHTS

	A. Under Non-Patent Rights: Subject to the terms and conditions of
	this Agreement, each Contributor, with respect to its own contribution
	to the Subject Software, hereby grants to each Recipient a
	non-exclusive, world-wide, royalty-free license to engage in the
	following activities pertaining to the Subject Software:

	1. Use
	2. Distribution
	3. Reproduction
	4. Modification
	5. Redistribution
	6. Display

	B. Under Patent Rights: Subject to the terms and conditions of this
	Agreement, each Contributor, with respect to its own contribution to
	the Subject Software, hereby grants to each Recipient under Covered
	Patents a non-exclusive, world-wide, royalty-free license to engage in
	the following activities pertaining to the Subject Software:

	1. Use
	2. Distribution
	3. Reproduction
	4. Sale
	5. Offer for Sale

	C. The rights granted under Paragraph B. also apply to the combination
	of a Contributor's Modification and the Subject Software if, at the
	time the Modification is added by the Contributor, the addition of
	such Modification causes the combination to be covered by the Covered
	Patents.  It does not apply to any other combinations that include a
	Modification.

	D. The rights granted in Paragraphs A. and B. allow the Recipient to
	sublicense those same rights.  Such sublicense must be under the same
	terms and conditions of this Agreement.

	3. OBLIGATIONS OF RECIPIENT

	A. Distribution or Redistribution of the Subject Software must be made
	under this Agreement except for additions covered under paragraph 3H.

	1. Whenever a Recipient distributes or redistributes the Subject
	Software, a copy of this Agreement must be included with each copy
	of the Subject Software; and
	2. If Recipient distributes or redistributes the Subject Software in
	any form other than source code, Recipient must also make the
	source code freely available, and must provide with each copy of
	the Subject Software information on how to obtain the source code
	in a reasonable manner on or through a medium customarily used for
	software exchange.

	B. Each Recipient must ensure that the following copyright notice
	appears prominently in the Subject Software:

	[Government Agency will insert the applicable copyright notice in each
	agreement accompanying the initial distribution of original software
	and remove this bracketed language.]

	[The following copyright notice will be used if created by a
	contractor pursuant to Government Agency contract and rights obtained
	from creator by assignment.  Government Agency will insert the year
	and its Agency designation and remove the bracketed language.]
	Copyright ã {YEAR} United States Government as represented by ______
	_________________________.  All Rights Reserved.

	[The following copyright notice will be used if created by civil
	servants only. Government Agency will insert the year and its Agency
	designation and remove the bracketed language.]  Copyright Ó {YEAR}
	United States Government as represented by _____________
	_____________________________.  No copyright is claimed in the United
	States under Title 17, U.S.Code. All Other Rights Reserved.

	C. Each Contributor must characterize its alteration of the Subject
	Software as a Modification and must identify itself as the originator
	of its Modification in a manner that reasonably allows subsequent
	Recipients to identify the originator of the Modification.  In
	fulfillment of these requirements, Contributor must include a file
	(e.g., a change log file) that describes the alterations made and the
	date of the alterations, identifies Contributor as originator of the
	alterations, and consents to characterization of the alterations as a
	Modification, for example, by including a statement that the
	Modification is derived, directly or indirectly, from Original
	Software provided by Government Agency. Once consent is granted, it
	may not thereafter be revoked.

	D. A Contributor may add its own copyright notice to the Subject
	Software.  Once a copyright notice has been added to the Subject
	Software, a Recipient may not remove it without the express permission
	of the Contributor who added the notice.

	E. A Recipient may not make any representation in the Subject Software
	or in any promotional, advertising or other material that may be
	construed as an endorsement by Government Agency or by any prior
	Recipient of any product or service provided by Recipient, or that may
	seek to obtain commercial advantage by the fact of Government Agency's
	or a prior Recipient's participation in this Agreement.

	F. In an effort to track usage and maintain accurate records of the
	Subject Software, each Recipient, upon receipt of the Subject
	Software, is requested to register with Government Agency by visiting
	the following website: ______________________________.  Recipient's
	name and personal information shall be used for statistical purposes
	only. Once a Recipient makes a Modification available, it is requested
	that the Recipient inform Government Agency at the web site provided
	above how to access the Modification.

	[Alternative paragraph for use when a web site for release and
	monitoring of subject software will not be supported by releasing
	Government Agency] In an effort to track usage and maintain accurate
	records of the Subject Software, each Recipient, upon receipt of the
	Subject Software, is requested to provide Government Agency, by e-mail
	to the Government Agency Point of Contact listed in clause 5.F., the
	following information: ______________________________.  Recipient's
	name and personal information shall be used for statistical purposes
	only. Once a Recipient makes a Modification available, it is requested
	that the Recipient inform Government Agency, by e-mail to the
	Government Agency Point of Contact listed in clause 5.F., how to
	access the Modification.

	G. Each Contributor represents that that its Modification is believed
	to be Contributor's original creation and does not violate any
	existing agreements, regulations, statutes or rules, and further that
	Contributor has sufficient rights to grant the rights conveyed by this
	Agreement.

	H. A Recipient may choose to offer, and to charge a fee for, warranty,
	support, indemnity and/or liability obligations to one or more other
	Recipients of the Subject Software.  A Recipient may do so, however,
	only on its own behalf and not on behalf of Government Agency or any
	other Recipient.  Such a Recipient must make it absolutely clear that
	any such warranty, support, indemnity and/or liability obligation is
	offered by that Recipient alone.  Further, such Recipient agrees to
	indemnify Government Agency and every other Recipient for any
	liability incurred by them as a result of warranty, support, indemnity
	and/or liability offered by such Recipient.

	I. A Recipient may create a Larger Work by combining Subject Software
	with separate software not governed by the terms of this agreement and
	distribute the Larger Work as a single product. In such case, the
	Recipient must make sure Subject Software, or portions thereof,
	included in the Larger Work is subject to this Agreement.

	J. Notwithstanding any provisions contained herein, Recipient is
	hereby put on notice that export of any goods or technical data from
	the United States may require some form of export license from the
	U.S. Government.  Failure to obtain necessary export licenses may
	result in criminal liability under U.S. laws.  Government Agency
	neither represents that a license shall not be required nor that, if
	required, it shall be issued.  Nothing granted herein provides any
	such export license.

	4. DISCLAIMER OF WARRANTIES AND LIABILITIES; WAIVER AND INDEMNIFICATION

	A. No Warranty: THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY
	WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
	INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE
	WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
	INFRINGEMENT, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL BE ERROR
	FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM TO
	THE SUBJECT SOFTWARE. THIS AGREEMENT DOES NOT, IN ANY MANNER,
	CONSTITUTE AN ENDORSEMENT BY GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT
	OF ANY RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY
	OTHER APPLICATIONS RESULTING FROM USE OF THE SUBJECT SOFTWARE.
	FURTHER, GOVERNMENT AGENCY DISCLAIMS ALL WARRANTIES AND LIABILITIES
	REGARDING THIRD-PARTY SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE,
	AND DISTRIBUTES IT "AS IS."

	B. Waiver and Indemnity: RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS
	AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
	SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT.  IF RECIPIENT'S USE OF
	THE SUBJECT SOFTWARE RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES,
	EXPENSES OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM
	PRODUCTS BASED ON, OR RESULTING FROM, RECIPIENT'S USE OF THE SUBJECT
	SOFTWARE, RECIPIENT SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED
	STATES GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY
	PRIOR RECIPIENT, TO THE EXTENT PERMITTED BY LAW.  RECIPIENT'S SOLE
	REMEDY FOR ANY SUCH MATTER SHALL BE THE IMMEDIATE, UNILATERAL
	TERMINATION OF THIS AGREEMENT.


	5. GENERAL TERMS

	A. Termination: This Agreement and the rights granted hereunder will
	terminate automatically if a Recipient fails to comply with these
	terms and conditions, and fails to cure such noncompliance within
	thirty (30) days of becoming aware of such noncompliance.  Upon
	termination, a Recipient agrees to immediately cease use and
	distribution of the Subject Software.  All sublicenses to the Subject
	Software properly granted by the breaching Recipient shall survive any
	such termination of this Agreement.

	B. Severability: If any provision of this Agreement is invalid or
	unenforceable under applicable law, it shall not affect the validity
	or enforceability of the remainder of the terms of this Agreement.

	C. Applicable Law: This Agreement shall be subject to United States
	federal law only for all purposes, including, but not limited to,
	determining the validity of this Agreement, the meaning of its
	provisions and the rights, obligations and remedies of the parties.

	D. Entire Understanding: This Agreement constitutes the entire
	understanding and agreement of the parties relating to release of the
	Subject Software and may not be superseded, modified or amended except
	by further written agreement duly executed by the parties.

	E. Binding Authority: By accepting and using the Subject Software
	under this Agreement, a Recipient affirms its authority to bind the
	Recipient to all terms and conditions of this Agreement and that that
	Recipient hereby agrees to all terms and conditions herein.

	F. Point of Contact: Any Recipient contact with Government Agency is
	to be directed to the designated representative as follows:
	___________________________________________________________.
 *
 *
 *
 */
#endregion

using Microsoft.DirectX.Direct3D;
using Microsoft.DirectX;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Net;
using System.Security.Permissions;
using System.Threading;
using System.Windows.Forms;
using System;
using WorldWind.Camera;
using WorldWind.Menu;
using WorldWind;
using WorldWind.Net;
using WorldWind.Net.Wms;
using WorldWind.Interop;
using WorldWind.VisualControl;
using Utility.Location;
using WorldWind.Net.Monitor;

namespace WorldWind
{
   public class WorldWindow : Control, IGlobe
   {
      #region Private Fields

      /// <summary>
      /// Direct3D rendering m_Device3d
      /// </summary>
      private Device m_Device3d;
      private ProgressMonitor progressMonitor;
      private PresentParameters m_presentParams;
      private DrawArgs drawArgs;
      private World m_World;
      private Cache m_Cache;
      private Thread m_WorkerThread;
      private bool showDiagnosticInfo;
      private string _caption = "";
      private long lastFpsUpdateTime;
      private int frameCounter;
      private float fps;
      private string saveScreenShotFilePath;
      private ImageFileFormat saveScreenShotImageFileFormat = ImageFileFormat.Bmp;
      private bool m_WorkerThreadRunning;
      //private LayerManagerButton layerManagerButton;
      //private MenuBar _menuBar = new MenuBar(MenuAnchor.Top, 90);
      private bool m_isRenderDisabled = true; // True when WW isn't active - CPU saver
      private bool isMouseDragging;
      private Point mouseDownStartPosition = Point.Empty;
      private bool renderWireFrame;
      private PluginEngine.PluginCompiler m_PluginCompiler = null;
      private Angle targetLatitude;
      private Angle targetLongitude;

      #endregion

      /// <summary>
      /// Initializes a new instance of the <see cref= "T:WorldWind.WorldWindow"/> class.
      /// </summary>
      public WorldWindow()
      {
         this.SetStyle(ControlStyles.AllPaintingInWmPaint | ControlStyles.Opaque, true);

         // The m_Device3d can't be created unless the control is at least 1 x 1 pixels in size
         this.Size = new Size(1, 1);
         try
         {
            // Now perform the rendering m_Device3d initialization
            // Skip DirectX initialization in design mode
            if (!IsInDesignMode())
             {
                 this.InitializeGraphics();
                 Application.Idle += new EventHandler(this.OnApplicationIdle);
             }

            //Post m_Device3d creation initialization
            this.drawArgs = new DrawArgs(m_Device3d, this);
            this.m_RootWidget = new WorldWind.Widgets.RootWidget(this);
         }
         catch (InvalidCallException caught)
         {
            throw new InvalidCallException(
               "Unable to locate a compatible graphics adapter. Make sure you are running the latest version of DirectX.\nAlso note that this application does not support execution within virtual machines or through remote desktop connections.", caught);
         }
         catch (NotAvailableException caught)
         {
            throw new NotAvailableException(
               "Unable to locate a compatible graphics adapter. Make sure you are running the latest version of DirectX.\nAlso note that this application does not support execution within virtual machines or through remote desktop connections.", caught);
         }
      }

      #region Public properties

      public World CurrentWorld
      {
         get
         {
            return m_World;
         }
         set
         {
            m_World = value;
            if (m_World != null)
            {
               this.drawArgs.WorldCamera = new MomentumCamera(m_World.Position, m_World.EquatorialRadius);

               // TODO: Decide how to load grids
               m_World.RenderableObjects.Add(new Renderable.LatLongGrid(m_World));
            }
         }
      }

      public double ViewRange
      {
         get
         {
            return this.drawArgs.WorldCamera.ViewRange.Degrees;
         }
      }
      public double Latitude
      {
         get
         {
            return this.drawArgs.WorldCamera.Latitude.Degrees;
         }
      }
      public double Longitude
      {
         get
         {
            return this.drawArgs.WorldCamera.Longitude.Degrees;
         }
      }

      public string Caption
      {
         get
         {
            return this._caption;
         }
         set
         {
            this._caption = value;
         }
      }

      public DrawArgs DrawArgs
      {
         get { return this.drawArgs; }
      }

      public Cache Cache
      {
         get
         {
            return m_Cache;
         }
      }

      /// <summary>
      /// Disables rendering (CPU tick saver)
      /// </summary>
      public bool IsRenderDisabled
      {
         get
         {
            return m_isRenderDisabled;
         }
         set
         {
            m_isRenderDisabled = value;
         }
      }

      private WorldWindSettingsComponent m_oWWSettings;

      [Browsable(true)]
      public WorldWindSettingsComponent WorldWindSettingsComponent
      {
         get
         {
            return m_oWWSettings;
         }
         set
         {
            m_oWWSettings = value;
            long CacheUpperLimit = (long)m_oWWSettings.CacheSizeGigaBytes * 1024L * 1024L;
            long CacheLowerLimit = (long)m_oWWSettings.CacheSizeGigaBytes * 768L * 1024L;	//75% of upper limit
            //Set up the cache
            m_Cache = new Cache(
             m_oWWSettings.CachePath,
             CacheLowerLimit,
             CacheUpperLimit,
             m_oWWSettings.CacheCleanupInterval,
             m_oWWSettings.TotalRunTime);
         }
      }

      public WorldWindSettings WorldWindSettings
      {
         get
         {
            return m_oWWSettings.WorldWindSettings;
         }
      }

      private PluginEngine.PluginCompiler PluginCompiler
      {
         get
         {
            if (m_PluginCompiler == null)
            {
               m_PluginCompiler = new WorldWind.PluginEngine.PluginCompiler();//m_oWWSettings.WorldWindDirectory);
            }
            return m_PluginCompiler;
         }
      }

      #endregion

      #region Public methods

      /// <summary>
      /// Rotate for a heading
      /// </summary>
      /// <param name="dX"></param>
      /// <param name="dY"></param>
      /// <param name="dCos"></param>
      /// <param name="dSin"></param>
      private static void Rotate(ref double dX, ref double dY, double dCos, double dSin) 
      {
         double dTemp = dX*dCos + dY*dSin;
         dY = dY*dCos - dX*dSin;
         dX = dTemp;
      }


      /// <summary>
      /// Algorithm for a better estimate of waht we are looking at on the planet.
      /// Used for overview drawing as well as dataset filtering and export in Dapple.
      /// </summary>
      const double DVangle = 30.0; // Diagonal view angle in radians
      const double HVangle = 22.21; // Horizontal view angle
      const double Deg2Rad = Math.PI / 180.0;
      const double Rad2Deg = 180 / Math.PI;
      public GeographicQuad GetViewBox()
      {
         // Known Variables
         double dAlt = this.drawArgs.WorldCamera.Distance; // distance to target position on ground
         double dTilt = this.drawArgs.WorldCamera.Tilt.Degrees; // tilt angle, 0 (vertical) to 90 (Horizontal)
         double dHead = this.drawArgs.WorldCamera.Heading.Degrees; // view direction CW relative to North
         double dX = this.drawArgs.WorldCamera.Longitude.Degrees, dY = this.drawArgs.WorldCamera.Latitude.Degrees; // view centre
         double dRadius = m_World.EquatorialRadius;
         double dX1,dY1; // lower left
         double dX2,dY2; // lower right
         double dX3,dY3; // upper right
         double dX4,dY4; // upper left

         // Maximum visibility
         double dMaxAngle = Math.Acos(dRadius  / (dRadius + dAlt)) * Rad2Deg;

         double H_Range, D_Range;
         double dHRatio = (dAlt + dRadius) * Math.Sin(HVangle * Deg2Rad) / dRadius;
         double dVRatio = (dAlt + dRadius) * Math.Sin(DVangle * Deg2Rad) / dRadius;

         // horizontal range
         if (dHRatio < 1.0)
            H_Range = Rad2Deg * Math.Asin(dHRatio) - HVangle;
         else
            H_Range = 90.0 - HVangle;

         // diagonal range
         if (dVRatio < 1.0)
            D_Range = Rad2Deg * Math.Asin(dVRatio) - DVangle;
         else
            D_Range = 90.0 - DVangle;

         H_Range = Math.Min(dMaxAngle, H_Range);
         D_Range = Math.Min(dMaxAngle, D_Range);

         // area limits for a tilted view (tilt maxes out at 85 degrees)
         dY1 = dY2 = -H_Range * (Math.Cos(DVangle * Deg2Rad) / Math.Cos((DVangle - dTilt) * Deg2Rad));
         if (DVangle + dTilt >= 90.0)
            dY3 = dY4 = Math.Min(dMaxAngle, 90 - DVangle);
         else
         {
            double dTA = H_Range * (Math.Cos(DVangle * Deg2Rad) / Math.Cos((DVangle + dTilt) * Deg2Rad));
            if (double.IsNaN(dTA) || dTA > 90.0 - DVangle)
               dTA = 90.0 - DVangle;
            dY3 = dY4 = Math.Min(dMaxAngle, dTA);
         }

         double dSkew = H_Range * Math.Sin(dTilt * Deg2Rad);
         dX1 = dSkew - H_Range;
         dX2 = H_Range - dSkew;
         dX3 = H_Range + dSkew * (dY3 / (-dY1));
         dX4 = -dX3;

         if (dHead != 0) {
            double dCos = Math.Cos(dHead * Deg2Rad);
            double dSin = Math.Sin(dHead * Deg2Rad);
            Rotate(ref dX1, ref dY1, dCos, dSin);
            Rotate(ref dX2, ref dY2, dCos, dSin);
            Rotate(ref dX3, ref dY3, dCos, dSin);
            Rotate(ref dX4, ref dY4, dCos, dSin);
         }

         dX1 += dX; dX1 = Math.Max(-180.0, Math.Min(dX1, 180.0));
         dX2 += dX; dX2 = Math.Max(-180.0, Math.Min(dX2, 180.0));
         dX3 += dX; dX3 = Math.Max(-180.0, Math.Min(dX3, 180.0));
         dX4 += dX; dX4 = Math.Max(-180.0, Math.Min(dX4, 180.0));
         dY1 += dY; dY1 = Math.Max(-90.0, Math.Min(dY1, 90.0));
         dY2 += dY; dY2 = Math.Max(-90.0, Math.Min(dY2, 90.0));
         dY3 += dY; dY3 = Math.Max(-90.0, Math.Min(dY3, 90.0));
         dY4 += dY; dY4 = Math.Max(-90.0, Math.Min(dY4, 90.0));


         return new GeographicQuad(dX1, dY1, dX2, dY2, dX3, dY3, dX4, dY4);
      }

      /// <summary>
      /// Go to worldwind URI
      /// </summary>
      public void Goto(WorldWind.Net.WorldWindUri uri)
      {
         GotoLatLon(
            uri.Latitude.Degrees, uri.Longitude.Degrees, uri.Direction.Degrees,
            uri.Altitude, uri.ViewRange.Degrees, uri.Tilt.Degrees);
         drawArgs.WorldCamera.Bank = uri.Bank;
         drawArgs.UpperLeftCornerText = uri.ToString();
         CurrentWorld.RenderableObjects.Enable(uri.Layer);
      }

      /// <summary>
      /// Moves to specified location.
      /// </summary>
      /// <param name="latitude">Latitude in degrees of target position. (-90 - 90).</param>
      /// <param name="longitude">Longitude in degrees of target position. (-180 - 180).</param>
      /// <param name="heading">Camera heading in degrees (0-360) or double.NaN for no change.</param>
      /// <param name="altitude">Camera altitude in meters or double.NaN for no change.</param>
      /// <param name="perpendicularViewRange"></param>
      /// <param name="tilt">Camera tilt in degrees (-90 - 90) or double.NaN for no change.</param>
      public void GotoLatLon(double latitude, double longitude, double heading, double altitude, double perpendicularViewRange, double tilt)
      {
         if (!double.IsNaN(perpendicularViewRange))
            altitude = m_World.EquatorialRadius * Math.Sin(MathEngine.DegreesToRadians(perpendicularViewRange * 0.5));
         if (altitude < 1)
            altitude = 1;
         this.drawArgs.WorldCamera.SlerpPercentage = World.Settings.CameraSlerpInertia;
         this.drawArgs.WorldCamera.SetPosition(latitude, longitude, heading, altitude, tilt);
      }

      public void GotoLatLon(double latitude, double longitude)
      {
         this.drawArgs.WorldCamera.SlerpPercentage = World.Settings.CameraSlerpInertia;
         this.drawArgs.WorldCamera.SetPosition(latitude, longitude,
            this.drawArgs.WorldCamera.Heading.Degrees,
            this.drawArgs.WorldCamera.Altitude,
            this.drawArgs.WorldCamera.Tilt.Degrees);
      }

      public void GotoLatLonAltitude(double latitude, double longitude, double altitude)
      {
         this.drawArgs.WorldCamera.SlerpPercentage = World.Settings.CameraSlerpInertia;
         this.drawArgs.WorldCamera.SetPosition(latitude, longitude,
            this.drawArgs.WorldCamera.Heading.Degrees,
            altitude,
            this.drawArgs.WorldCamera.Tilt.Degrees);
      }

      public void GotoLatLonHeadingViewRange(double latitude, double longitude, double heading, double perpendicularViewRange)
      {
         double altitude = m_World.EquatorialRadius * Math.Sin(MathEngine.DegreesToRadians(perpendicularViewRange * 0.5));
         this.GotoLatLonHeadingAltitude(latitude, longitude, heading, altitude);
      }

      public void GotoLatLonViewRange(double latitude, double longitude, double perpendicularViewRange)
      {
         double altitude = m_World.EquatorialRadius * Math.Sin(MathEngine.DegreesToRadians(perpendicularViewRange * 0.5));
         this.GotoLatLonHeadingAltitude(latitude, longitude, this.drawArgs.WorldCamera.Heading.Degrees, altitude);
      }

      public void GotoLatLonHeadingAltitude(double latitude, double longitude, double heading, double altitude)
      {
         this.drawArgs.WorldCamera.SlerpPercentage = World.Settings.CameraSlerpInertia;
         this.drawArgs.WorldCamera.SetPosition(latitude, longitude,
            heading,
            altitude,
            this.drawArgs.WorldCamera.Tilt.Degrees);
      }

      /// <summary>
      /// Saves the current view to file.
      /// </summary>
      /// <param name="filePath">Path and filename of output file.  
      /// Extension is used to determine the image format.</param>
      public void SaveScreenshot(string filePath)
      {
         if (m_Device3d == null)
            return;

         FileInfo saveFileInfo = new FileInfo(filePath);
         string ext = saveFileInfo.Extension.Replace(".", "");
         try
         {
            this.saveScreenShotImageFileFormat = (ImageFileFormat)Enum.Parse(typeof(ImageFileFormat), ext, true);
         }
         catch (ArgumentException)
         {
            throw new ApplicationException("Unknown file type/file extension for file '" + filePath + "'.  Unable to save.");
         }

         if (!saveFileInfo.Directory.Exists)
            saveFileInfo.Directory.Create();

         this.saveScreenShotFilePath = filePath;
      }

      /// <summary>
      /// The world render loop.  
      /// Borrowed from FlightGear and Tom Miller's blog
      /// </summary>
      public void OnApplicationIdle(object sender, EventArgs e)
      {
         // Sleep will always overshoot by a bit so under-sleep by
         // 2ms in the hopes of never oversleeping.
         const float SleepOverHeadSeconds = 2e-3f;

         // Overhead associated with displaying the frame
         const float PresentOverheadSeconds = 3e-4f;

         try
         {
            while (IsAppStillIdle)
            {
               if (!World.Settings.AlwaysRenderWindow && m_isRenderDisabled && !World.Settings.CameraHasMomentum)
                  return;

               Render();

               //if (World.Settings.ThrottleFpsHz > 0)
               //{
                  // DAPPLE: Ignore the setting, 20FPS should be just fine, 
                  // DAPPLE: we don't have animated moving objects (yet)
                  // optionally throttle the frame rate (to get consistent frame
                  // rates or reduce CPU usage.
                  //float frameSeconds = 1.0f / World.Settings.ThrottleFpsHz - PresentOverheadSeconds;
                  float frameSeconds = 1.0f / 20.0f - PresentOverheadSeconds;

                  // Sleep for remaining period of time until next render
                  float sleepSeconds = frameSeconds - SleepOverHeadSeconds - DrawArgs.SecondsSinceLastFrame;
                  if (sleepSeconds > 0)
                  {
                     // Don't sleep too long. We don't know the accuracy of Thread.Sleep
                     Thread.Sleep((int)(1000 * sleepSeconds));

                     // Burn off what little time still remains at 100% CPU load
                     //while (DrawArgs.SecondsSinceLastFrame < frameSeconds)
                     //{
                        // Patience
                     //}
                  }
               //}
               // Flip
               drawArgs.Present();
            }
         }
         catch (DeviceLostException)
         {
            AttemptRecovery();
         }
         catch (Exception caught)
         {
            Utility.Log.Write(caught);
         }
      }

      public void SafeRender()
      {
         try
         {
            Render();
            drawArgs.Present();
         }
         catch (DeviceLostException)
         {
            AttemptRecovery();
         }
         catch (Exception caught)
         {
            Utility.Log.Write(caught);
         }
      }

      /// <summary>
      /// Load a plugin from a path
      /// </summary>
      /// <param name="fullPath">the path of the code file or assembly containing the plugin</param>
      /// <returns>the plugin as an object</returns>
      public PluginEngine.Plugin GetPlugin(string fullPath)
      {
         try
         {
            return PluginCompiler.Load(fullPath);
         }
         catch (Exception)
         {
         }
         return null;
      }

      public bool AddPlugin(PluginEngine.Plugin plugin, string pluginPath)
      {
         if (CurrentWorld == null || plugin == null)
         {
            return false;
         }
         PluginCompiler.AddPlugin(plugin, this, pluginPath);
         return true;
      }

      public bool RemovePlugin(PluginEngine.Plugin plugin)
      {
         if (CurrentWorld == null || plugin == null)
         {
            return false;
         }
         PluginCompiler.RemovePlugin(plugin);
         return true;
      }
      #endregion

      /// <summary>
      /// Determine whether any window messages is queued.
      /// </summary>
      private static bool IsAppStillIdle
      {
         get
         {
            NativeMethods.Message msg;
            return !NativeMethods.PeekMessage(out msg, IntPtr.Zero, 0, 0, 0);
         }
      }

      /// <summary>
      /// Occurs when the control is redrawn and m_isRenderDisabled=true.
      /// All other painting is handled in WndProc.
      /// </summary>
      /// <param name="e"></param>
      protected override void OnPaint(PaintEventArgs e)
      {
         // Paint the last active scene if rendering is disabled to keep the ui responsive
         try
         {
            if (m_Device3d == null)
            {
               e.Graphics.Clear(SystemColors.Control);
               return;
            }

            m_Device3d.Present();
         }
         catch (DeviceLostException)
         {
            try
            {
               AttemptRecovery();

               // Our surface was lost, force re-render
               Render();
               m_Device3d.Present();
            }
            catch (DirectXException)
            {
               // Ignore a 2nd failure
            }
         }
      }

      public void ClearDevice()
      {
         m_Device3d.Clear(ClearFlags.Target, 0, 0, 0);
      }

      System.Collections.ArrayList m_FrameTimes = new ArrayList();
      WorldWind.Widgets.RootWidget m_RootWidget = null;

      /// <summary>
      /// Render the scene.
      /// </summary>
      public void Render()
      {
         long startTicks = 0;
         PerformanceTimer.QueryPerformanceCounter(ref startTicks);

         try
         {
            this.drawArgs.BeginRender();

            // Render the sky according to view - example, close to earth, render sky blue, render space as black
            System.Drawing.Color backgroundColor = System.Drawing.Color.Black;

            /*if (drawArgs.WorldCamera != null &&
               drawArgs.WorldCamera.Altitude < 1000000f &&
               m_World != null &&
               m_World.Name.IndexOf("Earth") >= 0)
            {
               float percent = 1 - (float)(drawArgs.WorldCamera.Altitude / 1000000);
               if (percent > 1.0f)
                  percent = 1.0f;
               else if (percent < 0.0f)
                  percent = 0.0f;

               backgroundColor = System.Drawing.Color.FromArgb(
                  (int)(World.Settings.SkyColor.R * percent),
                  (int)(World.Settings.SkyColor.G * percent),
                  (int)(World.Settings.SkyColor.B * percent));
            }*/

            m_Device3d.Clear(ClearFlags.Target | ClearFlags.ZBuffer, backgroundColor, 1.0f, 0);

            if (m_World == null)
            {
               m_Device3d.BeginScene();
               m_Device3d.EndScene();
               m_Device3d.Present();
               Thread.Sleep(25);
               return;
            }

            if (m_WorkerThread == null)
            {
               m_WorkerThreadRunning = true;
               m_WorkerThread = new Thread(new ThreadStart(WorkerThreadFunc));
               m_WorkerThread.Name = "WorldWindow.WorkerThreadFunc";
               m_WorkerThread.IsBackground = true;
               if (World.Settings.UseBelowNormalPriorityUpdateThread)
               {
                  m_WorkerThread.Priority = ThreadPriority.BelowNormal;
               }
               else
               {
                  m_WorkerThread.Priority = ThreadPriority.Normal;
               }
               // BelowNormal makes rendering smooth, but on slower machines updates become slow or stops
               // TODO: Implement dynamic FPS limiter (or different solution)
               m_WorkerThread.Start();
            }

            this.drawArgs.WorldCamera.Update(m_Device3d);

            m_Device3d.BeginScene();

            // Set fill mode
            if (renderWireFrame)
               m_Device3d.RenderState.FillMode = FillMode.WireFrame;
            else
               m_Device3d.RenderState.FillMode = FillMode.Solid;

            drawArgs.RenderWireFrame = renderWireFrame;

            // Render the current planet
            m_World.Render(this.drawArgs);

            if (World.Settings.ShowCrosshairs)
               this.DrawCrossHairs();

            frameCounter++;
            if (frameCounter == 30)
            {
               fps = frameCounter / (float)(DrawArgs.CurrentFrameStartTicks - lastFpsUpdateTime) * PerformanceTimer.TicksPerSecond;
               frameCounter = 0;
               lastFpsUpdateTime = DrawArgs.CurrentFrameStartTicks;
            }

            if (saveScreenShotFilePath != null)
               SaveScreenShot();

            drawArgs.device.RenderState.ZBufferEnable = false;

            // 3D rendering complete, switch to 2D for UI rendering

            // Restore normal fill mode
            if (renderWireFrame)
               m_Device3d.RenderState.FillMode = FillMode.Solid;

            // Disable fog for UI
            m_Device3d.RenderState.FogEnable = false;

            RenderPositionInfo();

            try
            {
               m_RootWidget.Render(drawArgs);
            }
            catch (Exception ex)
            {
               Utility.Log.Write(ex);
            }
            if (m_World.OnScreenMessages != null)
            {
               try
               {
                  foreach (OnScreenMessage dm in m_World.OnScreenMessages)
                  {
                     int xPos = (int)Math.Round(dm.X * this.Width);
                     int yPos = (int)Math.Round(dm.Y * this.Height);
                     Rectangle posRect =
                        new Rectangle(xPos, yPos, this.Width, this.Height);
                     this.drawArgs.defaultDrawingFont.DrawText(null,
                        dm.Message, posRect,
                        DrawTextFormat.NoClip | DrawTextFormat.WordBreak,
                        Color.White);
                  }
               }
               catch (Exception)
               {
                  // Don't let a script error cancel the frame.
               }
            }

            m_Device3d.EndScene();
         }
         finally
         {
            this.drawArgs.EndRender();
         }
         drawArgs.UpdateMouseCursor(this);
      }

      private const int positionAlphaStep = 20;
      private int positionAlpha = 255;
      private int positionAlphaMin = 40;
      private int positionAlphaMax = 205;

      protected void RenderPositionInfo()
      {
         // Render some Development information to screen
         string captionText = _caption;

         captionText += "\n" + this.drawArgs.UpperLeftCornerText;

         if (World.Settings.ShowPosition)
         {
            // TODO: Configurable transparent number->string conversion (metric/imperial etc units)
            string alt = null;
            float agl = (float)this.drawArgs.WorldCamera.AltitudeAboveTerrain;
            if (agl > 100000)
               alt = string.Format("{0:f2}km", agl / 1000);
            else
               alt = string.Format("{0:f0}m", agl);
            string dist = null;
            float dgl = (float)this.drawArgs.WorldCamera.Distance;
            if (dgl > 100000)
               dist = string.Format("{0:f2}km", dgl / 1000);
            else
               dist = string.Format("{0:f0}m", dgl);

            // Heading from 0 - 360
            double heading = this.drawArgs.WorldCamera.Heading.Degrees;
            if (heading < 0)
               heading += 360;
            /*captionText += String.Format("Latitude: {0}\nLongitude: {1}\nHeading: {2:f2}°\nTilt: {3}\nAltitude: {4}\nDistance: {5}\nFOV: {6}",
               new Latitude(this.drawArgs.WorldCamera.Latitude.Degrees),
               new Longitude(this.drawArgs.WorldCamera.Longitude.Degrees),
               heading,
               this.drawArgs.WorldCamera.Tilt,
               alt,
               dist,
               this.drawArgs.WorldCamera.Fov);*/
            captionText += String.Format("Latitude: {0}\nLongitude: {1}\nHeading: {2:f2}°\nTilt: {3}\nAltitude: {4}\nDistance: {5}",
               new Latitude(this.drawArgs.WorldCamera.Latitude.Degrees),
               new Longitude(this.drawArgs.WorldCamera.Longitude.Degrees),
               heading,
               this.drawArgs.WorldCamera.Tilt,
               alt,
               dist);

            if (agl < 300000)
            {
               captionText += String.Format("\nTerrain Elevation: {0:n} meters\n", this.drawArgs.WorldCamera.TerrainElevation);
            }
         }

         if (this.showDiagnosticInfo)
            captionText +=
               "\nAvailable Texture Memory: " + (m_Device3d.AvailableTextureMemory / 1024).ToString("N0") + " kB" +
               "\nBoundary Points: " + this.drawArgs.numBoundaryPointsRendered.ToString() + " / " + this.drawArgs.numBoundaryPointsTotal.ToString() + " : " + this.drawArgs.numBoundariesDrawn.ToString() +
               "\nTiles Drawn: " + (this.drawArgs.numberTilesDrawn * 0.25f).ToString() +
               "\n" + this.drawArgs.WorldCamera +
               "\nFPS: " + this.fps.ToString("f1") +
               "\nRO: " + m_World.RenderableObjects.Count.ToString("f0") +
               "\nmLat: " + this.cLat.Degrees.ToString() +
               "\nmLon: " + this.cLon.Degrees.ToString();


         captionText = captionText.Trim();
         DrawTextFormat dtf = DrawTextFormat.NoClip | DrawTextFormat.WordBreak | DrawTextFormat.Right;
         int x = 7;
         int y = 7;//_menuBar!=null && World.Settings.ShowToolbar ? 65 : 7;
         Rectangle textRect = Rectangle.FromLTRB(x, y, this.Width - 8, this.Height - 8);

         // Hide position info when toolbar is open
         //if (_menuBar.IsActive)
         //{
         //   positionAlpha -= positionAlphaStep;
         //   if (positionAlpha<positionAlphaMin)
         //   {
         //      positionAlpha=positionAlphaMin;
         //   }
         //}
         //else
         //{
         positionAlpha += positionAlphaStep;
         if (positionAlpha > positionAlphaMax)
            positionAlpha = positionAlphaMax;
         //}

         int positionBackColor = positionAlpha << 24;
         int positionForeColor = (int)((uint)(positionAlpha << 24) + 0xffffffu);
         this.drawArgs.defaultDrawingFont.DrawText(null, captionText, textRect, dtf, positionBackColor);
         textRect.Offset(-1, -1);
         this.drawArgs.defaultDrawingFont.DrawText(null, captionText, textRect, dtf, positionForeColor);
      }


      /// <summary>
      /// Draws a small cross hairs for the user to pinpoint the exact lat/lon
      /// TODO: Make this user-resizeable and color customizable
      /// </summary>
      Line crossHairs;
      int crossHairColor = Color.GhostWhite.ToArgb();
      protected void DrawCrossHairs()
      {
         int crossHairSize = 10;

         if (this.crossHairs == null)
         {
            crossHairs = new Line(m_Device3d);
         }

         Vector2[] vertical = new Vector2[2];
         Vector2[] horizontal = new Vector2[2];

         horizontal[0].X = this.Width / 2 - crossHairSize;
         horizontal[0].Y = this.Height / 2;
         horizontal[1].X = this.Width / 2 + crossHairSize;
         horizontal[1].Y = this.Height / 2;

         vertical[0].X = this.Width / 2;
         vertical[0].Y = this.Height / 2 - crossHairSize;
         vertical[1].X = this.Width / 2;
         vertical[1].Y = this.Height / 2 + crossHairSize;

         crossHairs.Begin();
         crossHairs.Draw(horizontal, crossHairColor);
         crossHairs.Draw(vertical, crossHairColor);
         crossHairs.End();
      }

      /// <summary>
      /// Attempt to restore the 3D m_Device3d
      /// </summary>
      protected void AttemptRecovery()
      {
         try
         {
            m_Device3d.TestCooperativeLevel();
         }
         catch (DeviceLostException)
         {
         }
         catch (DeviceNotResetException)
         {
            try
            {
               m_Device3d.Reset(m_presentParams);
            }
            catch (DeviceLostException)
            {
               // If it's still lost or lost again, just do
               // nothing
            }
         }
      }

      #region Event handlers

      /// <summary>
      /// Occurs when the mouse wheel moves while the control has focus.
      /// </summary>
      protected override void OnMouseWheel(MouseEventArgs e)
      {
         try
         {
            //if(this._menuBar.OnMouseWheel(e))
            //   return;

            this.drawArgs.WorldCamera.SlerpPercentage = World.Settings.CameraSlerpInertia * 2;
            this.drawArgs.WorldCamera.ZoomStepped(-e.Delta / 120.0f);
         }
         finally
         {
            // Call the base class's OnMouseWheel method so that registered delegates receive the event.
            base.OnMouseWheel(e);
         }
      }

      /// <summary>
      /// Occurs when a key is pressed while the control has focus.
      /// </summary>
      protected override void OnKeyDown(KeyEventArgs e)
      {
         try
         {
            e.Handled = HandleKeyDown(e);
            base.OnKeyDown(e);
         }
         catch (Exception caught)
         {
            MessageBox.Show(caught.Message, "Operation failed", MessageBoxButtons.OK, MessageBoxIcon.Error);
         }
      }

      /// <summary>
      /// Occurs when a key is released while the control has focus.
      /// </summary>
      protected override void OnKeyUp(KeyEventArgs e)
      {
         try
         {
            e.Handled = HandleKeyUp(e);
            base.OnKeyUp(e);
         }
         catch (Exception caught)
         {
            MessageBox.Show(caught.Message, "Operation failed", MessageBoxButtons.OK, MessageBoxIcon.Error);
         }
      }

      protected override void OnKeyPress(KeyPressEventArgs e)
      {
         if (m_RootWidget != null)
         {
            bool handled = m_RootWidget.OnKeyPress(e);
            e.Handled = handled;
         }
         base.OnKeyPress(e);
      }


      /// <summary>
      /// Preprocess keyboard or input messages within the message loop before they are dispatched.
      /// </summary>
      /// <param name="msg">A Message, passed by reference, that represents the message to process. 
      /// The possible values are WM_KEYDOWN, WM_SYSKEYDOWN, WM_CHAR, and WM_SYSCHAR.</param>
      [SecurityPermission(SecurityAction.LinkDemand, UnmanagedCode = true), SecurityPermission(SecurityAction.InheritanceDemand, UnmanagedCode = true)]
      public override bool PreProcessMessage(ref Message msg)
      {
         const int WM_KEYDOWN = 0x0100;

         // it's the only way to handle arrow keys in OnKeyDown
         if (msg.Msg == WM_KEYDOWN)
         {
            Keys key = (Keys)msg.WParam.ToInt32();
            switch (key)
            {
               case Keys.Left:
               case Keys.Up:
               case Keys.Right:
               case Keys.Down:
                  OnKeyDown(new KeyEventArgs(key));
                  // mark message as processed
                  msg.Result = (IntPtr)1;
                  // When overriding PreProcessMessage, a control should return true to indicate that it has processed the message.
                  return true;
            }
         }

         return base.PreProcessMessage(ref msg);
      }


      /// <summary>
      /// Handles key down events.
      /// </summary>
      /// <param name="e"></param>
      /// <returns>Returns true if the key is handled.</returns>
      protected bool HandleKeyDown(KeyEventArgs e)
      {
         bool handled = this.m_RootWidget.OnKeyDown(e);
         if (handled)
            return handled;

         // Alt key down
         if (e.Alt)
         {
            switch (e.KeyCode)
            {
               case Keys.C:
                  World.Settings.ShowCrosshairs = !World.Settings.ShowCrosshairs;
                  return true;
               case Keys.Add:
               case Keys.Oemplus:
               case Keys.Home:
               case Keys.NumPad7:
                  this.drawArgs.WorldCamera.Fov -= Angle.FromDegrees(5);
                  return true;
               case Keys.Subtract:
               case Keys.OemMinus:
               case Keys.End:
               case Keys.NumPad1:
                  this.drawArgs.WorldCamera.Fov += Angle.FromDegrees(5);
                  return true;
            }
         }
         // Control key down
         else if (e.Control)
         {
         }
         // Other and no control key
         else
         {
            switch (e.KeyCode)
            {
               // reset north
               case Keys.N:
                  this.drawArgs.WorldCamera.SlerpPercentage = World.Settings.CameraSlerpInertia;
                  this.DrawArgs.WorldCamera.SetPosition(
                  this.Latitude,
                  this.Longitude,
                   0,
                   this.DrawArgs.WorldCamera.Altitude,
                   this.DrawArgs.WorldCamera.Tilt.Degrees);
                  return true;
               // reset Tilt
               case Keys.T:
                  this.drawArgs.WorldCamera.SlerpPercentage = World.Settings.CameraSlerpInertia;
                  this.DrawArgs.WorldCamera.SetPosition(
                  this.Latitude,
                  this.Longitude,
                   this.DrawArgs.WorldCamera.Heading.Degrees,
                   this.DrawArgs.WorldCamera.Altitude,
                   0);
                  return true;
               // rotate left
               case Keys.A:
                  this.drawArgs.WorldCamera.SlerpPercentage = 1.0;
                  Angle rotateClockwise = Angle.FromRadians(0.01f);
                  this.drawArgs.WorldCamera.Heading += rotateClockwise;
                  this.drawArgs.WorldCamera.RotationYawPitchRoll(Angle.Zero, Angle.Zero, rotateClockwise);
                  return true;
               // rotate right
               case Keys.D:
                  this.drawArgs.WorldCamera.SlerpPercentage = 1.0; 
                  Angle rotateCounterclockwise = Angle.FromRadians(-0.01f);
                  this.drawArgs.WorldCamera.Heading += rotateCounterclockwise;
                  this.drawArgs.WorldCamera.RotationYawPitchRoll(Angle.Zero, Angle.Zero, rotateCounterclockwise);
                  return true;
               // rotate up
               case Keys.W:
                  this.drawArgs.WorldCamera.SlerpPercentage = 1.0; 
                  this.drawArgs.WorldCamera.Tilt += Angle.FromDegrees(-1.0f);
                  return true;
               // rotate down
               case Keys.S:
                  this.drawArgs.WorldCamera.SlerpPercentage = 1.0;
                  this.drawArgs.WorldCamera.Tilt += Angle.FromDegrees(1.0f);
                  return true;
               // pan left
               case Keys.Left:
               case Keys.H:
               case Keys.NumPad4:
                  // TODO: pan n pixels
                  this.drawArgs.WorldCamera.SlerpPercentage = 1.0;
                  Angle panLeft = Angle.FromRadians((float)-1 * (this.drawArgs.WorldCamera.Altitude) * (1 / (300 * this.CurrentWorld.EquatorialRadius)));
                  this.drawArgs.WorldCamera.RotationYawPitchRoll(panLeft, Angle.Zero, Angle.Zero);
                  return true;
               // pan down
               case Keys.Down:
               case Keys.J:
               case Keys.NumPad2:
                  this.drawArgs.WorldCamera.SlerpPercentage = 1.0;
                  Angle panDown = Angle.FromRadians((float)-1 * (this.drawArgs.WorldCamera.Altitude) * (1 / (300 * this.CurrentWorld.EquatorialRadius)));
                  this.drawArgs.WorldCamera.RotationYawPitchRoll(Angle.Zero, panDown, Angle.Zero);
                  return true;
               // pan right
               case Keys.Right:
               case Keys.K:
               case Keys.NumPad6:
                  this.drawArgs.WorldCamera.SlerpPercentage = 1.0;
                  Angle panRight = Angle.FromRadians((float)1 * (this.drawArgs.WorldCamera.Altitude) * (1 / (300 * this.CurrentWorld.EquatorialRadius)));
                  this.drawArgs.WorldCamera.RotationYawPitchRoll(panRight, Angle.Zero, Angle.Zero);
                  return true;
               // pan up
               case Keys.Up:
               case Keys.U:
               case Keys.NumPad8:
                  // TODO: Pan n pixels
                  this.drawArgs.WorldCamera.SlerpPercentage = 1.0;
                  Angle panUp = Angle.FromRadians((float)1 * (this.drawArgs.WorldCamera.Altitude) * (1 / (300 * this.CurrentWorld.EquatorialRadius)));
                  this.drawArgs.WorldCamera.RotationYawPitchRoll(Angle.Zero, panUp, Angle.Zero);
                  return true;
               // zoom in
               case Keys.Add:
               case Keys.Oemplus:
               case Keys.Home:
               case Keys.NumPad7:
                  this.drawArgs.WorldCamera.SlerpPercentage = 1.0;
                  this.drawArgs.WorldCamera.ZoomStepped(World.Settings.CameraZoomStepKeyboard);
                  return true;
               // zoom out
               case Keys.Subtract:
               case Keys.OemMinus:
               case Keys.End:
               case Keys.NumPad1:
                  this.drawArgs.WorldCamera.SlerpPercentage = 1.0;
                  this.drawArgs.WorldCamera.ZoomStepped(-World.Settings.CameraZoomStepKeyboard);
                  return true;
            }
         }
         return false;
      }

      /// <summary>
      /// Handles key up events.
      /// </summary>
      /// <param name="e"></param>
      /// <returns>Returns true if the key is handled.</returns>
      protected bool HandleKeyUp(KeyEventArgs e)
      {
         bool handled = m_RootWidget.OnKeyUp(e);
         if (handled)
         {
            e.Handled = handled;
            return handled;
         }

         // Alt key down
         if (e.Alt)
         {
         }
         // Control key down
         else if (e.Control)
         {
            switch (e.KeyCode)
            {
#if DEBUG
               case Keys.H:
                  if (progressMonitor != null)
                  {
                     bool wasVisible = progressMonitor.Visible;
                     progressMonitor.Close();
                     progressMonitor.Dispose();
                     progressMonitor = null;
                     if (wasVisible)
                        return true;
                  }

                  progressMonitor = new ProgressMonitor();
                  progressMonitor.Show();
                  return true;
#endif
               case Keys.D:
                  this.showDiagnosticInfo = !this.showDiagnosticInfo;
                  return true;
               case Keys.W:
                  renderWireFrame = !renderWireFrame;
                  return true;
            }
         }
         // Other and no control key
         else
         {
            switch (e.KeyCode)
            {
               case Keys.Space:
               case Keys.Clear:
                  this.drawArgs.WorldCamera.SlerpPercentage = World.Settings.CameraSlerpInertia;
                  this.drawArgs.WorldCamera.Reset();
                  return true;
            }
         }
         return false;
      }

      protected override void OnMouseDown(MouseEventArgs e)
      {
         DrawArgs.LastMousePosition.X = e.X;
         DrawArgs.LastMousePosition.Y = e.Y;

         mouseDownStartPosition.X = e.X;
         mouseDownStartPosition.Y = e.Y;


         try
         {
            bool handled = false;
            handled = m_RootWidget.OnMouseDown(e);

//            if (!handled)
//            {
//               if (this._menuBar.OnMouseDown(e))
//                  return;
//            }
         }
         finally
         {
				if(e.Button == MouseButtons.Left)
					DrawArgs.IsLeftMouseButtonDown = true;

				if(e.Button == MouseButtons.Right)
					DrawArgs.IsRightMouseButtonDown = true;
            // Call the base class method so that registered delegates receive the event.
            base.OnMouseDown(e);
         }
      }

      protected override void OnMouseDoubleClick(MouseEventArgs e)
      {
         DrawArgs.LastMousePosition.X = e.X;
         DrawArgs.LastMousePosition.Y = e.Y;

         try
         {
            bool handled = false;

            handled = m_RootWidget.OnMouseDoubleClick(e);

            if (!handled)
            {
               // Mouse must have been clicked outside our window and released on us, ignore
               if (mouseDownStartPosition == Point.Empty)
                  return;

               mouseDownStartPosition = Point.Empty;

               //					if(!this.isMouseDragging)
               //					{
               //						if(this._menuBar.OnMouseUp(e))
               //							return;
               //					}

               if (m_World == null)
                  return;

               double Coeff;
               double ZoomFactIn = 0.25;
               double ZoomFactOut = 0.2;

               if (e.Button == MouseButtons.Right)
                  Coeff = 1 / ZoomFactOut;
               else
                  Coeff = ZoomFactIn;
               GotoLatLonAltitude(this.targetLatitude.Degrees, this.targetLongitude.Degrees, Coeff * this.drawArgs.WorldCamera.Altitude);
            }
         }
         finally
         {
            if (e.Button == MouseButtons.Left)
               DrawArgs.IsLeftMouseButtonDown = false;

            if (e.Button == MouseButtons.Right)
               DrawArgs.IsRightMouseButtonDown = false;

            // Call the base class method so that registered delegates receive the event.
            base.OnMouseDoubleClick(e);
         }
      }

      protected override void OnMouseClick(MouseEventArgs e)
      {
         DrawArgs.LastMousePosition.X = e.X;
         DrawArgs.LastMousePosition.Y = e.Y;

         try
         {

            bool handled = false;

            handled = m_RootWidget.OnMouseClick(e);

            if (!handled)
            {
               // Mouse must have been clicked outside our window and released on us, ignore
               if (mouseDownStartPosition == Point.Empty)
                  return;

               mouseDownStartPosition = Point.Empty;

               //					if(!this.isMouseDragging)
               //					{
               //						if(this._menuBar.OnMouseUp(e))
               //							return;
               //					}

               if (m_World == null)
                  return;

               if (this.isMouseDragging)
                  this.isMouseDragging = false;
               else if (!m_World.PerformSelectionAction(this.drawArgs))
               {
                  //Quaternion targetOrientation = new Quaternion();
                  this.drawArgs.WorldCamera.PickingRayIntersection(
                     DrawArgs.LastMousePosition.X,
                     DrawArgs.LastMousePosition.Y,
                     out this.targetLatitude,
                     out this.targetLongitude);
                  if (!Angle.IsNaN(targetLatitude))
                  {
                     this.drawArgs.WorldCamera.SlerpPercentage = World.Settings.CameraSlerpInertia;
                     this.drawArgs.WorldCamera.PointGoto(targetLatitude, targetLongitude);
                  }
               }
            }
         }
         finally
         {
            if (e.Button == MouseButtons.Left)
               DrawArgs.IsLeftMouseButtonDown = false;

            if (e.Button == MouseButtons.Right)
               DrawArgs.IsRightMouseButtonDown = false;
            // Call the base class method so that registered delegates receive the event.
            base.OnMouseClick(e);
         }
      }

      protected override void OnMouseUp(MouseEventArgs e)
      {
         DrawArgs.LastMousePosition.X = e.X;
         DrawArgs.LastMousePosition.Y = e.Y;

         try
         {

            bool handled = false;

            handled = m_RootWidget.OnMouseUp(e);

            if (!handled)
            {
            }
         }
         finally
         {
            // Call the base class method so that registered delegates receive the event.
            base.OnMouseUp(e);
         }
      }

      protected override void OnMouseMove(MouseEventArgs e)
      {
         // Default to default cursor
         DrawArgs.MouseCursor = CursorType.Arrow;

         try
         {
            bool handled = false;
            handled = m_RootWidget.OnMouseMove(e);


            if (!handled)
            {
               int deltaX = e.X - DrawArgs.LastMousePosition.X;
               int deltaY = e.Y - DrawArgs.LastMousePosition.Y;
               float deltaXNormalized = (float)deltaX / drawArgs.screenWidth;
               float deltaYNormalized = (float)deltaY / drawArgs.screenHeight;

               //if(!this.isMouseDragging)
               //{
               //   if(this._menuBar.OnMouseMove(e))
               //   {
               //      base.OnMouseMove(e);
               //      return;
               //   }
               //}

               if (mouseDownStartPosition == Point.Empty)
                  return;

               bool isMouseLeftButtonDown = ((int)e.Button & (int)MouseButtons.Left) != 0;
               bool isMouseRightButtonDown = ((int)e.Button & (int)MouseButtons.Right) != 0;
               if (isMouseLeftButtonDown || isMouseRightButtonDown)
               {
                  int dx = this.mouseDownStartPosition.X - e.X;
                  int dy = this.mouseDownStartPosition.Y - e.Y;
                  int distanceSquared = dx * dx + dy * dy;
                  if (distanceSquared > 3 * 3)
                     // Distance > 3 = drag
                     this.isMouseDragging = true;
               }

               if (isMouseLeftButtonDown && !isMouseRightButtonDown)
               {
                  // Left button (pan)
                  // Store start lat/lon for drag
                  Angle prevLat, prevLon;
                  this.drawArgs.WorldCamera.PickingRayIntersection(
                     DrawArgs.LastMousePosition.X,
                     DrawArgs.LastMousePosition.Y,
                     out prevLat,
                     out prevLon);

                  Angle curLat, curLon;
                  this.drawArgs.WorldCamera.PickingRayIntersection(
                     e.X,
                     e.Y,
                     out curLat,
                     out curLon);

                  if (World.Settings.CameraTwistLock)
                  {
                     this.drawArgs.WorldCamera.SlerpPercentage = 1.0;
                     if (Angle.IsNaN(curLat) || Angle.IsNaN(prevLat))
                     {
                        // Old style pan
                        Angle deltaLat = Angle.FromRadians((double)deltaY * (this.drawArgs.WorldCamera.Altitude) / (800 * this.CurrentWorld.EquatorialRadius));
                        Angle deltaLon = Angle.FromRadians((double)-deltaX * (this.drawArgs.WorldCamera.Altitude) / (800 * this.CurrentWorld.EquatorialRadius));
                        this.drawArgs.WorldCamera.Pan(deltaLat, deltaLon);
                     }
                     else
                     {
                        //Picking ray pan
                        Angle lat = prevLat - curLat;
                        Angle lon = prevLon - curLon;
                        this.drawArgs.WorldCamera.Pan(lat, lon);
                     }
                  }
                  else
                  {
                     double factor = (this.drawArgs.WorldCamera.Altitude) / (1500 * this.CurrentWorld.EquatorialRadius);
                     this.drawArgs.WorldCamera.SlerpPercentage = 1.0;
                     drawArgs.WorldCamera.RotationYawPitchRoll(
                        Angle.FromRadians(DrawArgs.LastMousePosition.X - e.X) * factor,
                        Angle.FromRadians(e.Y - DrawArgs.LastMousePosition.Y) * factor,
                        Angle.Zero);
                  }
               }
               else if (!isMouseLeftButtonDown && isMouseRightButtonDown)
               {
                  //Right mouse button

                  // Heading
                  Angle deltaEyeDirection = Angle.FromRadians(-deltaXNormalized * World.Settings.CameraRotationSpeed);
                  this.drawArgs.WorldCamera.SlerpPercentage = 1.0;
                  this.drawArgs.WorldCamera.RotationYawPitchRoll(Angle.Zero, Angle.Zero, deltaEyeDirection);

                  // tilt
                  this.drawArgs.WorldCamera.Tilt += Angle.FromRadians(deltaYNormalized * World.Settings.CameraRotationSpeed);
               }
               else if (isMouseLeftButtonDown && isMouseRightButtonDown)
               {
                  // Both buttons (zoom)
                  this.drawArgs.WorldCamera.SlerpPercentage = 1.0;
                  if (Math.Abs(deltaYNormalized) > float.Epsilon)
                     this.drawArgs.WorldCamera.Zoom(-deltaYNormalized * World.Settings.CameraZoomAnalogFactor);

                  if (!World.Settings.CameraBankLock)
                     this.drawArgs.WorldCamera.Bank -= Angle.FromRadians(deltaXNormalized * World.Settings.CameraRotationSpeed);
               }
            }
         }
         catch
         {
         }
         finally
         {

            this.drawArgs.WorldCamera.PickingRayIntersection(
               e.X,
               e.Y,
               out cLat,
               out cLon);

            DrawArgs.LastMousePosition.X = e.X;
            DrawArgs.LastMousePosition.Y = e.Y;
            base.OnMouseMove(e);
         }
      }

      Angle cLat, cLon;
      protected override void OnMouseLeave(EventArgs e)
      {
         //if(_menuBar!=null)
         //   // reset menu bar mouse hover state.
         //   _menuBar.OnMouseMove(new MouseEventArgs(MouseButtons.None, 0,-1,-1,0));
         base.OnMouseLeave(e);
      }

      #endregion

      protected void SaveScreenShot()
      {
         try
         {
            using (Surface backbuffer = m_Device3d.GetBackBuffer(0, 0, BackBufferType.Mono))
               SurfaceLoader.Save(saveScreenShotFilePath, saveScreenShotImageFileFormat, backbuffer);
            saveScreenShotFilePath = null;
         }
         catch (InvalidCallException caught)
         {
            MessageBox.Show(caught.Message, "Screenshot save failed.", MessageBoxButtons.OK, MessageBoxIcon.Error);
         }
      }

      /// <summary>
      /// Clean up any resources being used.
      /// </summary>
      protected override void Dispose(bool disposing)
      {
         if (disposing)
         {
            if (m_WorkerThread != null && m_WorkerThread.IsAlive)
            {
               m_WorkerThreadRunning = false;
               if (!m_WorkerThread.Join(new TimeSpan(0, 0, 1)))
               {
                  m_WorkerThread.Abort();
               }
            }
            if (m_World != null)
            {
               m_World.Dispose();
               m_World = null;
            }
            if (this.drawArgs != null)
            {
               this.drawArgs.Dispose();
               this.drawArgs = null;
            }

            //TODO: Ensure user is not held up here
            try
            {
               m_Device3d.Dispose();
            }
            catch { }
         }

         base.Dispose(disposing);
         GC.SuppressFinalize(this);
      }

      private void m_Device3d_DeviceResizing(object sender, CancelEventArgs e)
      {
         if (this.Size.Width == 0 || this.Size.Height == 0)
         {
            e.Cancel = true;
            return;
         }

         this.drawArgs.screenHeight = this.Height;
         this.drawArgs.screenWidth = this.Width;
      }


      /// <summary>
      /// Returns true if executing in Design mode (inside IDE)
      /// </summary>
      /// <returns></returns>
      private static bool IsInDesignMode()
      {
         return Application.ExecutablePath.ToUpper(CultureInfo.InvariantCulture).EndsWith("DEVENV.EXE");
      }

      private void InitializeGraphics()
      {
         // Set up our presentation parameters
         m_presentParams = new PresentParameters();

         m_presentParams.Windowed = true;
         m_presentParams.SwapEffect = SwapEffect.Discard;
         m_presentParams.AutoDepthStencilFormat = DepthFormat.D16;
         m_presentParams.EnableAutoDepthStencil = true;

         if (!World.Settings.VSync)
            // Disable wait for vertical retrace (higher frame rate at the expense of tearing)
            m_presentParams.PresentationInterval = PresentInterval.Immediate;

         int adapterOrdinal = 0;
         try
         {
            // Store the default adapter
            adapterOrdinal = Manager.Adapters.Default.Adapter;
         }
         catch
         {
            // User probably needs to upgrade DirectX or install a 3D capable graphics adapter
            throw new NotAvailableException();
         }

         DeviceType dType = DeviceType.Hardware;

         foreach (AdapterInformation ai in Manager.Adapters)
         {
            if (ai.Information.Description.IndexOf("NVPerfHUD") >= 0)
            {
               adapterOrdinal = ai.Adapter;
               dType = DeviceType.Reference;
            }
         }
         CreateFlags flags = CreateFlags.SoftwareVertexProcessing;

         // Check to see if we can use a pure hardware m_Device3d
         Caps caps = Manager.GetDeviceCaps(adapterOrdinal, DeviceType.Hardware);

         // Do we support hardware vertex processing?
         if (caps.DeviceCaps.SupportsHardwareTransformAndLight)
            //	// Replace the software vertex processing
            flags = CreateFlags.HardwareVertexProcessing;

         // Use multi-threading for now - TODO: See if the code can be changed such that this isn't necessary (Texture Loading for example)
			flags |= CreateFlags.MultiThreaded | CreateFlags.FpuPreserve;

         if (World.Settings.AllowPureDevice && caps.DeviceCaps.SupportsPureDevice)
         {
            flags |= CreateFlags.PureDevice;
         }

         try
         {
            // Create our m_Device3d
            m_Device3d = new Device(adapterOrdinal, dType, this, flags, m_presentParams);
         }
         catch (Microsoft.DirectX.DirectXException)
         {
            throw new NotSupportedException("Unable to create the Direct3D m_Device3d.");
         }

         // Hook the m_Device3d reset event
         m_Device3d.DeviceReset += new EventHandler(OnDeviceReset);
         m_Device3d.DeviceResizing += new CancelEventHandler(m_Device3d_DeviceResizing);
         OnDeviceReset(m_Device3d, null);
      }

      private void OnDeviceReset(object sender, EventArgs e)
      {
         // Can we use anisotropic texture minify filter?
         if (m_Device3d.DeviceCaps.TextureFilterCaps.SupportsMinifyAnisotropic)
         {
            m_Device3d.SamplerState[0].MinFilter = TextureFilter.Anisotropic;
         }
         else if (m_Device3d.DeviceCaps.TextureFilterCaps.SupportsMinifyLinear)
         {
            m_Device3d.SamplerState[0].MinFilter = TextureFilter.Linear;
         }

         // What about magnify filter?
         if (m_Device3d.DeviceCaps.TextureFilterCaps.SupportsMagnifyAnisotropic)
         {
            m_Device3d.SamplerState[0].MagFilter = TextureFilter.Anisotropic;
         }
         else if (m_Device3d.DeviceCaps.TextureFilterCaps.SupportsMagnifyLinear)
         {
            m_Device3d.SamplerState[0].MagFilter = TextureFilter.Linear;
         }

         m_Device3d.SamplerState[0].AddressU = TextureAddress.Clamp;
         m_Device3d.SamplerState[0].AddressV = TextureAddress.Clamp;

         m_Device3d.RenderState.Clipping = true;
         m_Device3d.RenderState.CullMode = Cull.Clockwise;
         m_Device3d.RenderState.Lighting = false;
         m_Device3d.RenderState.Ambient = Color.FromArgb(0x40, 0x40, 0x40);

         m_Device3d.RenderState.ZBufferEnable = true;
         m_Device3d.RenderState.AlphaBlendEnable = true;
         m_Device3d.RenderState.SourceBlend = Blend.SourceAlpha;
         m_Device3d.RenderState.DestinationBlend = Blend.InvSourceAlpha;
      }


      /// <summary>
      /// Background worker thread loop (updates UI)
      /// </summary>
      public delegate void UpdatedDelegate();
      public event UpdatedDelegate Updated;
      private void WorkerThreadFunc()
      {
         const int refreshIntervalMs = 150; // Max 6 updates per seconds
         while (m_WorkerThreadRunning)
         {
            try
            {
               if (World.Settings.UseBelowNormalPriorityUpdateThread && m_WorkerThread.Priority == System.Threading.ThreadPriority.Normal)
               {
                  m_WorkerThread.Priority = System.Threading.ThreadPriority.BelowNormal;
               }
               else if (!World.Settings.UseBelowNormalPriorityUpdateThread && m_WorkerThread.Priority == System.Threading.ThreadPriority.BelowNormal)
               {
                  m_WorkerThread.Priority = System.Threading.ThreadPriority.Normal;
               }
               long startTicks = 0;
               PerformanceTimer.QueryPerformanceCounter(ref startTicks);


               m_World.Update(this.drawArgs);
               if (Updated != null)
                  Updated();

               long endTicks = 0;
               PerformanceTimer.QueryPerformanceCounter(ref endTicks);
               float elapsedMilliSeconds = 1000 * (float)(endTicks - startTicks) / PerformanceTimer.TicksPerSecond;
               float remaining = refreshIntervalMs - elapsedMilliSeconds;
               if (remaining > 0)
                  Thread.Sleep((int)remaining);
            }
            catch (Exception caught)
            {
               Utility.Log.Write(caught);
            }
         }
      }

      #region IGlobe Members

      public void SetDisplayMessages(IList messages)
      {
         m_World.OnScreenMessages = messages;
      }

      public void SetLatLonGridShow(bool show)
      {
         World.Settings.ShowLatLonLines = show;
      }

      public void SetLayers(IList layers)
      {
         if (layers != null)
         {
            foreach (LayerDescriptor ld in layers)
            {
               this.CurrentWorld.SetLayerOpacity(ld.Category, ld.Name, (float)ld.Opacity * 0.01f);
            }
         }
      }

      public void SetVerticalExaggeration(double exageration)
      {
         World.Settings.VerticalExaggeration = (float)exageration;
      }

      public void SetViewDirection(String type, double horiz, double vert, double elev)
      {
         this.drawArgs.WorldCamera.SlerpPercentage = World.Settings.CameraSlerpInertia;
         this.drawArgs.WorldCamera.SetPosition(this.drawArgs.WorldCamera.Latitude.Degrees, this.drawArgs.WorldCamera.Longitude.Degrees, horiz,
            this.drawArgs.WorldCamera.Altitude, vert);
      }

      public void SetViewPosition(double degreesLatitude, double degreesLongitude,
			double metersElevation)
      {
         this.drawArgs.WorldCamera.SlerpPercentage = World.Settings.CameraSlerpInertia;
         this.drawArgs.WorldCamera.SetPosition(degreesLatitude, degreesLongitude, this.drawArgs.WorldCamera.Heading.Degrees,
            metersElevation, this.drawArgs.WorldCamera.Tilt.Degrees);
      }

      public void SetWmsImage(WmsDescriptor imageA, WmsDescriptor imageB, double alpha)
      {
         // TODO:  Add WorldWindow.SetWmsImage implementation
         if (imageA != null)
         {
            // TODO: Remove writes to console once Wms images are implemented.
            System.Console.Write(imageA.Url.ToString() + " ");
            System.Console.WriteLine(imageA.Opacity);
         }
         if (imageB != null)
         {
            // TODO: Remove writes to console once Wms images are implemented.
            System.Console.Write(imageB.Url.ToString() + " ");
            System.Console.Write(imageB.Opacity);
            System.Console.Write(" alpha = ");
            System.Console.WriteLine(alpha);
         }
      }

      #endregion
   }
}
