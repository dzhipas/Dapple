#region OPEN SOURCE AGREEMENT
/*
	NASA OPEN SOURCE AGREEMENT VERSION 1.3

	THIS OPEN SOURCE AGREEMENT ("AGREEMENT") DEFINES THE RIGHTS OF USE,
	REPRODUCTION, DISTRIBUTION, MODIFICATION AND REDISTRIBUTION OF CERTAIN
	COMPUTER SOFTWARE ORIGINALLY RELEASED BY THE UNITED STATES GOVERNMENT
	AS REPRESENTED BY THE GOVERNMENT AGENCY LISTED BELOW ("GOVERNMENT
	AGENCY").  THE UNITED STATES GOVERNMENT, AS REPRESENTED BY GOVERNMENT
	AGENCY, IS AN INTENDED THIRD-PARTY BENEFICIARY OF ALL SUBSEQUENT
	DISTRIBUTIONS OR REDISTRIBUTIONS OF THE SUBJECT SOFTWARE.  ANYONE WHO
	USES, REPRODUCES, DISTRIBUTES, MODIFIES OR REDISTRIBUTES THE SUBJECT
	SOFTWARE, AS DEFINED HEREIN, OR ANY PART THEREOF, IS, BY THAT ACTION,
	ACCEPTING IN FULL THE RESPONSIBILITIES AND OBLIGATIONS CONTAINED IN
	THIS AGREEMENT.

	Government Agency: NASA_____________________________________
	Government Agency Original Software Designation: ______________
	Government Agency Original Software Title: ____________________
	User Registration Requested.  Please Visit http://__________________
	Government Agency Point of Contact for Original Software: ___________________
	________________________________________________


	1. DEFINITIONS

	A. "Contributor" means Government Agency, as the developer of the
	Original Software, and any entity that makes a Modification.
	B. "Covered Patents" mean patent claims licensable by a Contributor
	that are necessarily infringed by the use or sale of its Modification
	alone or when combined with the Subject Software.
	C. "Display" means the showing of a copy of the Subject Software,
	either directly or by means of an image, or any other device.
	D. "Distribution" means conveyance or transfer of the Subject
	Software, regardless of means, to another.
	E. "Larger Work" means computer software that combines Subject
	Software, or portions thereof, with software separate from the Subject
	Software that is not governed by the terms of this Agreement.
	F.  "Modification" means any alteration of, including addition to or
	deletion from, the substance or structure of either the Original
	Software or Subject Software, and includes derivative works, as that
	term is defined in the Copyright Statute, 17 USC 101.  However, the
	act of including Subject Software as part of a Larger Work does not in
	and of itself constitute a Modification.
	G. "Original Software" means the computer software first released
	under this Agreement by Government Agency with Government Agency
	designation ______________ and entitled
	_____________________________________________, including source code,
	object code and accompanying documentation, if any.
	H. "Recipient" means anyone who acquires the Subject Software under
	this Agreement, including all Contributors.
	I. "Redistribution" means Distribution of the Subject Software after a
	Modification has been made.
	J. "Reproduction" means the making of a counterpart, image or copy of
	the Subject Software.
	K. "Sale" means the exchange of the Subject Software for money or
	equivalent value.
	L. "Subject Software" means the Original Software, Modifications, or
	any respective parts thereof.
	M. "Use" means the application or employment of the Subject Software
	for any purpose.

	2. GRANT OF RIGHTS

	A. Under Non-Patent Rights: Subject to the terms and conditions of
	this Agreement, each Contributor, with respect to its own contribution
	to the Subject Software, hereby grants to each Recipient a
	non-exclusive, world-wide, royalty-free license to engage in the
	following activities pertaining to the Subject Software:

	1. Use
	2. Distribution
	3. Reproduction
	4. Modification
	5. Redistribution
	6. Display

	B. Under Patent Rights: Subject to the terms and conditions of this
	Agreement, each Contributor, with respect to its own contribution to
	the Subject Software, hereby grants to each Recipient under Covered
	Patents a non-exclusive, world-wide, royalty-free license to engage in
	the following activities pertaining to the Subject Software:

	1. Use
	2. Distribution
	3. Reproduction
	4. Sale
	5. Offer for Sale

	C. The rights granted under Paragraph B. also apply to the combination
	of a Contributor's Modification and the Subject Software if, at the
	time the Modification is added by the Contributor, the addition of
	such Modification causes the combination to be covered by the Covered
	Patents.  It does not apply to any other combinations that include a
	Modification.

	D. The rights granted in Paragraphs A. and B. allow the Recipient to
	sublicense those same rights.  Such sublicense must be under the same
	terms and conditions of this Agreement.

	3. OBLIGATIONS OF RECIPIENT

	A. Distribution or Redistribution of the Subject Software must be made
	under this Agreement except for additions covered under paragraph 3H.

	1. Whenever a Recipient distributes or redistributes the Subject
	Software, a copy of this Agreement must be included with each copy
	of the Subject Software; and
	2. If Recipient distributes or redistributes the Subject Software in
	any form other than source code, Recipient must also make the
	source code freely available, and must provide with each copy of
	the Subject Software information on how to obtain the source code
	in a reasonable manner on or through a medium customarily used for
	software exchange.

	B. Each Recipient must ensure that the following copyright notice
	appears prominently in the Subject Software:

	[Government Agency will insert the applicable copyright notice in each
	agreement accompanying the initial distribution of original software
	and remove this bracketed language.]

	[The following copyright notice will be used if created by a
	contractor pursuant to Government Agency contract and rights obtained
	from creator by assignment.  Government Agency will insert the year
	and its Agency designation and remove the bracketed language.]
	Copyright ã {YEAR} United States Government as represented by ______
	_________________________.  All Rights Reserved.

	[The following copyright notice will be used if created by civil
	servants only. Government Agency will insert the year and its Agency
	designation and remove the bracketed language.]  Copyright Ó {YEAR}
	United States Government as represented by _____________
	_____________________________.  No copyright is claimed in the United
	States under Title 17, U.S.Code. All Other Rights Reserved.

	C. Each Contributor must characterize its alteration of the Subject
	Software as a Modification and must identify itself as the originator
	of its Modification in a manner that reasonably allows subsequent
	Recipients to identify the originator of the Modification.  In
	fulfillment of these requirements, Contributor must include a file
	(e.g., a change log file) that describes the alterations made and the
	date of the alterations, identifies Contributor as originator of the
	alterations, and consents to characterization of the alterations as a
	Modification, for example, by including a statement that the
	Modification is derived, directly or indirectly, from Original
	Software provided by Government Agency. Once consent is granted, it
	may not thereafter be revoked.

	D. A Contributor may add its own copyright notice to the Subject
	Software.  Once a copyright notice has been added to the Subject
	Software, a Recipient may not remove it without the express permission
	of the Contributor who added the notice.

	E. A Recipient may not make any representation in the Subject Software
	or in any promotional, advertising or other material that may be
	construed as an endorsement by Government Agency or by any prior
	Recipient of any product or service provided by Recipient, or that may
	seek to obtain commercial advantage by the fact of Government Agency's
	or a prior Recipient's participation in this Agreement.

	F. In an effort to track usage and maintain accurate records of the
	Subject Software, each Recipient, upon receipt of the Subject
	Software, is requested to register with Government Agency by visiting
	the following website: ______________________________.  Recipient's
	name and personal information shall be used for statistical purposes
	only. Once a Recipient makes a Modification available, it is requested
	that the Recipient inform Government Agency at the web site provided
	above how to access the Modification.

	[Alternative paragraph for use when a web site for release and
	monitoring of subject software will not be supported by releasing
	Government Agency] In an effort to track usage and maintain accurate
	records of the Subject Software, each Recipient, upon receipt of the
	Subject Software, is requested to provide Government Agency, by e-mail
	to the Government Agency Point of Contact listed in clause 5.F., the
	following information: ______________________________.  Recipient's
	name and personal information shall be used for statistical purposes
	only. Once a Recipient makes a Modification available, it is requested
	that the Recipient inform Government Agency, by e-mail to the
	Government Agency Point of Contact listed in clause 5.F., how to
	access the Modification.

	G. Each Contributor represents that that its Modification is believed
	to be Contributor's original creation and does not violate any
	existing agreements, regulations, statutes or rules, and further that
	Contributor has sufficient rights to grant the rights conveyed by this
	Agreement.

	H. A Recipient may choose to offer, and to charge a fee for, warranty,
	support, indemnity and/or liability obligations to one or more other
	Recipients of the Subject Software.  A Recipient may do so, however,
	only on its own behalf and not on behalf of Government Agency or any
	other Recipient.  Such a Recipient must make it absolutely clear that
	any such warranty, support, indemnity and/or liability obligation is
	offered by that Recipient alone.  Further, such Recipient agrees to
	indemnify Government Agency and every other Recipient for any
	liability incurred by them as a result of warranty, support, indemnity
	and/or liability offered by such Recipient.

	I. A Recipient may create a Larger Work by combining Subject Software
	with separate software not governed by the terms of this agreement and
	distribute the Larger Work as a single product. In such case, the
	Recipient must make sure Subject Software, or portions thereof,
	included in the Larger Work is subject to this Agreement.

	J. Notwithstanding any provisions contained herein, Recipient is
	hereby put on notice that export of any goods or technical data from
	the United States may require some form of export license from the
	U.S. Government.  Failure to obtain necessary export licenses may
	result in criminal liability under U.S. laws.  Government Agency
	neither represents that a license shall not be required nor that, if
	required, it shall be issued.  Nothing granted herein provides any
	such export license.

	4. DISCLAIMER OF WARRANTIES AND LIABILITIES; WAIVER AND INDEMNIFICATION

	A. No Warranty: THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY
	WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
	INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE
	WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
	INFRINGEMENT, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL BE ERROR
	FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM TO
	THE SUBJECT SOFTWARE. THIS AGREEMENT DOES NOT, IN ANY MANNER,
	CONSTITUTE AN ENDORSEMENT BY GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT
	OF ANY RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY
	OTHER APPLICATIONS RESULTING FROM USE OF THE SUBJECT SOFTWARE.
	FURTHER, GOVERNMENT AGENCY DISCLAIMS ALL WARRANTIES AND LIABILITIES
	REGARDING THIRD-PARTY SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE,
	AND DISTRIBUTES IT "AS IS."

	B. Waiver and Indemnity: RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS
	AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
	SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT.  IF RECIPIENT'S USE OF
	THE SUBJECT SOFTWARE RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES,
	EXPENSES OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM
	PRODUCTS BASED ON, OR RESULTING FROM, RECIPIENT'S USE OF THE SUBJECT
	SOFTWARE, RECIPIENT SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED
	STATES GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY
	PRIOR RECIPIENT, TO THE EXTENT PERMITTED BY LAW.  RECIPIENT'S SOLE
	REMEDY FOR ANY SUCH MATTER SHALL BE THE IMMEDIATE, UNILATERAL
	TERMINATION OF THIS AGREEMENT.


	5. GENERAL TERMS

	A. Termination: This Agreement and the rights granted hereunder will
	terminate automatically if a Recipient fails to comply with these
	terms and conditions, and fails to cure such noncompliance within
	thirty (30) days of becoming aware of such noncompliance.  Upon
	termination, a Recipient agrees to immediately cease use and
	distribution of the Subject Software.  All sublicenses to the Subject
	Software properly granted by the breaching Recipient shall survive any
	such termination of this Agreement.

	B. Severability: If any provision of this Agreement is invalid or
	unenforceable under applicable law, it shall not affect the validity
	or enforceability of the remainder of the terms of this Agreement.

	C. Applicable Law: This Agreement shall be subject to United States
	federal law only for all purposes, including, but not limited to,
	determining the validity of this Agreement, the meaning of its
	provisions and the rights, obligations and remedies of the parties.

	D. Entire Understanding: This Agreement constitutes the entire
	understanding and agreement of the parties relating to release of the
	Subject Software and may not be superseded, modified or amended except
	by further written agreement duly executed by the parties.

	E. Binding Authority: By accepting and using the Subject Software
	under this Agreement, a Recipient affirms its authority to bind the
	Recipient to all terms and conditions of this Agreement and that that
	Recipient hereby agrees to all terms and conditions herein.

	F. Point of Contact: Any Recipient contact with Government Agency is
	to be directed to the designated representative as follows:
	___________________________________________________________.
 *
 *
 *
 */
#endregion

using Microsoft.DirectX.Direct3D;
using Microsoft.DirectX;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Net;
using System.Security.Permissions;
using System.Threading;
using System.Windows.Forms;
using System;
using WorldWind.Camera;
using WorldWind.Menu;
using WorldWind;
using WorldWind.Net;
using WorldWind.Net.Wms;
using WorldWind.Interop;
using WorldWind.VisualControl;
using Utility;

namespace WorldWind
{
	public class WorldWindow : Control
	{
		/// <summary>
		/// Direct3D rendering m_Device3d
		/// </summary>
		private Device m_Device3d;
		private PresentParameters m_presentParams;
		private DrawArgs drawArgs;
		private World m_World;
		private Cache m_Cache;
		private Thread m_WorkerThread;
		private bool showDiagnosticInfo;
		private string _caption = "";
		private long lastFpsUpdateTime;
		private int frameCounter;
		private float fps;
		private bool m_WorkerThreadRunning;
		private bool m_isRenderDisabled = true; // True when WW isn't active - CPU saver
		private bool isMouseDragging;
		private Point mouseDownStartPosition = Point.Empty;
		private bool renderWireFrame;
		private System.Timers.Timer m_FpsTimer = new System.Timers.Timer(250);
#if DEBUG
		private bool supressUpdates;
#endif
		public static event EventHandler VideoMemoryExhausted;

		/// <summary>
		/// Initializes a new instance of the <see cref= "T:WorldWind.WorldWindow"/> class.
		/// </summary>
		public WorldWindow()
		{
			this.SetStyle(ControlStyles.AllPaintingInWmPaint | ControlStyles.Opaque, true);

			// The m_Device3d can't be created unless the control is at least 1 x 1 pixels in size
			this.Size = new Size(1, 1);

			// Now perform the rendering m_Device3d initialization
			// Skip DirectX initialization in design mode
			if (!IsInDesignMode())
			{
				this.InitializeGraphics();
				Application.Idle += new EventHandler(this.OnApplicationIdle);
			}

			//Post m_Device3d creation initialization
			this.drawArgs = new DrawArgs(m_Device3d, this);
			this.m_RootWidget = new WorldWind.Widgets.RootWidget(this);
			this.m_NewRootWidget = new WorldWind.NewWidgets.RootWidget(this);

			DrawArgs.RootWidget = this.m_RootWidget;
			DrawArgs.NewRootWidget = this.m_NewRootWidget;

			m_FpsTimer.Elapsed += new System.Timers.ElapsedEventHandler(m_FpsTimer_Elapsed);
			m_FpsTimer.Start();

			TimeKeeper.Start();
		}

		#region Public properties

		public World CurrentWorld
		{
			get
			{
				return m_World;
			}
			set
			{
				m_World = value;
				if (m_World != null)
				{
					MomentumCamera camera = new MomentumCamera(m_World.EquatorialRadius);
					if (!World.Settings.CameraResetsAtStartup)
					{
						camera.SetPosition(
							 World.Settings.CameraLatitude.Degrees,
							 World.Settings.CameraLongitude.Degrees,
							 World.Settings.CameraHeading.Degrees,
							 World.Settings.CameraAltitude,
							 World.Settings.CameraTilt.Degrees,
							 0
							 );
					}
					this.drawArgs.WorldCamera = camera;

					this.drawArgs.CurrentWorld = value;
					// TODO: Decide how to load grids
					m_World.RenderableObjects.Add(new Renderable.LatLongGrid(m_World));
				}
			}
		}

		public double Latitude
		{
			get
			{
				return this.drawArgs.WorldCamera.Latitude.Degrees;
			}
		}
		public double Longitude
		{
			get
			{
				return this.drawArgs.WorldCamera.Longitude.Degrees;
			}
		}

		public DrawArgs DrawArgs
		{
			get { return this.drawArgs; }
		}

		public Cache Cache
		{
			get
			{
				return m_Cache;
			}
			set
			{
				m_Cache = value;
			}
		}

		/// <summary>
		/// Disables rendering (CPU tick saver)
		/// </summary>
		public bool IsRenderDisabled
		{
			get
			{
				return m_isRenderDisabled;
			}
			set
			{
				m_isRenderDisabled = value;
			}
		}
		#endregion

		#region Public methods

		/// <summary>
		/// If the camera's height is above this value, the entire half of the world is visible.  Below this value, the top and bottom of the globe
		/// is clipped by the window.
		/// </summary>
		internal double HeightThreshold
		{
			get
			{
				return m_World.EquatorialRadius * (1 - Math.Sin(drawArgs.WorldCamera.Fov.Radians / 2)) / Math.Sin(drawArgs.WorldCamera.Fov.Radians / 2);
			}
		}

		/// <summary>
		/// Gets how much arc of the earth's surface is visible at the given height.
		/// </summary>
		/// <param name="dDistance">Height above the earth's surface.</param>
		/// <returns>Latitude viewing angle, in degrees.</returns>
		internal double LatitudeVisibleAngleFromCameraHeight(double dDistance)
		{
			if (dDistance >= HeightThreshold) return 180 - drawArgs.WorldCamera.Fov.Degrees;
			if (dDistance <= 0) return 0.0;

			double dRadius = m_World.EquatorialRadius;
			double dFov = this.drawArgs.WorldCamera.Fov.Radians;

			// Step 1: Figure out the third side of the triangle

			double A = 1.0;
			double B = -2 * (dDistance + dRadius) * Math.Cos(dFov / 2);
			double C = Math.Pow(dDistance + dRadius, 2) - Math.Pow(dRadius, 2);

			double dDiscriminant = Math.Sqrt(Math.Pow(B, 2) - (4 * A * C));

			double x1 = (-B + dDiscriminant) / (2.0 * A);
			double x2 = (-B - dDiscriminant) / (2.0 * A);
			double X = Math.Min(x1, x2);

			// Step 2: Figure out the actual view angle

			return 180 - Math.Acos((Math.Pow(X, 2) - Math.Pow(dDistance + dRadius, 2) - Math.Pow(dRadius, 2)) / (2 * (dDistance + dRadius) * dRadius)) * Rad2Deg;
		}

		internal double CameraHeightFromVisibleAngles(double dLatArc, double dLonArc, double dLat)
		{
			return Math.Max(CameraHeightFromLatitudeVisibleAngle(dLatArc), CameraHeightFromLatitudeVisibleAngle(dLonArc * Math.Cos(dLat) * (double)this.Height / (double)this.Width));
		}

		/// <summary>
		/// Gets the altitude needed to produce the requested visible arc.  For arcs greater than the camera can display, just gives the height threshold.
		/// </summary>
		/// <remarks>
		/// dLatArc must be between 0 and 180.
		/// </remarks>
		/// <param name="dLatArc"></param>
		/// <returns></returns>
		internal double CameraHeightFromLatitudeVisibleAngle(double dLatArc)
		{
			if (dLatArc > 180.0 - drawArgs.WorldCamera.Fov.Degrees) return HeightThreshold + 10000;
			if (dLatArc <= 0.0) return 0.0;

			double dFovAngle = drawArgs.WorldCamera.Fov.Radians / 2;
			return this.m_World.EquatorialRadius * Math.Sin(Math.PI - dFovAngle - dLatArc / 2 * Deg2Rad) / Math.Sin(dFovAngle) - m_World.EquatorialRadius;
		}

		/// <summary>
		/// Get a search box.  It is calculated based solely on the radius of the world, the lat/lon of the current viewing location, the altitude,
		/// the FOV, and the aspect ratio of the window.  In pretty much all cases, it more accurately reflects what you're actually looking at.
		/// </summary>
		/// <returns></returns>
		public GeographicQuad CurrentAreaOfInterest
		{
			get
			{
				double dDistance = this.drawArgs.WorldCamera.Distance;
				double dCameraLatitude = drawArgs.WorldCamera.Latitude.Degrees;
				if (dCameraLatitude > 89.9) dCameraLatitude = 89.0;
				if (dCameraLatitude < -89.9) dCameraLatitude = -89.9;
				double dCameraLongitude = drawArgs.WorldCamera.Longitude.Degrees;
				double dMaxVisibleAngle = 90.0 - drawArgs.WorldCamera.Fov.Degrees / 2;

				// Step 0: If you're zoomed out, use a whole-world box

				if (dDistance > HeightThreshold)
				{
					return new GeographicQuad(-180.0, -90.0, 180.0, -90.0, 180.0, 90.0, -180.0, 90.0);
				}

				// Step 1: Figure out the third side of the triangle

				double dLatitudeVisibleAngle = LatitudeVisibleAngleFromCameraHeight(dDistance);

				// Step 2: Scale the longitude viewing angle by the screen aspect ratio

				double dAspectRatio = (double)this.Width / (double)this.Height;
				double dLongitudeVisibleAngle = dLatitudeVisibleAngle * dAspectRatio;
				if (dLongitudeVisibleAngle > dMaxVisibleAngle) dLongitudeVisibleAngle = dMaxVisibleAngle;

				// Step 3: Scale the longitude viewing angle by the latitude (higher up == wider)

				double dLatitudeScaleFactor = 1 / Math.Cos(dCameraLatitude * Deg2Rad);
				dLongitudeVisibleAngle *= dLatitudeScaleFactor;

				// Step 4: Return the box based on that viewed area

				return new GeographicQuad(
					dCameraLongitude - dLongitudeVisibleAngle, dCameraLatitude - dLatitudeVisibleAngle,
					dCameraLongitude - dLongitudeVisibleAngle, dCameraLatitude + dLatitudeVisibleAngle,
					dCameraLongitude + dLongitudeVisibleAngle, dCameraLatitude + dLatitudeVisibleAngle,
					dCameraLongitude + dLongitudeVisibleAngle, dCameraLatitude - dLatitudeVisibleAngle
				);
			}
		}


		const double Deg2Rad = Math.PI / 180.0;
		const double Rad2Deg = 180 / Math.PI;

		/// <summary>
		/// Moves to specified location.
		/// </summary>
		/// <param name="latitude">Latitude in degrees of target position. (-90 - 90).</param>
		/// <param name="longitude">Longitude in degrees of target position. (-180 - 180).</param>
		/// <param name="heading">Camera heading in degrees (0-360) or double.NaN for no change.</param>
		/// <param name="altitude">Camera altitude in meters or double.NaN for no change.</param>
		/// <param name="perpendicularViewRange"></param>
		/// <param name="tilt">Camera tilt in degrees (-90 - 90) or double.NaN for no change.</param>
		public void GoToLatLon(double latitude, double longitude, double heading, double altitude, double perpendicularViewRange, double tilt)
		{
			if (!double.IsNaN(perpendicularViewRange))
				altitude = m_World.EquatorialRadius * Math.Sin(MathEngine.DegreesToRadians(perpendicularViewRange * 0.5));
			if (altitude < 1)
				altitude = 1;
			this.drawArgs.WorldCamera.SlerpPercentage = World.Settings.CameraSlerpInertia;
			this.drawArgs.WorldCamera.SetPosition(latitude, longitude, heading, altitude, tilt);
		}

		public void GoToLatLon(double latitude, double longitude)
		{
			this.drawArgs.WorldCamera.SlerpPercentage = World.Settings.CameraSlerpInertia;
			this.drawArgs.WorldCamera.SetPosition(latitude, longitude,
				this.drawArgs.WorldCamera.Heading.Degrees,
				this.drawArgs.WorldCamera.Altitude,
				this.drawArgs.WorldCamera.Tilt.Degrees);
		}

		public void GoToLatLonHeadingViewRange(double latitude, double longitude, double heading, double perpendicularViewRange)
		{
			double altitude = m_World.EquatorialRadius * Math.Sin(MathEngine.DegreesToRadians(perpendicularViewRange * 0.5));
			this.GotoLatLonHeadingAltitude(latitude, longitude, heading, altitude);
		}

		internal void GotoLatLonHeadingAltitude(double latitude, double longitude, double heading, double altitude)
		{
			this.drawArgs.WorldCamera.SlerpPercentage = World.Settings.CameraSlerpInertia;
			this.drawArgs.WorldCamera.SetPosition(latitude, longitude,
				heading,
				altitude,
				this.drawArgs.WorldCamera.Tilt.Degrees);
		}

		/// <summary>
		/// New routine for "go to" operations.
		/// </summary>
		/// <param name="dMinLon"></param>
		/// <param name="dMinLat"></param>
		/// <param name="dMaxLon"></param>
		/// <param name="dMaxLat"></param>
		public void GoToBoundingBox(GeographicBoundingBox boundingBox, bool blImmediate)
		{
			double dMinLon = boundingBox.West;
			double dMinLat = boundingBox.South;
			double dMaxLon = boundingBox.East;
			double dMaxLat = boundingBox.North;

			double dLatitudeAngle = dMaxLat - dMinLat;
			double dLongitudeAngle = dMaxLon - dMinLon;
			double dLatitude = (dMinLat + dMaxLat) / 2.0;
			double dLongitude = (dMinLon + dMaxLon) / 2.0;

			this.drawArgs.WorldCamera.SlerpPercentage = World.Settings.CameraSlerpInertia;

			if (blImmediate)
			{
				this.drawArgs.WorldCamera.SetPositionImmediate(
					dLatitude,
					dLongitude,
					0.0,
					CameraHeightFromVisibleAngles(dLatitudeAngle, dLongitudeAngle, dLatitude),
					0.0,
					0.0);
			}
			else
			{
				this.drawArgs.WorldCamera.SetPosition(
					dLatitude,
					dLongitude,
					0.0,
					CameraHeightFromVisibleAngles(dLatitudeAngle, dLongitudeAngle, dLatitude),
					0.0,
					0.0);
			}
		}

		/// <summary>
		/// The world render loop.  
		/// Borrowed from FlightGear and Tom Miller's blog
		/// </summary>
		internal void OnApplicationIdle(object sender, EventArgs e)
		{
			// Sleep will always overshoot by a bit so under-sleep by
			// 2ms in the hopes of never oversleeping.
			const float SleepOverHeadSeconds = 2e-3f;

			if (Parent.Focused && !Focused)
				Focus();

			while (IsAppStillIdle)
			{
				if (!World.Settings.AlwaysRenderWindow && m_isRenderDisabled && !World.Settings.CameraHasMomentum)
					return;

				float fRenderTime = Render();

				float fSleepNeeded = (1.0f / 25.0f) - SleepOverHeadSeconds - fRenderTime;
				if (fSleepNeeded > 0)
				{
					Thread.Sleep((int)(fSleepNeeded * 1000));
				}
			}
		}
		#endregion

		/// <summary>
		/// Determine whether any window messages is queued.
		/// </summary>
		private static bool IsAppStillIdle
		{
			get
			{
				NativeMethods.Message msg;
				return !NativeMethods.PeekMessage(out msg, IntPtr.Zero, 0, 0, 0);
			}
		}

		/// <summary>
		/// Occurs when the control is redrawn and m_isRenderDisabled=true.
		/// All other painting is handled in WndProc.
		/// </summary>
		/// <param name="e"></param>
		protected override void OnPaint(PaintEventArgs e)
		{
			if (m_Device3d == null)
			{
				e.Graphics.Clear(SystemColors.Control);
			}
			else
			{
				Render();
			}
		}

		System.Collections.ArrayList m_FrameTimes = new ArrayList();
		WorldWind.Widgets.RootWidget m_RootWidget = null;
		WorldWind.NewWidgets.RootWidget m_NewRootWidget = null;
		private bool m_blDeviceLost;

		/// <summary>
		/// This method is a redirect; delete it sometime and call the redirected method directly.
		/// </summary>
		public void SafeRender()
		{
			Render();
		}

		/// <summary>
		/// Render the scene.
		/// </summary>
		/// <returns>The number of seconds taken to render everything.</returns>
		public float Render()
		{
			float result;

			// --- Ensure the Device isn't lost, and cancel if it is ---
			if (m_blDeviceLost)
			{
				AttemptRecovery();
			}
			if (m_blDeviceLost)
			{
				return 0;
			}

			using (new DirectXProfilerEvent("WorldWindow::Render"))
			{
				long startTicks = 0;
				PerformanceTimer.QueryPerformanceCounter(ref startTicks);

				try
				{
					this.drawArgs.BeginRender();

					// Render the sky according to view - example, close to earth, render sky blue, render space as black
					System.Drawing.Color backgroundColor = System.Drawing.Color.Black;

					m_Device3d.Clear(ClearFlags.Target | ClearFlags.ZBuffer, backgroundColor, 1.0f, 0);

					if (m_World != null)
					{
						if (m_WorkerThread == null)
						{
							m_WorkerThreadRunning = true;
							m_WorkerThread = new Thread(new ThreadStart(WorkerThreadFunc));
							m_WorkerThread.Name = ThreadNames.WorldWindowBackground;
							m_WorkerThread.IsBackground = true;
							if (World.Settings.UseBelowNormalPriorityUpdateThread)
							{
								m_WorkerThread.Priority = ThreadPriority.BelowNormal;
							}
							else
							{
								m_WorkerThread.Priority = ThreadPriority.Normal;
							}
							// BelowNormal makes rendering smooth, but on slower machines updates become slow or stops
							// TODO: Implement dynamic FPS limiter (or different solution)
							m_WorkerThread.Start();
						}

						// Update camera view
						this.drawArgs.WorldCamera.UpdateTerrainElevation(m_World.TerrainAccessor);
						this.drawArgs.WorldCamera.Update(m_Device3d);

						try
						{
							m_Device3d.BeginScene();

							// Set fill mode
							if (renderWireFrame)
								m_Device3d.RenderState.FillMode = FillMode.WireFrame;
							else
								m_Device3d.RenderState.FillMode = FillMode.Solid;

							drawArgs.RenderWireFrame = renderWireFrame;

							// Render the current planet
							m_World.Render(this.drawArgs);

							if (World.Settings.ShowCrosshairs)
								this.DrawCrosshairs();

							frameCounter++;
							if (frameCounter == 30)
							{
								fps = frameCounter / (float)(DrawArgs.CurrentFrameStartTicks - lastFpsUpdateTime) * PerformanceTimer.TicksPerSecond;
								frameCounter = 0;
								lastFpsUpdateTime = DrawArgs.CurrentFrameStartTicks;
							}

							m_RootWidget.Render(drawArgs);
							m_NewRootWidget.Render(drawArgs);

							drawArgs.device.RenderState.ZBufferEnable = false;

							// 3D rendering complete, switch to 2D for UI rendering

							// Restore normal fill mode
							if (renderWireFrame)
								m_Device3d.RenderState.FillMode = FillMode.Solid;

							// Disable fog for UI
							m_Device3d.RenderState.FogEnable = false;

							RenderPositionInfo();

							m_FpsGraph.Render(drawArgs);
						}
						finally
						{
							m_Device3d.EndScene();
						}

						try
						{
							drawArgs.Present();
						}
						catch (DeviceLostException)
						{
							m_blDeviceLost = true;
						}
						catch (InvalidCallException)
						{
							// --- We've never managed to isolate what causes this in all cases
							// --- (a common one was Present called after BeginScene but before EndScene,
							// --- but it still occurred when all code paths were believed to be checked).
							// --- Consider the device lost, and see if we can't simply recover using
							// --- a normal test/reset operation.
							m_blDeviceLost = true;
						}
					}
				}
				finally
				{
					long endTicks = 0;
					PerformanceTimer.QueryPerformanceCounter(ref endTicks);
					result = (float)(endTicks - startTicks) / PerformanceTimer.TicksPerSecond;

					if (World.Settings.ShowFpsGraph)
					{
						m_FrameTimes.Add(result);
					}
					this.drawArgs.EndRender();
				}
				drawArgs.UpdateMouseCursor(this);
			}

			return result;
		}

		private LineGraph m_FpsGraph = new LineGraph();

		private const int positionAlphaStep = 20;
		private int positionAlpha = 255;
		private int positionAlphaMax = 205;

		protected void RenderPositionInfo()
		{
			// Render some Development information to screen
			string captionText = _caption;

			captionText += "\n" + this.drawArgs.UpperLeftCornerText;

			if (World.Settings.ShowPosition)
			{
				double feetPerMeter = 3.2808399;
				double feetPerMile = 5280;

				// TODO: Configurable transparent number->string conversion (metric/imperial etc units)
				string alt = null;
				float agl = (float)this.drawArgs.WorldCamera.Altitude;
				string dist = null;
				float dgl = (float)this.drawArgs.WorldCamera.Distance;

				if (World.Settings.DisplayUnits == Units.Metric)
				{
					if (agl >= 1000)
						alt = string.Format(CultureInfo.CurrentCulture, "{0:,.0} km", agl / 1000);
					else
						alt = string.Format(CultureInfo.CurrentCulture, "{0:f0} m", agl);

					if (dgl > 100000)
						dist = string.Format(CultureInfo.CurrentCulture, "{0:f2} km", dgl / 1000);
					else
						dist = string.Format(CultureInfo.CurrentCulture, "{0:f0} m", dgl);
				}
				else
				{
					agl *= (float)feetPerMeter;
					dgl *= (float)feetPerMeter;

					if (agl >= feetPerMile)
						alt = string.Format(CultureInfo.CurrentCulture, "{0:,.0} miles", agl / feetPerMile);
					else
						alt = string.Format(CultureInfo.CurrentCulture, "{0:f0} ft", agl);

					if (dgl > 100000)
						dist = string.Format(CultureInfo.CurrentCulture, "{0:f2} miles", dgl / feetPerMile);
					else
						dist = string.Format(CultureInfo.CurrentCulture, "{0:f0} ft", dgl);
				}

				// Heading from 0 - 360
				double heading = this.drawArgs.WorldCamera.Heading.Degrees;
				if (heading < 0)
					heading += 360;
				captionText += String.Format(CultureInfo.CurrentCulture, "Latitude: {0:f6}°\nLongitude: {1:f6}°\nHeading: {2:f2}°\nTilt: {3:f2}°\nAltitude: {4}\nDistance: {5}\nFOV: {6}",
					 this.drawArgs.WorldCamera.Latitude.Degrees,
					 this.drawArgs.WorldCamera.Longitude.Degrees,
					 heading,
					 this.drawArgs.WorldCamera.Tilt.Degrees,
					 alt,
					 dist,
					 this.drawArgs.WorldCamera.Fov);

				if (drawArgs.WorldCamera.AltitudeAboveTerrain < 300000)
				{
					double terrainElevation = drawArgs.WorldCamera.TerrainElevation;
					if (World.Settings.DisplayUnits == Units.Metric)
					{
						captionText += String.Format(CultureInfo.CurrentCulture, "\nTerrain Elevation: {0:n} meters\n", terrainElevation);
					}
					else
					{
						captionText += String.Format(CultureInfo.CurrentCulture, "\nTerrain Elevation: {0:n} feet\n", terrainElevation * feetPerMeter);
					}
				}
			}

			if (this.showDiagnosticInfo)
			{

				captionText +=
					"\nAvailable Texture Memory: " + (m_Device3d.AvailableTextureMemory / 1024).ToString("N0", CultureInfo.CurrentCulture) + " Kb" +
					"\nBoundary Points: " + this.drawArgs.numBoundaryPointsRendered.ToString(CultureInfo.CurrentCulture) + " / " + this.drawArgs.numBoundaryPointsTotal.ToString(CultureInfo.CurrentCulture) + " : " + this.drawArgs.numBoundariesDrawn.ToString(CultureInfo.CurrentCulture) +
					"\nTiles Drawn: " + (this.drawArgs.numberTilesDrawn * 0.25f).ToString(CultureInfo.CurrentCulture) +
					"\n" + this.drawArgs.WorldCamera +
					"\nFPS: " + this.fps.ToString("f1", CultureInfo.CurrentCulture) +
					"\nRO: " + m_World.RenderableObjects.Count.ToString("f0", CultureInfo.CurrentCulture) +
					"\nmLat: " + this.cLat.Degrees.ToString(CultureInfo.CurrentCulture) +
						  "\nmLon: " + this.cLon.Degrees.ToString(CultureInfo.CurrentCulture) +
						  "\n" + TimeKeeper.CurrentTimeUtc.ToLocalTime().ToLongTimeString();
			}


			captionText = captionText.Trim();
			DrawTextFormat dtf = DrawTextFormat.NoClip | DrawTextFormat.WordBreak | DrawTextFormat.Right;
			int x = 7;
			int y = 7;//_menuBar!=null && World.Settings.ShowToolbar ? 65 : 7;
			Rectangle textRect = Rectangle.FromLTRB(x, y, this.Width - 8, this.Height - 8);

			positionAlpha += positionAlphaStep;
			if (positionAlpha > positionAlphaMax)
				positionAlpha = positionAlphaMax;
			//}

			int positionBackColor = positionAlpha << 24;
			int positionForeColor = (int)((uint)(positionAlpha << 24) + 0xffffffu);
			this.drawArgs.defaultDrawingFont.DrawText(null, captionText, textRect, dtf, positionBackColor);
			textRect.Offset(-1, -1);
			this.drawArgs.defaultDrawingFont.DrawText(null, captionText, textRect, dtf, positionForeColor);
		}


		/// <summary>
		/// Draws a small cross hairs for the user to pinpoint the exact lat/lon
		/// TODO: Make this user-resizeable and color customizable
		/// </summary>
		Line crossHairs;
		protected void DrawCrosshairs()
		{
			int crossHairColor = World.Settings.CrosshairColor.ToArgb();
			int crossHairSize = World.Settings.CrosshairSize;

			if (crossHairs == null)
			{
				crossHairs = new Line(m_Device3d);
			}

			Vector2[] vertical = new Vector2[2];
			Vector2[] horizontal = new Vector2[2];

			horizontal[0].X = this.Width / 2 - crossHairSize;
			horizontal[0].Y = this.Height / 2;
			horizontal[1].X = this.Width / 2 + crossHairSize + 1;
			horizontal[1].Y = this.Height / 2;

			vertical[0].X = this.Width / 2;
			vertical[0].Y = this.Height / 2 - crossHairSize;
			vertical[1].X = this.Width / 2;
			vertical[1].Y = this.Height / 2 + crossHairSize + 1;

			crossHairs.Begin();
			crossHairs.Draw(horizontal, crossHairColor);
			crossHairs.Draw(vertical, crossHairColor);
			crossHairs.End();
		}

		/// <summary>
		/// Attempt to restore the 3D m_Device3d
		/// </summary>
		protected void AttemptRecovery()
		{
			try
			{
				m_Device3d.TestCooperativeLevel();
			}
			catch (DeviceLostException)
			{
				// --- Device is still lost ---
			}
			catch (DeviceNotResetException)
			{
				try
				{
					m_Device3d.Reset(m_presentParams);
					m_blDeviceLost = false;
				}
				catch (DeviceLostException)
				{
					// --- Device was found, but got lost again quickly ---
				}
			}
		}

		#region Event handlers

		/// <summary>
		/// Occurs when the mouse wheel moves while the control has focus.
		/// </summary>
		protected override void OnMouseWheel(MouseEventArgs e)
		{
			if (!IsWorldReady())
			{
				return;
			}
			try
			{
				this.drawArgs.WorldCamera.SlerpPercentage = World.Settings.CameraSlerpInertia * 2;
				this.drawArgs.WorldCamera.ZoomStepped(-e.Delta / 120.0f);
			}
			finally
			{
				if (m_NewRootWidget != null)
				{
					m_NewRootWidget.OnMouseWheel(e);
				}

				// Call the base class's OnMouseWheel method so that registered delegates receive the event.
				base.OnMouseWheel(e);
			}
		}

		/// <summary>
		/// Occurs when a key is pressed while the control has focus.
		/// </summary>
		protected override void OnKeyDown(KeyEventArgs e)
		{
			if (IsWorldReady())
			{
				e.Handled = HandleKeyDown(e);
			}
			base.OnKeyDown(e);
		}

		/// <summary>
		/// Occurs when a key is released while the control has focus.
		/// </summary>
		protected override void OnKeyUp(KeyEventArgs e)
		{
			if (IsWorldReady())
			{
				e.Handled = HandleKeyUp(e);
			}
			base.OnKeyUp(e);
		}

		protected override void OnKeyPress(KeyPressEventArgs e)
		{
			if (!IsWorldReady())
			{
				return;
			}
			if (m_RootWidget != null)
			{
				bool handled = m_RootWidget.OnKeyPress(e);
				e.Handled = handled;
			}
			if (m_NewRootWidget != null)
			{
				bool handled = m_NewRootWidget.OnKeyPress(e);
				e.Handled = handled;
			}
			base.OnKeyPress(e);
		}


		/// <summary>
		/// Preprocess keyboard or input messages within the message loop before they are dispatched.
		/// </summary>
		/// <param name="msg">A Message, passed by reference, that represents the message to process. 
		/// The possible values are WM_KEYDOWN, WM_SYSKEYDOWN, WM_CHAR, and WM_SYSCHAR.</param>
		[SecurityPermission(SecurityAction.LinkDemand, UnmanagedCode = true), SecurityPermission(SecurityAction.InheritanceDemand, UnmanagedCode = true)]
		public override bool PreProcessMessage(ref Message msg)
		{
			const int WM_KEYDOWN = 0x0100;

			// it's the only way to handle arrow keys in OnKeyDown
			if (msg.Msg == WM_KEYDOWN)
			{
				Keys key = (Keys)msg.WParam.ToInt32();
				switch (key)
				{
					case Keys.Left:
					case Keys.Up:
					case Keys.Right:
					case Keys.Down:
						OnKeyDown(new KeyEventArgs(key));
						// mark message as processed
						msg.Result = (IntPtr)1;
						// When overriding PreProcessMessage, a control should return true to indicate that it has processed the message.
						return true;
				}
			}

			return base.PreProcessMessage(ref msg);
		}


		/// <summary>
		/// Handles key down events.
		/// </summary>
		/// <param name="e"></param>
		/// <returns>Returns true if the key is handled.</returns>
		internal bool HandleKeyDown(KeyEventArgs e)
		{

			bool handled = this.m_RootWidget.OnKeyDown(e);
			if (handled)
				return handled;

			handled = this.m_NewRootWidget.OnKeyDown(e);
			if (handled)
				return handled;

			// Alt key down
			if (e.Alt)
				return HandleAltKeyDown(e);
			else if (e.Control)
				return false;
			else
				return HandleNormalKeyDown(e);
		}

		private bool HandleAltKeyDown(KeyEventArgs e)
		{
			switch (e.KeyCode)
			{
				case Keys.C:
					World.Settings.ShowCrosshairs = !World.Settings.ShowCrosshairs;
					break;
				case Keys.Add:
				case Keys.Oemplus:
				case Keys.Home:
				case Keys.NumPad7:
					this.drawArgs.WorldCamera.Fov -= Angle.FromDegrees(5);
					break;
				case Keys.Subtract:
				case Keys.OemMinus:
				case Keys.End:
				case Keys.NumPad1:
					this.drawArgs.WorldCamera.Fov += Angle.FromDegrees(5);
					break;
			}
			return true;
		}

		private bool HandleNormalKeyDown(KeyEventArgs e)
		{
			switch (e.KeyCode)
			{
				// reset north
				case Keys.N:
					this.drawArgs.WorldCamera.SlerpPercentage = World.Settings.CameraSlerpInertia;
					this.DrawArgs.WorldCamera.SetPosition(
					this.Latitude,
					this.Longitude,
					 0,
					 this.DrawArgs.WorldCamera.Altitude,
					 this.DrawArgs.WorldCamera.Tilt.Degrees);
					break;
				// reset Tilt
				case Keys.T:
					this.drawArgs.WorldCamera.SlerpPercentage = World.Settings.CameraSlerpInertia;
					this.DrawArgs.WorldCamera.SetPosition(
					this.Latitude,
					this.Longitude,
					 this.DrawArgs.WorldCamera.Heading.Degrees,
					 this.DrawArgs.WorldCamera.Altitude,
					 0);
					break;
				// rotate left
				case Keys.A:
					this.drawArgs.WorldCamera.SlerpPercentage = 1.0;
					Angle rotateClockwise = Angle.FromRadians(0.01f);
					this.drawArgs.WorldCamera.Heading += rotateClockwise;
					this.drawArgs.WorldCamera.RotationYawPitchRoll(Angle.Zero, Angle.Zero, rotateClockwise);
					break;
				// rotate right
				case Keys.D:
					this.drawArgs.WorldCamera.SlerpPercentage = 1.0;
					Angle rotateCounterclockwise = Angle.FromRadians(-0.01f);
					this.drawArgs.WorldCamera.Heading += rotateCounterclockwise;
					this.drawArgs.WorldCamera.RotationYawPitchRoll(Angle.Zero, Angle.Zero, rotateCounterclockwise);
					break;
				// rotate up
				case Keys.W:
					this.drawArgs.WorldCamera.SlerpPercentage = 1.0;
					this.drawArgs.WorldCamera.Tilt += Angle.FromDegrees(-1.0f);
					break;
				// rotate down
				case Keys.S:
					this.drawArgs.WorldCamera.SlerpPercentage = 1.0;
					this.drawArgs.WorldCamera.Tilt += Angle.FromDegrees(1.0f);
					break;
				// pan left
				case Keys.Left:
				case Keys.H:
				case Keys.NumPad4:
					// TODO: pan n pixels
					this.drawArgs.WorldCamera.SlerpPercentage = 1.0;
					Angle panLeft = Angle.FromRadians((float)-1 * (this.drawArgs.WorldCamera.Altitude) * (1 / (300 * this.CurrentWorld.EquatorialRadius)));
					this.drawArgs.WorldCamera.RotationYawPitchRoll(panLeft, Angle.Zero, Angle.Zero);
					break;
				// pan down
				case Keys.Down:
				case Keys.J:
				case Keys.NumPad2:
					this.drawArgs.WorldCamera.SlerpPercentage = 1.0;
					Angle panDown = Angle.FromRadians((float)-1 * (this.drawArgs.WorldCamera.Altitude) * (1 / (300 * this.CurrentWorld.EquatorialRadius)));
					this.drawArgs.WorldCamera.RotationYawPitchRoll(Angle.Zero, panDown, Angle.Zero);
					break;
				// pan right
				case Keys.Right:
				case Keys.K:
				case Keys.NumPad6:
					this.drawArgs.WorldCamera.SlerpPercentage = 1.0;
					Angle panRight = Angle.FromRadians((float)1 * (this.drawArgs.WorldCamera.Altitude) * (1 / (300 * this.CurrentWorld.EquatorialRadius)));
					this.drawArgs.WorldCamera.RotationYawPitchRoll(panRight, Angle.Zero, Angle.Zero);
					break;
				// pan up
				case Keys.Up:
				case Keys.U:
				case Keys.NumPad8:
					// TODO: Pan n pixels
					this.drawArgs.WorldCamera.SlerpPercentage = 1.0;
					Angle panUp = Angle.FromRadians((float)1 * (this.drawArgs.WorldCamera.Altitude) * (1 / (300 * this.CurrentWorld.EquatorialRadius)));
					this.drawArgs.WorldCamera.RotationYawPitchRoll(Angle.Zero, panUp, Angle.Zero);
					break;
				// zoom in
				case Keys.Add:
				case Keys.Oemplus:
				case Keys.Home:
				case Keys.NumPad7:
					this.drawArgs.WorldCamera.SlerpPercentage = 1.0;
					this.drawArgs.WorldCamera.ZoomStepped(World.Settings.CameraZoomStepKeyboard);
					break;
				// zoom out
				case Keys.Subtract:
				case Keys.OemMinus:
				case Keys.End:
				case Keys.NumPad1:
					this.drawArgs.WorldCamera.SlerpPercentage = 1.0;
					this.drawArgs.WorldCamera.ZoomStepped(-World.Settings.CameraZoomStepKeyboard);
					break;
#if DEBUG
				case Keys.Escape:
					this.supressUpdates ^= true;
					break;
#endif
			}
			return true;
		}

		/// <summary>
		/// Handles key up events.
		/// </summary>
		/// <param name="e"></param>
		/// <returns>Returns true if the key is handled.</returns>
		internal bool HandleKeyUp(KeyEventArgs e)
		{
			bool handled = m_RootWidget.OnKeyUp(e);
			if (handled)
			{
				e.Handled = handled;
				return handled;
			}
			handled = m_NewRootWidget.OnKeyUp(e);
			if (handled)
			{
				e.Handled = handled;
				return handled;
			}

			// Alt key down
			if (e.Alt)
			{
			}
			// Control key down
			else if (e.Control)
			{
				switch (e.KeyCode)
				{
					case Keys.D:
						this.showDiagnosticInfo = !this.showDiagnosticInfo;
						return true;
					case Keys.W:
						renderWireFrame = !renderWireFrame;
						return true;
				}
			}
			// Other and no control key
			else
			{
				switch (e.KeyCode)
				{
					case Keys.Space:
					case Keys.Clear:
						this.drawArgs.WorldCamera.SlerpPercentage = World.Settings.CameraSlerpInertia;
						this.drawArgs.WorldCamera.Reset();
						return true;
				}
			}
			return false;
		}

		protected override void OnMouseDown(MouseEventArgs e)
		{
			this.Focus();  //fixes mousewheel not working problem

			if (!IsWorldReady())
			{
				return;
			}

			DrawArgs.LastMousePosition.X = e.X;
			DrawArgs.LastMousePosition.Y = e.Y;

			mouseDownStartPosition.X = e.X;
			mouseDownStartPosition.Y = e.Y;


			try
			{
				bool handled = false;
				handled = m_RootWidget.OnMouseDown(e);

				if (!handled)
				{
					handled = m_NewRootWidget.OnMouseDown(e);
				}
			}
			finally
			{
				if (e.Button == MouseButtons.Left)
					DrawArgs.IsLeftMouseButtonDown = true;

				if (e.Button == MouseButtons.Right)
					DrawArgs.IsRightMouseButtonDown = true;
				// Call the base class method so that registered delegates receive the event.
				base.OnMouseDown(e);
			}
		}

		bool isDoubleClick;
		protected override void OnMouseDoubleClick(MouseEventArgs e)
		{
			isDoubleClick = true;
			base.OnMouseDoubleClick(e);
		}

		protected override void OnMouseUp(MouseEventArgs e)
		{
			if (!IsWorldReady())
			{
				return;
			}
			DrawArgs.LastMousePosition.X = e.X;
			DrawArgs.LastMousePosition.Y = e.Y;

			try
			{
				bool handled = false;

				handled = m_RootWidget.OnMouseUp(e);

				if (!handled)
				{
					handled = m_NewRootWidget.OnMouseUp(e);
				}

				if (!handled)
				{
					// Mouse must have been clicked outside our window and released on us, ignore
					if (mouseDownStartPosition == Point.Empty)
						return;

					mouseDownStartPosition = Point.Empty;

					if (m_World == null)
						return;

					if (isDoubleClick)
					{
						isDoubleClick = false;
						if (e.Button == MouseButtons.Left)
						{
							drawArgs.WorldCamera.SlerpPercentage = 1.0;
							drawArgs.WorldCamera.Zoom(World.Settings.CameraDoubleClickZoomFactor);
						}
						else if (e.Button == MouseButtons.Right)
						{
							drawArgs.WorldCamera.SlerpPercentage = 1.0;
							drawArgs.WorldCamera.Zoom(-World.Settings.CameraDoubleClickZoomFactor);
						}
					}
					else
					{
						if (e.Button == MouseButtons.Left)
						{
							if (this.isMouseDragging)
							{
								this.isMouseDragging = false;
							}
							else
							{
								Angle targetLatitude;
								Angle targetLongitude;
								//Quaternion targetOrientation = new Quaternion();
								this.drawArgs.WorldCamera.PickingRayIntersection(
									 DrawArgs.LastMousePosition.X,
									 DrawArgs.LastMousePosition.Y,
									 out targetLatitude,
									 out targetLongitude);
								if (this.drawArgs.WorldCamera.Altitude < 60e3)
									this.drawArgs.WorldCamera.PickingRayIntersectionWithTerrain(
									 DrawArgs.LastMousePosition.X,
									 DrawArgs.LastMousePosition.Y,
									 out targetLatitude,
									 out targetLongitude,
									 m_World);
								if (!Angle.IsNaN(targetLatitude))
								{
									this.drawArgs.WorldCamera.SlerpPercentage = World.Settings.CameraSlerpInertia;
									this.drawArgs.WorldCamera.PointGoto(targetLatitude, targetLongitude);
								}
							}
						}
						else if (e.Button == MouseButtons.Right)
						{
							if (this.isMouseDragging)
								this.isMouseDragging = false;
						}
						else if (e.Button == MouseButtons.Middle)
						{
							if (this.isMouseDragging)
								this.isMouseDragging = false;
							else
							{
								// Switch sun shading on/off
								World.Settings.EnableSunShading = !World.Settings.EnableSunShading;
							}
						}
					}
				}
			}
			finally
			{
				if (e.Button == MouseButtons.Left)
					DrawArgs.IsLeftMouseButtonDown = false;

				if (e.Button == MouseButtons.Right)
					DrawArgs.IsRightMouseButtonDown = false;
				// Call the base class method so that registered delegates receive the event.
				base.OnMouseUp(e);
			}
		}

		private bool IsWorldReady()
		{
			if (this.m_World == null || this.drawArgs == null || this.drawArgs.WorldCamera == null)
				return false;
			else
				return true;
		}

		protected override void OnMouseMove(MouseEventArgs e)
		{
			if (!IsWorldReady())
			{
				return;
			}
			// Default to default cursor
			DrawArgs.MouseCursor = CursorType.Arrow;

			try
			{
				bool handled = false;
				if (!isMouseDragging)
				{
					handled = m_RootWidget.OnMouseMove(e);

					if (!handled)
					{
						handled = m_NewRootWidget.OnMouseMove(e);
					}
				}

				if (!handled)
				{
					int deltaX = e.X - DrawArgs.LastMousePosition.X;
					int deltaY = e.Y - DrawArgs.LastMousePosition.Y;
					float deltaXNormalized = (float)deltaX / drawArgs.screenWidth;
					float deltaYNormalized = (float)deltaY / drawArgs.screenHeight;

					if (mouseDownStartPosition == Point.Empty)
						return;

					bool isMouseLeftButtonDown = ((int)e.Button & (int)MouseButtons.Left) != 0;
					bool isMouseRightButtonDown = ((int)e.Button & (int)MouseButtons.Right) != 0;
					bool isMouseMiddleButtonDown = ((int)e.Button & (int)MouseButtons.Middle) != 0;
					if (isMouseLeftButtonDown || isMouseRightButtonDown || isMouseMiddleButtonDown)
					{
						int dx = this.mouseDownStartPosition.X - e.X;
						int dy = this.mouseDownStartPosition.Y - e.Y;
						int distanceSquared = dx * dx + dy * dy;
						if (distanceSquared > 3 * 3)
							// Distance > 3 = drag
							this.isMouseDragging = true;
					}

					if (isMouseLeftButtonDown && !isMouseRightButtonDown && !isMouseMiddleButtonDown)
					{
						// Left button (pan)
						// Store start lat/lon for drag
						Angle prevLat, prevLon;
						this.drawArgs.WorldCamera.PickingRayIntersection(
							DrawArgs.LastMousePosition.X,
							DrawArgs.LastMousePosition.Y,
							out prevLat,
							out prevLon);

						Angle curLat, curLon;
						this.drawArgs.WorldCamera.PickingRayIntersection(
							e.X,
							e.Y,
							out curLat,
							out curLon);

						if (World.Settings.CameraTwistLock)
						{
							this.drawArgs.WorldCamera.SlerpPercentage = 1.0;
							if (Angle.IsNaN(curLat) || Angle.IsNaN(prevLat))
							{
								// Old style pan
								Angle deltaLat = Angle.FromRadians((double)deltaY * (this.drawArgs.WorldCamera.Altitude) / (800 * this.CurrentWorld.EquatorialRadius));
								Angle deltaLon = Angle.FromRadians((double)-deltaX * (this.drawArgs.WorldCamera.Altitude) / (800 * this.CurrentWorld.EquatorialRadius));
								this.drawArgs.WorldCamera.Pan(deltaLat, deltaLon);
							}
							else
							{
								//Picking ray pan
								Angle lat = prevLat - curLat;
								Angle lon = prevLon - curLon;
								this.drawArgs.WorldCamera.Pan(lat, lon);
							}
						}
						else
						{
							double factor = (this.drawArgs.WorldCamera.Altitude) / (1500 * this.CurrentWorld.EquatorialRadius);
							this.drawArgs.WorldCamera.SlerpPercentage = 1.0;
							drawArgs.WorldCamera.RotationYawPitchRoll(
								Angle.FromRadians(DrawArgs.LastMousePosition.X - e.X) * factor,
								Angle.FromRadians(e.Y - DrawArgs.LastMousePosition.Y) * factor,
								Angle.Zero);
						}
					}
					else if (!isMouseLeftButtonDown && isMouseRightButtonDown && !isMouseMiddleButtonDown)
					{
						//Right mouse button

						// Heading
						Angle deltaEyeDirection = Angle.FromRadians(-deltaXNormalized * World.Settings.CameraRotationSpeed);
						this.drawArgs.WorldCamera.SlerpPercentage = 1.0;
						this.drawArgs.WorldCamera.RotationYawPitchRoll(Angle.Zero, Angle.Zero, deltaEyeDirection);

						// tilt
						this.drawArgs.WorldCamera.Tilt += Angle.FromRadians(deltaYNormalized * World.Settings.CameraRotationSpeed);
					}
					else if (isMouseLeftButtonDown && isMouseRightButtonDown)
					{
						// Both buttons (zoom)
						// Zoom
						this.drawArgs.WorldCamera.SlerpPercentage = 1.0;
						if (Math.Abs(deltaYNormalized) > float.Epsilon)
							this.drawArgs.WorldCamera.Zoom(-deltaYNormalized * World.Settings.CameraZoomAnalogFactor);

						if (!World.Settings.CameraBankLock)
							this.drawArgs.WorldCamera.Bank -= Angle.FromRadians(deltaXNormalized * World.Settings.CameraRotationSpeed);
					}
					else if (!isMouseLeftButtonDown && !isMouseRightButtonDown && isMouseMiddleButtonDown)
					{
						// Middle button
						if (World.Settings.EnableSunShading)
						{
							// Sun light control
							if (Math.Abs(deltaYNormalized) > float.Epsilon) World.Settings.SunElevation -= deltaYNormalized * Math.PI;
							if (Math.Abs(deltaXNormalized) > float.Epsilon) World.Settings.SunHeading -= deltaXNormalized * Math.PI;
							if (World.Settings.SunElevation < MathEngine.DegreesToRadians(-10)) World.Settings.SunElevation = MathEngine.DegreesToRadians(-10);
							if (World.Settings.SunElevation > MathEngine.DegreesToRadians(90)) World.Settings.SunElevation = MathEngine.DegreesToRadians(90);
							if (World.Settings.SunHeading < -Math.PI) World.Settings.SunHeading += Math.PI * 2;
							if (World.Settings.SunHeading > Math.PI) World.Settings.SunHeading -= Math.PI * 2;
						}
					}
				}
			}
			finally
			{

				this.drawArgs.WorldCamera.PickingRayIntersection(
					e.X,
					e.Y,
					out cLat,
					out cLon);

				DrawArgs.LastMousePosition.X = e.X;
				DrawArgs.LastMousePosition.Y = e.Y;
				base.OnMouseMove(e);
			}
		}

		Angle cLat, cLon;

		protected override void OnMouseLeave(EventArgs e)
		{
			if (!IsWorldReady())
			{
				return;
			}
			base.OnMouseLeave(e);
		}

		#endregion

		public void KillWorkerThread()
		{
			if (InvokeRequired)
			{
				Invoke(new MethodInvoker(KillWorkerThread));
			}
			else
			{
				m_WorkerThreadRunning = false;
				m_WorkerThread.Join();
			}
		}

		private void m_Device3d_DeviceResizing(object sender, CancelEventArgs e)
		{
			if (!m_Device3d.CheckCooperativeLevel() || this.Size.Width == 0 || this.Size.Height == 0)
			{
				e.Cancel = true;
				return;
			}

			this.drawArgs.screenHeight = this.Height;
			this.drawArgs.screenWidth = this.Width;
		}


		/// <summary>
		/// Returns true if executing in Design mode (inside IDE)
		/// </summary>
		/// <returns></returns>
		private static bool IsInDesignMode()
		{
			return Application.ExecutablePath.EndsWith("DEVENV.EXE", StringComparison.OrdinalIgnoreCase);
		}

		private void InitializeGraphics()
		{
			// Set up our presentation parameters
			m_presentParams = new PresentParameters();

			m_presentParams.Windowed = true;
			m_presentParams.SwapEffect = SwapEffect.Discard;
			m_presentParams.AutoDepthStencilFormat = DepthFormat.D16;
			m_presentParams.EnableAutoDepthStencil = true;

			if (!World.Settings.VSync)
				// Disable wait for vertical retrace (higher frame rate at the expense of tearing)
				m_presentParams.PresentationInterval = PresentInterval.Immediate;

			int adapterOrdinal = 0;
			try
			{
				// Store the default adapter
				adapterOrdinal = Manager.Adapters.Default.Adapter;
			}
			catch
			{
				// User probably needs to upgrade DirectX or install a 3D capable graphics adapter
				throw new NotAvailableException();
			}

			DeviceType dType = DeviceType.Hardware;
			CreateFlags flags = CreateFlags.SoftwareVertexProcessing;

			// Check to see if we can use a pure hardware m_Device3d
			Caps caps = Manager.GetDeviceCaps(adapterOrdinal, DeviceType.Hardware);

			// Do we support hardware vertex processing?
			if (caps.DeviceCaps.SupportsHardwareTransformAndLight)
				//	// Replace the software vertex processing
				flags = CreateFlags.HardwareVertexProcessing;

			// Use multi-threading for now - TODO: See if the code can be changed such that this isn't necessary (Texture Loading for example)
			flags |= CreateFlags.MultiThreaded | CreateFlags.FpuPreserve;

			try
			{
				// Create our m_Device3d
				m_Device3d = new Device(adapterOrdinal, dType, this, flags, m_presentParams);
			}
			catch (Microsoft.DirectX.DirectXException)
			{
				throw new NotSupportedException("Unable to create the Direct3D m_Device3d.");
			}

			// Hook the m_Device3d reset event
			m_Device3d.DeviceReset += new EventHandler(OnDeviceReset);
			m_Device3d.DeviceResizing += new CancelEventHandler(m_Device3d_DeviceResizing);
			OnDeviceReset(m_Device3d, null);
		}

		private void OnDeviceReset(object sender, EventArgs e)
		{
			// Can we use anisotropic texture minify filter?
			if (m_Device3d.DeviceCaps.TextureFilterCaps.SupportsMinifyAnisotropic)
			{
				m_Device3d.SamplerState[0].MinFilter = TextureFilter.Anisotropic;
			}
			else if (m_Device3d.DeviceCaps.TextureFilterCaps.SupportsMinifyLinear)
			{
				m_Device3d.SamplerState[0].MinFilter = TextureFilter.Linear;
			}

			// What about magnify filter?
			if (m_Device3d.DeviceCaps.TextureFilterCaps.SupportsMagnifyAnisotropic)
			{
				m_Device3d.SamplerState[0].MagFilter = TextureFilter.Anisotropic;
			}
			else if (m_Device3d.DeviceCaps.TextureFilterCaps.SupportsMagnifyLinear)
			{
				m_Device3d.SamplerState[0].MagFilter = TextureFilter.Linear;
			}

			m_Device3d.SamplerState[0].AddressU = TextureAddress.Clamp;
			m_Device3d.SamplerState[0].AddressV = TextureAddress.Clamp;

			m_Device3d.RenderState.Clipping = true;
			m_Device3d.RenderState.CullMode = Cull.Clockwise;
			m_Device3d.RenderState.Lighting = false;
			m_Device3d.RenderState.Ambient = World.Settings.StandardAmbientColor;

			m_Device3d.RenderState.ZBufferEnable = true;
			m_Device3d.RenderState.AlphaBlendEnable = true;
			m_Device3d.RenderState.SourceBlend = Blend.SourceAlpha;
			m_Device3d.RenderState.DestinationBlend = Blend.InvSourceAlpha;
		}



		public event EventHandler Updated;
		private const int WORKER_THREAD_REFRESH_INTERVAL = 150; // Max 6 updates per seconds

		/// <summary>
		/// Background worker thread loop (updates UI)
		/// </summary>
		private void WorkerThreadFunc()
		{
			while (m_WorkerThreadRunning)
			{
				if (World.Settings.UseBelowNormalPriorityUpdateThread && m_WorkerThread.Priority == System.Threading.ThreadPriority.Normal)
				{
					m_WorkerThread.Priority = System.Threading.ThreadPriority.BelowNormal;
				}
				else if (!World.Settings.UseBelowNormalPriorityUpdateThread && m_WorkerThread.Priority == System.Threading.ThreadPriority.BelowNormal)
				{
					m_WorkerThread.Priority = System.Threading.ThreadPriority.Normal;
				}

				long startTicks = 0;
				PerformanceTimer.QueryPerformanceCounter(ref startTicks);

#if DEBUG
				if (!supressUpdates)
				{
					drawArgs.CurrentRoI = GeographicBoundingBox.FromQuad(CurrentAreaOfInterest);
					m_World.Update(this.drawArgs);
				}
#endif
				if (Updated != null)
					Updated(this, EventArgs.Empty);

				long endTicks = 0;
				PerformanceTimer.QueryPerformanceCounter(ref endTicks);
				float elapsedMilliSeconds = 1000 * (float)(endTicks - startTicks) / PerformanceTimer.TicksPerSecond;
				float remaining = WORKER_THREAD_REFRESH_INTERVAL - elapsedMilliSeconds;
				if (remaining <= 50)
					remaining = 50; // Always sleep for at least a little bit. Otherwise, you starve the rendering thread.
				Thread.Sleep((int)remaining);
			}
		}

		public void SetViewPosition(double degreesLatitude, double degreesLongitude,
			double metersElevation)
		{
			this.drawArgs.WorldCamera.SlerpPercentage = World.Settings.CameraSlerpInertia;
			this.drawArgs.WorldCamera.SetPosition(degreesLatitude, degreesLongitude, this.drawArgs.WorldCamera.Heading.Degrees,
				metersElevation, this.drawArgs.WorldCamera.Tilt.Degrees);
		}

		bool m_FpsUpdate;
		private void m_FpsTimer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)
		{
			if (m_FpsUpdate)
				return;

			m_FpsUpdate = true;

			if (World.Settings.ShowFpsGraph)
			{
				if (!m_FpsGraph.Visible)
				{
					m_FpsGraph.Visible = true;
				}

				if (m_FrameTimes.Count > World.Settings.FpsFrameCount)
				{
					m_FrameTimes.RemoveRange(0, m_FrameTimes.Count - World.Settings.FpsFrameCount);
				}

				m_FpsGraph.Size = new Size((int)(Width * .5), (int)(Height * .1));
				m_FpsGraph.Location = new Point((int)(Width * .35), (int)(Height * .895));
				m_FpsGraph.Values = (float[])m_FrameTimes.ToArray(typeof(float));
			}
			else
			{
				if (m_FpsGraph.Visible)
				{
					m_FpsGraph.Visible = false;
				}
			}

			m_FpsUpdate = false;
		}

		protected override void OnResize(EventArgs e)
		{
			try
			{
				base.OnResize(e);
			}
			catch (OutOfVideoMemoryException)
			{
				KillD3DAndWorkerThread();
				if (VideoMemoryExhausted != null)
					VideoMemoryExhausted(this, EventArgs.Empty);
			}
			catch (InvalidCallException)
			{
				// A few users were getting exceptions here on startup. Set the device lost
				// flag and hope that the recovery code can take care of it.
				m_blDeviceLost = true;
			}
		}

		public void KillD3DAndWorkerThread()
		{
			if (m_WorkerThread != null)
			{
				m_WorkerThreadRunning = false;
				m_WorkerThread.Abort();
				m_WorkerThread = null;
			}

			if (m_Device3d != null)
			{
				m_Device3d.Dispose();
				m_Device3d = null;
			}
		}
	}
}
