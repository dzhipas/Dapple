//
// datasetType.cs
//
// This file was generated by XMLSpy 2007r3 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//


using System;
using System.Collections;
using System.Xml;
using Altova.Types;

namespace dappleview
{
	public class datasetType : Altova.Xml.Node
	{
		#region Documentation
		public static string GetAnnoDocumentation() { return ""; }
		#endregion

		#region Forward constructors

		public datasetType() : base() { SetCollectionParents(); }

		public datasetType(XmlDocument doc) : base(doc) { SetCollectionParents(); }
		public datasetType(XmlNode node) : base(node) { SetCollectionParents(); }
		public datasetType(Altova.Xml.Node node) : base(node) { SetCollectionParents(); }
		public datasetType(Altova.Xml.Document doc, string namespaceURI, string prefix, string name) : base(doc, namespaceURI, prefix, name) { SetCollectionParents(); }
		#endregion // Forward constructors

		public override void AdjustPrefix()
		{

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Attribute, "", "name" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Attribute, "", "name", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, false);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Attribute, "", "uri" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Attribute, "", "uri", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, false);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Attribute, "", "opacity" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Attribute, "", "opacity", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, false);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Attribute, "", "hierarchy" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Attribute, "", "hierarchy", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, false);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Attribute, "", "invisible" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Attribute, "", "invisible", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, false);
			}
		}

		public void SetXsiType()
		{
 			XmlElement el = (XmlElement) domNode;
			el.SetAttribute("type", "http://www.w3.org/2001/XMLSchema-instance", "dataset");
		}


		#region name Documentation
		public static string GetnameAnnoDocumentation()
		{
			return "";		
		}
		public static string GetnameDefault()
		{
			return "";		
		}
		#endregion

		#region name accessor methods
		public static int GetnameMinCount()
		{
			return 1;
		}

		public static int nameMinCount
		{
			get
			{
				return 1;
			}
		}

		public static int GetnameMaxCount()
		{
			return 1;
		}

		public static int nameMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetnameCount()
		{
			return DomChildCount(NodeType.Attribute, "", "name");
		}

		public int nameCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "name");
			}
		}

		public bool Hasname()
		{
			return HasDomChild(NodeType.Attribute, "", "name");
		}

		public SchemaString Newname()
		{
			return new SchemaString();
		}

		public SchemaString GetnameAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "name", index)));
		}

		public XmlNode GetStartingnameCursor()
		{
			return GetDomFirstChild( NodeType.Attribute, "", "name" );
		}

		public XmlNode GetAdvancednameCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Attribute, "", "name", curNode );
		}

		public SchemaString GetnameValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.Value );
		}


		public SchemaString Getname()
		{
			return GetnameAt(0);
		}

		public SchemaString name
		{
			get
			{
				return GetnameAt(0);
			}
		}

		public void RemovenameAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "name", index);
		}

		public void Removename()
		{
			RemovenameAt(0);
		}

		public XmlNode Addname(SchemaString newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Attribute, "", "name", newValue.ToString());
			return null;
		}

		public void InsertnameAt(SchemaString newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Attribute, "", "name", index, newValue.ToString());
		}

		public void ReplacenameAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "name", index, newValue.ToString());
		}
		#endregion // name accessor methods

		#region name collection
        public nameCollection	Mynames = new nameCollection( );

        public class nameCollection: IEnumerable
        {
            datasetType parent;
            public datasetType Parent
			{
				set
				{
					parent = value;
				}
			}
			public nameEnumerator GetEnumerator() 
			{
				return new nameEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class nameEnumerator: IEnumerator 
        {
			int nIndex;
			datasetType parent;
			public nameEnumerator(datasetType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.nameCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetnameAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // name collection

		#region uri Documentation
		public static string GeturiAnnoDocumentation()
		{
			return "";		
		}
		public static string GeturiDefault()
		{
			return "";		
		}
		#endregion

		#region uri accessor methods
		public static int GeturiMinCount()
		{
			return 1;
		}

		public static int uriMinCount
		{
			get
			{
				return 1;
			}
		}

		public static int GeturiMaxCount()
		{
			return 1;
		}

		public static int uriMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GeturiCount()
		{
			return DomChildCount(NodeType.Attribute, "", "uri");
		}

		public int uriCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "uri");
			}
		}

		public bool Hasuri()
		{
			return HasDomChild(NodeType.Attribute, "", "uri");
		}

		public SchemaString Newuri()
		{
			return new SchemaString();
		}

		public SchemaString GeturiAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "uri", index)));
		}

		public XmlNode GetStartinguriCursor()
		{
			return GetDomFirstChild( NodeType.Attribute, "", "uri" );
		}

		public XmlNode GetAdvanceduriCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Attribute, "", "uri", curNode );
		}

		public SchemaString GeturiValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.Value );
		}


		public SchemaString Geturi()
		{
			return GeturiAt(0);
		}

		public SchemaString uri
		{
			get
			{
				return GeturiAt(0);
			}
		}

		public void RemoveuriAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "uri", index);
		}

		public void Removeuri()
		{
			RemoveuriAt(0);
		}

		public XmlNode Adduri(SchemaString newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Attribute, "", "uri", newValue.ToString());
			return null;
		}

		public void InserturiAt(SchemaString newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Attribute, "", "uri", index, newValue.ToString());
		}

		public void ReplaceuriAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "uri", index, newValue.ToString());
		}
		#endregion // uri accessor methods

		#region uri collection
        public uriCollection	Myuris = new uriCollection( );

        public class uriCollection: IEnumerable
        {
            datasetType parent;
            public datasetType Parent
			{
				set
				{
					parent = value;
				}
			}
			public uriEnumerator GetEnumerator() 
			{
				return new uriEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class uriEnumerator: IEnumerator 
        {
			int nIndex;
			datasetType parent;
			public uriEnumerator(datasetType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.uriCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GeturiAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // uri collection

		#region opacity Documentation
		public static string GetopacityAnnoDocumentation()
		{
			return "";		
		}
		public static string GetopacityDefault()
		{
			return "255";		
		}
		#endregion

		#region opacity accessor methods
		public static int GetopacityMinCount()
		{
			return 0;
		}

		public static int opacityMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetopacityMaxCount()
		{
			return 1;
		}

		public static int opacityMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetopacityCount()
		{
			return DomChildCount(NodeType.Attribute, "", "opacity");
		}

		public int opacityCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "opacity");
			}
		}

		public bool Hasopacity()
		{
			return HasDomChild(NodeType.Attribute, "", "opacity");
		}

		public opacityType Newopacity()
		{
			return new opacityType();
		}

		public opacityType GetopacityAt(int index)
		{
			return new opacityType(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "opacity", index)));
		}

		public XmlNode GetStartingopacityCursor()
		{
			return GetDomFirstChild( NodeType.Attribute, "", "opacity" );
		}

		public XmlNode GetAdvancedopacityCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Attribute, "", "opacity", curNode );
		}

		public opacityType GetopacityValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new opacityType( curNode.Value );
		}


		public opacityType Getopacity()
		{
			return GetopacityAt(0);
		}

		public opacityType opacity
		{
			get
			{
				return GetopacityAt(0);
			}
		}

		public void RemoveopacityAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "opacity", index);
		}

		public void Removeopacity()
		{
			RemoveopacityAt(0);
		}

		public XmlNode Addopacity(opacityType newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Attribute, "", "opacity", newValue.ToString());
			return null;
		}

		public void InsertopacityAt(opacityType newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Attribute, "", "opacity", index, newValue.ToString());
		}

		public void ReplaceopacityAt(opacityType newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "opacity", index, newValue.ToString());
		}
		#endregion // opacity accessor methods

		#region opacity collection
        public opacityCollection	Myopacitys = new opacityCollection( );

        public class opacityCollection: IEnumerable
        {
            datasetType parent;
            public datasetType Parent
			{
				set
				{
					parent = value;
				}
			}
			public opacityEnumerator GetEnumerator() 
			{
				return new opacityEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class opacityEnumerator: IEnumerator 
        {
			int nIndex;
			datasetType parent;
			public opacityEnumerator(datasetType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.opacityCount );
			}
			public opacityType  Current 
			{
				get 
				{
					return(parent.GetopacityAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // opacity collection

		#region hierarchy Documentation
		public static string GethierarchyAnnoDocumentation()
		{
			return "";		
		}
		public static string GethierarchyDefault()
		{
			return "";		
		}
		#endregion

		#region hierarchy accessor methods
		public static int GethierarchyMinCount()
		{
			return 0;
		}

		public static int hierarchyMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GethierarchyMaxCount()
		{
			return 1;
		}

		public static int hierarchyMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GethierarchyCount()
		{
			return DomChildCount(NodeType.Attribute, "", "hierarchy");
		}

		public int hierarchyCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "hierarchy");
			}
		}

		public bool Hashierarchy()
		{
			return HasDomChild(NodeType.Attribute, "", "hierarchy");
		}

		public SchemaString Newhierarchy()
		{
			return new SchemaString();
		}

		public SchemaString GethierarchyAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "hierarchy", index)));
		}

		public XmlNode GetStartinghierarchyCursor()
		{
			return GetDomFirstChild( NodeType.Attribute, "", "hierarchy" );
		}

		public XmlNode GetAdvancedhierarchyCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Attribute, "", "hierarchy", curNode );
		}

		public SchemaString GethierarchyValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.Value );
		}


		public SchemaString Gethierarchy()
		{
			return GethierarchyAt(0);
		}

		public SchemaString hierarchy
		{
			get
			{
				return GethierarchyAt(0);
			}
		}

		public void RemovehierarchyAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "hierarchy", index);
		}

		public void Removehierarchy()
		{
			RemovehierarchyAt(0);
		}

		public XmlNode Addhierarchy(SchemaString newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Attribute, "", "hierarchy", newValue.ToString());
			return null;
		}

		public void InserthierarchyAt(SchemaString newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Attribute, "", "hierarchy", index, newValue.ToString());
		}

		public void ReplacehierarchyAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "hierarchy", index, newValue.ToString());
		}
		#endregion // hierarchy accessor methods

		#region hierarchy collection
        public hierarchyCollection	Myhierarchys = new hierarchyCollection( );

        public class hierarchyCollection: IEnumerable
        {
            datasetType parent;
            public datasetType Parent
			{
				set
				{
					parent = value;
				}
			}
			public hierarchyEnumerator GetEnumerator() 
			{
				return new hierarchyEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class hierarchyEnumerator: IEnumerator 
        {
			int nIndex;
			datasetType parent;
			public hierarchyEnumerator(datasetType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.hierarchyCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GethierarchyAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // hierarchy collection

		#region invisible Documentation
		public static string GetinvisibleAnnoDocumentation()
		{
			return "";		
		}
		public static string GetinvisibleDefault()
		{
			return "false";		
		}
		#endregion

		#region invisible accessor methods
		public static int GetinvisibleMinCount()
		{
			return 0;
		}

		public static int invisibleMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetinvisibleMaxCount()
		{
			return 1;
		}

		public static int invisibleMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetinvisibleCount()
		{
			return DomChildCount(NodeType.Attribute, "", "invisible");
		}

		public int invisibleCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "invisible");
			}
		}

		public bool Hasinvisible()
		{
			return HasDomChild(NodeType.Attribute, "", "invisible");
		}

		public SchemaBoolean Newinvisible()
		{
			return new SchemaBoolean();
		}

		public SchemaBoolean GetinvisibleAt(int index)
		{
			return new SchemaBoolean(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "invisible", index)));
		}

		public XmlNode GetStartinginvisibleCursor()
		{
			return GetDomFirstChild( NodeType.Attribute, "", "invisible" );
		}

		public XmlNode GetAdvancedinvisibleCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Attribute, "", "invisible", curNode );
		}

		public SchemaBoolean GetinvisibleValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaBoolean( curNode.Value );
		}


		public SchemaBoolean Getinvisible()
		{
			return GetinvisibleAt(0);
		}

		public SchemaBoolean invisible
		{
			get
			{
				return GetinvisibleAt(0);
			}
		}

		public void RemoveinvisibleAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "invisible", index);
		}

		public void Removeinvisible()
		{
			RemoveinvisibleAt(0);
		}

		public XmlNode Addinvisible(SchemaBoolean newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Attribute, "", "invisible", newValue.ToString());
			return null;
		}

		public void InsertinvisibleAt(SchemaBoolean newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Attribute, "", "invisible", index, newValue.ToString());
		}

		public void ReplaceinvisibleAt(SchemaBoolean newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "invisible", index, newValue.ToString());
		}
		#endregion // invisible accessor methods

		#region invisible collection
        public invisibleCollection	Myinvisibles = new invisibleCollection( );

        public class invisibleCollection: IEnumerable
        {
            datasetType parent;
            public datasetType Parent
			{
				set
				{
					parent = value;
				}
			}
			public invisibleEnumerator GetEnumerator() 
			{
				return new invisibleEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class invisibleEnumerator: IEnumerator 
        {
			int nIndex;
			datasetType parent;
			public invisibleEnumerator(datasetType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.invisibleCount );
			}
			public SchemaBoolean  Current 
			{
				get 
				{
					return(parent.GetinvisibleAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // invisible collection

        private void SetCollectionParents()
        {
            Mynames.Parent = this; 
            Myuris.Parent = this; 
            Myopacitys.Parent = this; 
            Myhierarchys.Parent = this; 
            Myinvisibles.Parent = this; 
	}
}
}
