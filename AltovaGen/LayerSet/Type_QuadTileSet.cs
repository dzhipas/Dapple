//
// Type_QuadTileSet.cs
//
// This file was generated by XMLSpy 2007r3 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//


using System;
using System.Collections;
using System.Xml;
using Altova.Types;

namespace LayerSet
{
	public class Type_QuadTileSet : Altova.Xml.Node
	{
		#region Documentation
		public static string GetAnnoDocumentation() { return ""; }
		#endregion

		#region Forward constructors

		public Type_QuadTileSet() : base() { SetCollectionParents(); }

		public Type_QuadTileSet(XmlDocument doc) : base(doc) { SetCollectionParents(); }
		public Type_QuadTileSet(XmlNode node) : base(node) { SetCollectionParents(); }
		public Type_QuadTileSet(Altova.Xml.Node node) : base(node) { SetCollectionParents(); }
		public Type_QuadTileSet(Altova.Xml.Document doc, string namespaceURI, string prefix, string name) : base(doc, namespaceURI, prefix, name) { SetCollectionParents(); }
		#endregion // Forward constructors

		public override void AdjustPrefix()
		{

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Attribute, "", "ShowAtStartup" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Attribute, "", "ShowAtStartup", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, false);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "Name" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "Name", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "Description" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "Description", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "Effect" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "Effect", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "DistanceAboveSurface" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "DistanceAboveSurface", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "BoundingBox" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "BoundingBox", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
				new Type_LatLonBoundingBox(DOMNode).AdjustPrefix();
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "Opacity" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "Opacity", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "TerrainMapped" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "TerrainMapped", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "RenderStruts" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "RenderStruts", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "ImageAccessor" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "ImageAccessor", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
				new Type_ImageAccessor(DOMNode).AdjustPrefix();
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "ImageAccessorList" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "ImageAccessorList", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
				new Type_ImageAccessorList(DOMNode).AdjustPrefix();
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "TransparentMinValue" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "TransparentMinValue", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "TransparentMaxValue" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "TransparentMaxValue", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "TileDrawDistanceFactor" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "TileDrawDistanceFactor", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "TileSpreadFactor" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "TileSpreadFactor", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "TransparentColor" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "TransparentColor", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
				new Type_RGBColor(DOMNode).AdjustPrefix();
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "ExtendedInformation" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "ExtendedInformation", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
				new Type_ExtendedInformation(DOMNode).AdjustPrefix();
			}
		}

		public void SetXsiType()
		{
 			XmlElement el = (XmlElement) domNode;
			el.SetAttribute("type", "http://www.w3.org/2001/XMLSchema-instance", "Type_QuadTileSet");
		}


		#region ShowAtStartup Documentation
		public static string GetShowAtStartupAnnoDocumentation()
		{
			return "";		
		}
		public static string GetShowAtStartupDefault()
		{
			return "";		
		}
		#endregion

		#region ShowAtStartup accessor methods
		public static int GetShowAtStartupMinCount()
		{
			return 1;
		}

		public static int ShowAtStartupMinCount
		{
			get
			{
				return 1;
			}
		}

		public static int GetShowAtStartupMaxCount()
		{
			return 1;
		}

		public static int ShowAtStartupMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetShowAtStartupCount()
		{
			return DomChildCount(NodeType.Attribute, "", "ShowAtStartup");
		}

		public int ShowAtStartupCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "ShowAtStartup");
			}
		}

		public bool HasShowAtStartup()
		{
			return HasDomChild(NodeType.Attribute, "", "ShowAtStartup");
		}

		public SchemaBoolean NewShowAtStartup()
		{
			return new SchemaBoolean();
		}

		public SchemaBoolean GetShowAtStartupAt(int index)
		{
			return new SchemaBoolean(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "ShowAtStartup", index)));
		}

		public XmlNode GetStartingShowAtStartupCursor()
		{
			return GetDomFirstChild( NodeType.Attribute, "", "ShowAtStartup" );
		}

		public XmlNode GetAdvancedShowAtStartupCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Attribute, "", "ShowAtStartup", curNode );
		}

		public SchemaBoolean GetShowAtStartupValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaBoolean( curNode.Value );
		}


		public SchemaBoolean GetShowAtStartup()
		{
			return GetShowAtStartupAt(0);
		}

		public SchemaBoolean ShowAtStartup
		{
			get
			{
				return GetShowAtStartupAt(0);
			}
		}

		public void RemoveShowAtStartupAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "ShowAtStartup", index);
		}

		public void RemoveShowAtStartup()
		{
			RemoveShowAtStartupAt(0);
		}

		public XmlNode AddShowAtStartup(SchemaBoolean newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Attribute, "", "ShowAtStartup", newValue.ToString());
			return null;
		}

		public void InsertShowAtStartupAt(SchemaBoolean newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Attribute, "", "ShowAtStartup", index, newValue.ToString());
		}

		public void ReplaceShowAtStartupAt(SchemaBoolean newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "ShowAtStartup", index, newValue.ToString());
		}
		#endregion // ShowAtStartup accessor methods

		#region ShowAtStartup collection
        public ShowAtStartupCollection	MyShowAtStartups = new ShowAtStartupCollection( );

        public class ShowAtStartupCollection: IEnumerable
        {
            Type_QuadTileSet parent;
            public Type_QuadTileSet Parent
			{
				set
				{
					parent = value;
				}
			}
			public ShowAtStartupEnumerator GetEnumerator() 
			{
				return new ShowAtStartupEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class ShowAtStartupEnumerator: IEnumerator 
        {
			int nIndex;
			Type_QuadTileSet parent;
			public ShowAtStartupEnumerator(Type_QuadTileSet par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.ShowAtStartupCount );
			}
			public SchemaBoolean  Current 
			{
				get 
				{
					return(parent.GetShowAtStartupAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // ShowAtStartup collection

		#region Name Documentation
		public static string GetNameAnnoDocumentation()
		{
			return "";		
		}
		public static string GetNameDefault()
		{
			return "";		
		}
		#endregion

		#region Name accessor methods
		public static int GetNameMinCount()
		{
			return 1;
		}

		public static int NameMinCount
		{
			get
			{
				return 1;
			}
		}

		public static int GetNameMaxCount()
		{
			return 1;
		}

		public static int NameMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetNameCount()
		{
			return DomChildCount(NodeType.Element, "", "Name");
		}

		public int NameCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Name");
			}
		}

		public bool HasName()
		{
			return HasDomChild(NodeType.Element, "", "Name");
		}

		public SchemaString NewName()
		{
			return new SchemaString();
		}

		public SchemaString GetNameAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "Name", index)));
		}

		public XmlNode GetStartingNameCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "Name" );
		}

		public XmlNode GetAdvancedNameCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "Name", curNode );
		}

		public SchemaString GetNameValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.InnerText );
		}


		public SchemaString GetName()
		{
			return GetNameAt(0);
		}

		public SchemaString Name
		{
			get
			{
				return GetNameAt(0);
			}
		}

		public void RemoveNameAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Name", index);
		}

		public void RemoveName()
		{
			RemoveNameAt(0);
		}

		public XmlNode AddName(SchemaString newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Element, "", "Name", newValue.ToString());
			return null;
		}

		public void InsertNameAt(SchemaString newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "Name", index, newValue.ToString());
		}

		public void ReplaceNameAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "Name", index, newValue.ToString());
		}
		#endregion // Name accessor methods

		#region Name collection
        public NameCollection	MyNames = new NameCollection( );

        public class NameCollection: IEnumerable
        {
            Type_QuadTileSet parent;
            public Type_QuadTileSet Parent
			{
				set
				{
					parent = value;
				}
			}
			public NameEnumerator GetEnumerator() 
			{
				return new NameEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class NameEnumerator: IEnumerator 
        {
			int nIndex;
			Type_QuadTileSet parent;
			public NameEnumerator(Type_QuadTileSet par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.NameCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetNameAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // Name collection

		#region Description Documentation
		public static string GetDescriptionAnnoDocumentation()
		{
			return "";		
		}
		public static string GetDescriptionDefault()
		{
			return "";		
		}
		#endregion

		#region Description accessor methods
		public static int GetDescriptionMinCount()
		{
			return 0;
		}

		public static int DescriptionMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetDescriptionMaxCount()
		{
			return 1;
		}

		public static int DescriptionMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetDescriptionCount()
		{
			return DomChildCount(NodeType.Element, "", "Description");
		}

		public int DescriptionCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Description");
			}
		}

		public bool HasDescription()
		{
			return HasDomChild(NodeType.Element, "", "Description");
		}

		public SchemaString NewDescription()
		{
			return new SchemaString();
		}

		public SchemaString GetDescriptionAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "Description", index)));
		}

		public XmlNode GetStartingDescriptionCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "Description" );
		}

		public XmlNode GetAdvancedDescriptionCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "Description", curNode );
		}

		public SchemaString GetDescriptionValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.InnerText );
		}


		public SchemaString GetDescription()
		{
			return GetDescriptionAt(0);
		}

		public SchemaString Description
		{
			get
			{
				return GetDescriptionAt(0);
			}
		}

		public void RemoveDescriptionAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Description", index);
		}

		public void RemoveDescription()
		{
			RemoveDescriptionAt(0);
		}

		public XmlNode AddDescription(SchemaString newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Element, "", "Description", newValue.ToString());
			return null;
		}

		public void InsertDescriptionAt(SchemaString newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "Description", index, newValue.ToString());
		}

		public void ReplaceDescriptionAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "Description", index, newValue.ToString());
		}
		#endregion // Description accessor methods

		#region Description collection
        public DescriptionCollection	MyDescriptions = new DescriptionCollection( );

        public class DescriptionCollection: IEnumerable
        {
            Type_QuadTileSet parent;
            public Type_QuadTileSet Parent
			{
				set
				{
					parent = value;
				}
			}
			public DescriptionEnumerator GetEnumerator() 
			{
				return new DescriptionEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class DescriptionEnumerator: IEnumerator 
        {
			int nIndex;
			Type_QuadTileSet parent;
			public DescriptionEnumerator(Type_QuadTileSet par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.DescriptionCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetDescriptionAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // Description collection

		#region Effect Documentation
		public static string GetEffectAnnoDocumentation()
		{
			return "";		
		}
		public static string GetEffectDefault()
		{
			return "";		
		}
		#endregion

		#region Effect accessor methods
		public static int GetEffectMinCount()
		{
			return 0;
		}

		public static int EffectMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetEffectMaxCount()
		{
			return 1;
		}

		public static int EffectMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetEffectCount()
		{
			return DomChildCount(NodeType.Element, "", "Effect");
		}

		public int EffectCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Effect");
			}
		}

		public bool HasEffect()
		{
			return HasDomChild(NodeType.Element, "", "Effect");
		}

		public SchemaString NewEffect()
		{
			return new SchemaString();
		}

		public SchemaString GetEffectAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "Effect", index)));
		}

		public XmlNode GetStartingEffectCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "Effect" );
		}

		public XmlNode GetAdvancedEffectCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "Effect", curNode );
		}

		public SchemaString GetEffectValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.InnerText );
		}


		public SchemaString GetEffect()
		{
			return GetEffectAt(0);
		}

		public SchemaString Effect
		{
			get
			{
				return GetEffectAt(0);
			}
		}

		public void RemoveEffectAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Effect", index);
		}

		public void RemoveEffect()
		{
			RemoveEffectAt(0);
		}

		public XmlNode AddEffect(SchemaString newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Element, "", "Effect", newValue.ToString());
			return null;
		}

		public void InsertEffectAt(SchemaString newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "Effect", index, newValue.ToString());
		}

		public void ReplaceEffectAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "Effect", index, newValue.ToString());
		}
		#endregion // Effect accessor methods

		#region Effect collection
        public EffectCollection	MyEffects = new EffectCollection( );

        public class EffectCollection: IEnumerable
        {
            Type_QuadTileSet parent;
            public Type_QuadTileSet Parent
			{
				set
				{
					parent = value;
				}
			}
			public EffectEnumerator GetEnumerator() 
			{
				return new EffectEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class EffectEnumerator: IEnumerator 
        {
			int nIndex;
			Type_QuadTileSet parent;
			public EffectEnumerator(Type_QuadTileSet par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.EffectCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetEffectAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // Effect collection

		#region DistanceAboveSurface Documentation
		public static string GetDistanceAboveSurfaceAnnoDocumentation()
		{
			return "";		
		}
		public static string GetDistanceAboveSurfaceDefault()
		{
			return "";		
		}
		#endregion

		#region DistanceAboveSurface accessor methods
		public static int GetDistanceAboveSurfaceMinCount()
		{
			return 1;
		}

		public static int DistanceAboveSurfaceMinCount
		{
			get
			{
				return 1;
			}
		}

		public static int GetDistanceAboveSurfaceMaxCount()
		{
			return 1;
		}

		public static int DistanceAboveSurfaceMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetDistanceAboveSurfaceCount()
		{
			return DomChildCount(NodeType.Element, "", "DistanceAboveSurface");
		}

		public int DistanceAboveSurfaceCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "DistanceAboveSurface");
			}
		}

		public bool HasDistanceAboveSurface()
		{
			return HasDomChild(NodeType.Element, "", "DistanceAboveSurface");
		}

		public SchemaDouble NewDistanceAboveSurface()
		{
			return new SchemaDouble();
		}

		public SchemaDouble GetDistanceAboveSurfaceAt(int index)
		{
			return new SchemaDouble(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "DistanceAboveSurface", index)));
		}

		public XmlNode GetStartingDistanceAboveSurfaceCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "DistanceAboveSurface" );
		}

		public XmlNode GetAdvancedDistanceAboveSurfaceCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "DistanceAboveSurface", curNode );
		}

		public SchemaDouble GetDistanceAboveSurfaceValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaDouble( curNode.InnerText );
		}


		public SchemaDouble GetDistanceAboveSurface()
		{
			return GetDistanceAboveSurfaceAt(0);
		}

		public SchemaDouble DistanceAboveSurface
		{
			get
			{
				return GetDistanceAboveSurfaceAt(0);
			}
		}

		public void RemoveDistanceAboveSurfaceAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "DistanceAboveSurface", index);
		}

		public void RemoveDistanceAboveSurface()
		{
			RemoveDistanceAboveSurfaceAt(0);
		}

		public XmlNode AddDistanceAboveSurface(SchemaDouble newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Element, "", "DistanceAboveSurface", newValue.ToString());
			return null;
		}

		public void InsertDistanceAboveSurfaceAt(SchemaDouble newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "DistanceAboveSurface", index, newValue.ToString());
		}

		public void ReplaceDistanceAboveSurfaceAt(SchemaDouble newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "DistanceAboveSurface", index, newValue.ToString());
		}
		#endregion // DistanceAboveSurface accessor methods

		#region DistanceAboveSurface collection
        public DistanceAboveSurfaceCollection	MyDistanceAboveSurfaces = new DistanceAboveSurfaceCollection( );

        public class DistanceAboveSurfaceCollection: IEnumerable
        {
            Type_QuadTileSet parent;
            public Type_QuadTileSet Parent
			{
				set
				{
					parent = value;
				}
			}
			public DistanceAboveSurfaceEnumerator GetEnumerator() 
			{
				return new DistanceAboveSurfaceEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class DistanceAboveSurfaceEnumerator: IEnumerator 
        {
			int nIndex;
			Type_QuadTileSet parent;
			public DistanceAboveSurfaceEnumerator(Type_QuadTileSet par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.DistanceAboveSurfaceCount );
			}
			public SchemaDouble  Current 
			{
				get 
				{
					return(parent.GetDistanceAboveSurfaceAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // DistanceAboveSurface collection

		#region BoundingBox Documentation
		public static string GetBoundingBoxAnnoDocumentation()
		{
			return "";		
		}
		public static string GetBoundingBoxDefault()
		{
			return "";		
		}
		#endregion

		#region BoundingBox accessor methods
		public static int GetBoundingBoxMinCount()
		{
			return 1;
		}

		public static int BoundingBoxMinCount
		{
			get
			{
				return 1;
			}
		}

		public static int GetBoundingBoxMaxCount()
		{
			return 1;
		}

		public static int BoundingBoxMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetBoundingBoxCount()
		{
			return DomChildCount(NodeType.Element, "", "BoundingBox");
		}

		public int BoundingBoxCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "BoundingBox");
			}
		}

		public bool HasBoundingBox()
		{
			return HasDomChild(NodeType.Element, "", "BoundingBox");
		}

		public Type_LatLonBoundingBox NewBoundingBox()
		{
			return new Type_LatLonBoundingBox(domNode.OwnerDocument.CreateElement("BoundingBox", ""));
		}

		public Type_LatLonBoundingBox GetBoundingBoxAt(int index)
		{
			return new Type_LatLonBoundingBox(GetDomChildAt(NodeType.Element, "", "BoundingBox", index));
		}

		public XmlNode GetStartingBoundingBoxCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "BoundingBox" );
		}

		public XmlNode GetAdvancedBoundingBoxCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "BoundingBox", curNode );
		}

		public Type_LatLonBoundingBox GetBoundingBoxValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new Type_LatLonBoundingBox( curNode );
		}


		public Type_LatLonBoundingBox GetBoundingBox()
		{
			return GetBoundingBoxAt(0);
		}

		public Type_LatLonBoundingBox BoundingBox
		{
			get
			{
				return GetBoundingBoxAt(0);
			}
		}

		public void RemoveBoundingBoxAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "BoundingBox", index);
		}

		public void RemoveBoundingBox()
		{
			RemoveBoundingBoxAt(0);
		}

		public XmlNode AddBoundingBox(Type_LatLonBoundingBox newValue)
		{
			return AppendDomElement("", "BoundingBox", newValue);
		}

		public void InsertBoundingBoxAt(Type_LatLonBoundingBox newValue, int index)
		{
			InsertDomElementAt("", "BoundingBox", index, newValue);
		}

		public void ReplaceBoundingBoxAt(Type_LatLonBoundingBox newValue, int index)
		{
			ReplaceDomElementAt("", "BoundingBox", index, newValue);
		}
		#endregion // BoundingBox accessor methods

		#region BoundingBox collection
        public BoundingBoxCollection	MyBoundingBoxs = new BoundingBoxCollection( );

        public class BoundingBoxCollection: IEnumerable
        {
            Type_QuadTileSet parent;
            public Type_QuadTileSet Parent
			{
				set
				{
					parent = value;
				}
			}
			public BoundingBoxEnumerator GetEnumerator() 
			{
				return new BoundingBoxEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class BoundingBoxEnumerator: IEnumerator 
        {
			int nIndex;
			Type_QuadTileSet parent;
			public BoundingBoxEnumerator(Type_QuadTileSet par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.BoundingBoxCount );
			}
			public Type_LatLonBoundingBox  Current 
			{
				get 
				{
					return(parent.GetBoundingBoxAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // BoundingBox collection

		#region Opacity Documentation
		public static string GetOpacityAnnoDocumentation()
		{
			return "";		
		}
		public static string GetOpacityDefault()
		{
			return "";		
		}
		#endregion

		#region Opacity accessor methods
		public static int GetOpacityMinCount()
		{
			return 0;
		}

		public static int OpacityMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetOpacityMaxCount()
		{
			return 1;
		}

		public static int OpacityMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetOpacityCount()
		{
			return DomChildCount(NodeType.Element, "", "Opacity");
		}

		public int OpacityCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Opacity");
			}
		}

		public bool HasOpacity()
		{
			return HasDomChild(NodeType.Element, "", "Opacity");
		}

		public SchemaLong NewOpacity()
		{
			return new SchemaLong();
		}

		public SchemaLong GetOpacityAt(int index)
		{
			return new SchemaLong(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "Opacity", index)));
		}

		public XmlNode GetStartingOpacityCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "Opacity" );
		}

		public XmlNode GetAdvancedOpacityCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "Opacity", curNode );
		}

		public SchemaLong GetOpacityValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaLong( curNode.InnerText );
		}


		public SchemaLong GetOpacity()
		{
			return GetOpacityAt(0);
		}

		public SchemaLong Opacity
		{
			get
			{
				return GetOpacityAt(0);
			}
		}

		public void RemoveOpacityAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Opacity", index);
		}

		public void RemoveOpacity()
		{
			RemoveOpacityAt(0);
		}

		public XmlNode AddOpacity(SchemaLong newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Element, "", "Opacity", newValue.ToString());
			return null;
		}

		public void InsertOpacityAt(SchemaLong newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "Opacity", index, newValue.ToString());
		}

		public void ReplaceOpacityAt(SchemaLong newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "Opacity", index, newValue.ToString());
		}
		#endregion // Opacity accessor methods

		#region Opacity collection
        public OpacityCollection	MyOpacitys = new OpacityCollection( );

        public class OpacityCollection: IEnumerable
        {
            Type_QuadTileSet parent;
            public Type_QuadTileSet Parent
			{
				set
				{
					parent = value;
				}
			}
			public OpacityEnumerator GetEnumerator() 
			{
				return new OpacityEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class OpacityEnumerator: IEnumerator 
        {
			int nIndex;
			Type_QuadTileSet parent;
			public OpacityEnumerator(Type_QuadTileSet par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.OpacityCount );
			}
			public SchemaLong  Current 
			{
				get 
				{
					return(parent.GetOpacityAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // Opacity collection

		#region TerrainMapped Documentation
		public static string GetTerrainMappedAnnoDocumentation()
		{
			return "";		
		}
		public static string GetTerrainMappedDefault()
		{
			return "";		
		}
		#endregion

		#region TerrainMapped accessor methods
		public static int GetTerrainMappedMinCount()
		{
			return 1;
		}

		public static int TerrainMappedMinCount
		{
			get
			{
				return 1;
			}
		}

		public static int GetTerrainMappedMaxCount()
		{
			return 1;
		}

		public static int TerrainMappedMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetTerrainMappedCount()
		{
			return DomChildCount(NodeType.Element, "", "TerrainMapped");
		}

		public int TerrainMappedCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "TerrainMapped");
			}
		}

		public bool HasTerrainMapped()
		{
			return HasDomChild(NodeType.Element, "", "TerrainMapped");
		}

		public SchemaBoolean NewTerrainMapped()
		{
			return new SchemaBoolean();
		}

		public SchemaBoolean GetTerrainMappedAt(int index)
		{
			return new SchemaBoolean(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "TerrainMapped", index)));
		}

		public XmlNode GetStartingTerrainMappedCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "TerrainMapped" );
		}

		public XmlNode GetAdvancedTerrainMappedCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "TerrainMapped", curNode );
		}

		public SchemaBoolean GetTerrainMappedValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaBoolean( curNode.InnerText );
		}


		public SchemaBoolean GetTerrainMapped()
		{
			return GetTerrainMappedAt(0);
		}

		public SchemaBoolean TerrainMapped
		{
			get
			{
				return GetTerrainMappedAt(0);
			}
		}

		public void RemoveTerrainMappedAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "TerrainMapped", index);
		}

		public void RemoveTerrainMapped()
		{
			RemoveTerrainMappedAt(0);
		}

		public XmlNode AddTerrainMapped(SchemaBoolean newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Element, "", "TerrainMapped", newValue.ToString());
			return null;
		}

		public void InsertTerrainMappedAt(SchemaBoolean newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "TerrainMapped", index, newValue.ToString());
		}

		public void ReplaceTerrainMappedAt(SchemaBoolean newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "TerrainMapped", index, newValue.ToString());
		}
		#endregion // TerrainMapped accessor methods

		#region TerrainMapped collection
        public TerrainMappedCollection	MyTerrainMappeds = new TerrainMappedCollection( );

        public class TerrainMappedCollection: IEnumerable
        {
            Type_QuadTileSet parent;
            public Type_QuadTileSet Parent
			{
				set
				{
					parent = value;
				}
			}
			public TerrainMappedEnumerator GetEnumerator() 
			{
				return new TerrainMappedEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class TerrainMappedEnumerator: IEnumerator 
        {
			int nIndex;
			Type_QuadTileSet parent;
			public TerrainMappedEnumerator(Type_QuadTileSet par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.TerrainMappedCount );
			}
			public SchemaBoolean  Current 
			{
				get 
				{
					return(parent.GetTerrainMappedAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // TerrainMapped collection

		#region RenderStruts Documentation
		public static string GetRenderStrutsAnnoDocumentation()
		{
			return "";		
		}
		public static string GetRenderStrutsDefault()
		{
			return "";		
		}
		#endregion

		#region RenderStruts accessor methods
		public static int GetRenderStrutsMinCount()
		{
			return 0;
		}

		public static int RenderStrutsMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetRenderStrutsMaxCount()
		{
			return 1;
		}

		public static int RenderStrutsMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetRenderStrutsCount()
		{
			return DomChildCount(NodeType.Element, "", "RenderStruts");
		}

		public int RenderStrutsCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "RenderStruts");
			}
		}

		public bool HasRenderStruts()
		{
			return HasDomChild(NodeType.Element, "", "RenderStruts");
		}

		public SchemaBoolean NewRenderStruts()
		{
			return new SchemaBoolean();
		}

		public SchemaBoolean GetRenderStrutsAt(int index)
		{
			return new SchemaBoolean(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "RenderStruts", index)));
		}

		public XmlNode GetStartingRenderStrutsCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "RenderStruts" );
		}

		public XmlNode GetAdvancedRenderStrutsCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "RenderStruts", curNode );
		}

		public SchemaBoolean GetRenderStrutsValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaBoolean( curNode.InnerText );
		}


		public SchemaBoolean GetRenderStruts()
		{
			return GetRenderStrutsAt(0);
		}

		public SchemaBoolean RenderStruts
		{
			get
			{
				return GetRenderStrutsAt(0);
			}
		}

		public void RemoveRenderStrutsAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "RenderStruts", index);
		}

		public void RemoveRenderStruts()
		{
			RemoveRenderStrutsAt(0);
		}

		public XmlNode AddRenderStruts(SchemaBoolean newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Element, "", "RenderStruts", newValue.ToString());
			return null;
		}

		public void InsertRenderStrutsAt(SchemaBoolean newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "RenderStruts", index, newValue.ToString());
		}

		public void ReplaceRenderStrutsAt(SchemaBoolean newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "RenderStruts", index, newValue.ToString());
		}
		#endregion // RenderStruts accessor methods

		#region RenderStruts collection
        public RenderStrutsCollection	MyRenderStrutss = new RenderStrutsCollection( );

        public class RenderStrutsCollection: IEnumerable
        {
            Type_QuadTileSet parent;
            public Type_QuadTileSet Parent
			{
				set
				{
					parent = value;
				}
			}
			public RenderStrutsEnumerator GetEnumerator() 
			{
				return new RenderStrutsEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class RenderStrutsEnumerator: IEnumerator 
        {
			int nIndex;
			Type_QuadTileSet parent;
			public RenderStrutsEnumerator(Type_QuadTileSet par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.RenderStrutsCount );
			}
			public SchemaBoolean  Current 
			{
				get 
				{
					return(parent.GetRenderStrutsAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // RenderStruts collection

		#region ImageAccessor Documentation
		public static string GetImageAccessorAnnoDocumentation()
		{
			return "";		
		}
		public static string GetImageAccessorDefault()
		{
			return "";		
		}
		#endregion

		#region ImageAccessor accessor methods
		public static int GetImageAccessorMinCount()
		{
			return 0;
		}

		public static int ImageAccessorMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetImageAccessorMaxCount()
		{
			return 1;
		}

		public static int ImageAccessorMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetImageAccessorCount()
		{
			return DomChildCount(NodeType.Element, "", "ImageAccessor");
		}

		public int ImageAccessorCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "ImageAccessor");
			}
		}

		public bool HasImageAccessor()
		{
			return HasDomChild(NodeType.Element, "", "ImageAccessor");
		}

		public Type_ImageAccessor NewImageAccessor()
		{
			return new Type_ImageAccessor(domNode.OwnerDocument.CreateElement("ImageAccessor", ""));
		}

		public Type_ImageAccessor GetImageAccessorAt(int index)
		{
			return new Type_ImageAccessor(GetDomChildAt(NodeType.Element, "", "ImageAccessor", index));
		}

		public XmlNode GetStartingImageAccessorCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "ImageAccessor" );
		}

		public XmlNode GetAdvancedImageAccessorCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "ImageAccessor", curNode );
		}

		public Type_ImageAccessor GetImageAccessorValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new Type_ImageAccessor( curNode );
		}


		public Type_ImageAccessor GetImageAccessor()
		{
			return GetImageAccessorAt(0);
		}

		public Type_ImageAccessor ImageAccessor
		{
			get
			{
				return GetImageAccessorAt(0);
			}
		}

		public void RemoveImageAccessorAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "ImageAccessor", index);
		}

		public void RemoveImageAccessor()
		{
			RemoveImageAccessorAt(0);
		}

		public XmlNode AddImageAccessor(Type_ImageAccessor newValue)
		{
			return AppendDomElement("", "ImageAccessor", newValue);
		}

		public void InsertImageAccessorAt(Type_ImageAccessor newValue, int index)
		{
			InsertDomElementAt("", "ImageAccessor", index, newValue);
		}

		public void ReplaceImageAccessorAt(Type_ImageAccessor newValue, int index)
		{
			ReplaceDomElementAt("", "ImageAccessor", index, newValue);
		}
		#endregion // ImageAccessor accessor methods

		#region ImageAccessor collection
        public ImageAccessorCollection	MyImageAccessors = new ImageAccessorCollection( );

        public class ImageAccessorCollection: IEnumerable
        {
            Type_QuadTileSet parent;
            public Type_QuadTileSet Parent
			{
				set
				{
					parent = value;
				}
			}
			public ImageAccessorEnumerator GetEnumerator() 
			{
				return new ImageAccessorEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class ImageAccessorEnumerator: IEnumerator 
        {
			int nIndex;
			Type_QuadTileSet parent;
			public ImageAccessorEnumerator(Type_QuadTileSet par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.ImageAccessorCount );
			}
			public Type_ImageAccessor  Current 
			{
				get 
				{
					return(parent.GetImageAccessorAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // ImageAccessor collection

		#region ImageAccessorList Documentation
		public static string GetImageAccessorListAnnoDocumentation()
		{
			return "";		
		}
		public static string GetImageAccessorListDefault()
		{
			return "";		
		}
		#endregion

		#region ImageAccessorList accessor methods
		public static int GetImageAccessorListMinCount()
		{
			return 0;
		}

		public static int ImageAccessorListMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetImageAccessorListMaxCount()
		{
			return 1;
		}

		public static int ImageAccessorListMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetImageAccessorListCount()
		{
			return DomChildCount(NodeType.Element, "", "ImageAccessorList");
		}

		public int ImageAccessorListCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "ImageAccessorList");
			}
		}

		public bool HasImageAccessorList()
		{
			return HasDomChild(NodeType.Element, "", "ImageAccessorList");
		}

		public Type_ImageAccessorList NewImageAccessorList()
		{
			return new Type_ImageAccessorList(domNode.OwnerDocument.CreateElement("ImageAccessorList", ""));
		}

		public Type_ImageAccessorList GetImageAccessorListAt(int index)
		{
			return new Type_ImageAccessorList(GetDomChildAt(NodeType.Element, "", "ImageAccessorList", index));
		}

		public XmlNode GetStartingImageAccessorListCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "ImageAccessorList" );
		}

		public XmlNode GetAdvancedImageAccessorListCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "ImageAccessorList", curNode );
		}

		public Type_ImageAccessorList GetImageAccessorListValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new Type_ImageAccessorList( curNode );
		}


		public Type_ImageAccessorList GetImageAccessorList()
		{
			return GetImageAccessorListAt(0);
		}

		public Type_ImageAccessorList ImageAccessorList
		{
			get
			{
				return GetImageAccessorListAt(0);
			}
		}

		public void RemoveImageAccessorListAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "ImageAccessorList", index);
		}

		public void RemoveImageAccessorList()
		{
			RemoveImageAccessorListAt(0);
		}

		public XmlNode AddImageAccessorList(Type_ImageAccessorList newValue)
		{
			return AppendDomElement("", "ImageAccessorList", newValue);
		}

		public void InsertImageAccessorListAt(Type_ImageAccessorList newValue, int index)
		{
			InsertDomElementAt("", "ImageAccessorList", index, newValue);
		}

		public void ReplaceImageAccessorListAt(Type_ImageAccessorList newValue, int index)
		{
			ReplaceDomElementAt("", "ImageAccessorList", index, newValue);
		}
		#endregion // ImageAccessorList accessor methods

		#region ImageAccessorList collection
        public ImageAccessorListCollection	MyImageAccessorLists = new ImageAccessorListCollection( );

        public class ImageAccessorListCollection: IEnumerable
        {
            Type_QuadTileSet parent;
            public Type_QuadTileSet Parent
			{
				set
				{
					parent = value;
				}
			}
			public ImageAccessorListEnumerator GetEnumerator() 
			{
				return new ImageAccessorListEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class ImageAccessorListEnumerator: IEnumerator 
        {
			int nIndex;
			Type_QuadTileSet parent;
			public ImageAccessorListEnumerator(Type_QuadTileSet par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.ImageAccessorListCount );
			}
			public Type_ImageAccessorList  Current 
			{
				get 
				{
					return(parent.GetImageAccessorListAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // ImageAccessorList collection

		#region TransparentMinValue Documentation
		public static string GetTransparentMinValueAnnoDocumentation()
		{
			return "";		
		}
		public static string GetTransparentMinValueDefault()
		{
			return "";		
		}
		#endregion

		#region TransparentMinValue accessor methods
		public static int GetTransparentMinValueMinCount()
		{
			return 0;
		}

		public static int TransparentMinValueMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetTransparentMinValueMaxCount()
		{
			return 1;
		}

		public static int TransparentMinValueMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetTransparentMinValueCount()
		{
			return DomChildCount(NodeType.Element, "", "TransparentMinValue");
		}

		public int TransparentMinValueCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "TransparentMinValue");
			}
		}

		public bool HasTransparentMinValue()
		{
			return HasDomChild(NodeType.Element, "", "TransparentMinValue");
		}

		public SchemaDouble NewTransparentMinValue()
		{
			return new SchemaDouble();
		}

		public SchemaDouble GetTransparentMinValueAt(int index)
		{
			return new SchemaDouble(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "TransparentMinValue", index)));
		}

		public XmlNode GetStartingTransparentMinValueCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "TransparentMinValue" );
		}

		public XmlNode GetAdvancedTransparentMinValueCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "TransparentMinValue", curNode );
		}

		public SchemaDouble GetTransparentMinValueValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaDouble( curNode.InnerText );
		}


		public SchemaDouble GetTransparentMinValue()
		{
			return GetTransparentMinValueAt(0);
		}

		public SchemaDouble TransparentMinValue
		{
			get
			{
				return GetTransparentMinValueAt(0);
			}
		}

		public void RemoveTransparentMinValueAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "TransparentMinValue", index);
		}

		public void RemoveTransparentMinValue()
		{
			RemoveTransparentMinValueAt(0);
		}

		public XmlNode AddTransparentMinValue(SchemaDouble newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Element, "", "TransparentMinValue", newValue.ToString());
			return null;
		}

		public void InsertTransparentMinValueAt(SchemaDouble newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "TransparentMinValue", index, newValue.ToString());
		}

		public void ReplaceTransparentMinValueAt(SchemaDouble newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "TransparentMinValue", index, newValue.ToString());
		}
		#endregion // TransparentMinValue accessor methods

		#region TransparentMinValue collection
        public TransparentMinValueCollection	MyTransparentMinValues = new TransparentMinValueCollection( );

        public class TransparentMinValueCollection: IEnumerable
        {
            Type_QuadTileSet parent;
            public Type_QuadTileSet Parent
			{
				set
				{
					parent = value;
				}
			}
			public TransparentMinValueEnumerator GetEnumerator() 
			{
				return new TransparentMinValueEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class TransparentMinValueEnumerator: IEnumerator 
        {
			int nIndex;
			Type_QuadTileSet parent;
			public TransparentMinValueEnumerator(Type_QuadTileSet par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.TransparentMinValueCount );
			}
			public SchemaDouble  Current 
			{
				get 
				{
					return(parent.GetTransparentMinValueAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // TransparentMinValue collection

		#region TransparentMaxValue Documentation
		public static string GetTransparentMaxValueAnnoDocumentation()
		{
			return "";		
		}
		public static string GetTransparentMaxValueDefault()
		{
			return "";		
		}
		#endregion

		#region TransparentMaxValue accessor methods
		public static int GetTransparentMaxValueMinCount()
		{
			return 0;
		}

		public static int TransparentMaxValueMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetTransparentMaxValueMaxCount()
		{
			return 1;
		}

		public static int TransparentMaxValueMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetTransparentMaxValueCount()
		{
			return DomChildCount(NodeType.Element, "", "TransparentMaxValue");
		}

		public int TransparentMaxValueCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "TransparentMaxValue");
			}
		}

		public bool HasTransparentMaxValue()
		{
			return HasDomChild(NodeType.Element, "", "TransparentMaxValue");
		}

		public SchemaDouble NewTransparentMaxValue()
		{
			return new SchemaDouble();
		}

		public SchemaDouble GetTransparentMaxValueAt(int index)
		{
			return new SchemaDouble(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "TransparentMaxValue", index)));
		}

		public XmlNode GetStartingTransparentMaxValueCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "TransparentMaxValue" );
		}

		public XmlNode GetAdvancedTransparentMaxValueCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "TransparentMaxValue", curNode );
		}

		public SchemaDouble GetTransparentMaxValueValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaDouble( curNode.InnerText );
		}


		public SchemaDouble GetTransparentMaxValue()
		{
			return GetTransparentMaxValueAt(0);
		}

		public SchemaDouble TransparentMaxValue
		{
			get
			{
				return GetTransparentMaxValueAt(0);
			}
		}

		public void RemoveTransparentMaxValueAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "TransparentMaxValue", index);
		}

		public void RemoveTransparentMaxValue()
		{
			RemoveTransparentMaxValueAt(0);
		}

		public XmlNode AddTransparentMaxValue(SchemaDouble newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Element, "", "TransparentMaxValue", newValue.ToString());
			return null;
		}

		public void InsertTransparentMaxValueAt(SchemaDouble newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "TransparentMaxValue", index, newValue.ToString());
		}

		public void ReplaceTransparentMaxValueAt(SchemaDouble newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "TransparentMaxValue", index, newValue.ToString());
		}
		#endregion // TransparentMaxValue accessor methods

		#region TransparentMaxValue collection
        public TransparentMaxValueCollection	MyTransparentMaxValues = new TransparentMaxValueCollection( );

        public class TransparentMaxValueCollection: IEnumerable
        {
            Type_QuadTileSet parent;
            public Type_QuadTileSet Parent
			{
				set
				{
					parent = value;
				}
			}
			public TransparentMaxValueEnumerator GetEnumerator() 
			{
				return new TransparentMaxValueEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class TransparentMaxValueEnumerator: IEnumerator 
        {
			int nIndex;
			Type_QuadTileSet parent;
			public TransparentMaxValueEnumerator(Type_QuadTileSet par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.TransparentMaxValueCount );
			}
			public SchemaDouble  Current 
			{
				get 
				{
					return(parent.GetTransparentMaxValueAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // TransparentMaxValue collection

		#region TileDrawDistanceFactor Documentation
		public static string GetTileDrawDistanceFactorAnnoDocumentation()
		{
			return "";		
		}
		public static string GetTileDrawDistanceFactorDefault()
		{
			return "";		
		}
		#endregion

		#region TileDrawDistanceFactor accessor methods
		public static int GetTileDrawDistanceFactorMinCount()
		{
			return 0;
		}

		public static int TileDrawDistanceFactorMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetTileDrawDistanceFactorMaxCount()
		{
			return 1;
		}

		public static int TileDrawDistanceFactorMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetTileDrawDistanceFactorCount()
		{
			return DomChildCount(NodeType.Element, "", "TileDrawDistanceFactor");
		}

		public int TileDrawDistanceFactorCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "TileDrawDistanceFactor");
			}
		}

		public bool HasTileDrawDistanceFactor()
		{
			return HasDomChild(NodeType.Element, "", "TileDrawDistanceFactor");
		}

		public SchemaDouble NewTileDrawDistanceFactor()
		{
			return new SchemaDouble();
		}

		public SchemaDouble GetTileDrawDistanceFactorAt(int index)
		{
			return new SchemaDouble(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "TileDrawDistanceFactor", index)));
		}

		public XmlNode GetStartingTileDrawDistanceFactorCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "TileDrawDistanceFactor" );
		}

		public XmlNode GetAdvancedTileDrawDistanceFactorCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "TileDrawDistanceFactor", curNode );
		}

		public SchemaDouble GetTileDrawDistanceFactorValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaDouble( curNode.InnerText );
		}


		public SchemaDouble GetTileDrawDistanceFactor()
		{
			return GetTileDrawDistanceFactorAt(0);
		}

		public SchemaDouble TileDrawDistanceFactor
		{
			get
			{
				return GetTileDrawDistanceFactorAt(0);
			}
		}

		public void RemoveTileDrawDistanceFactorAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "TileDrawDistanceFactor", index);
		}

		public void RemoveTileDrawDistanceFactor()
		{
			RemoveTileDrawDistanceFactorAt(0);
		}

		public XmlNode AddTileDrawDistanceFactor(SchemaDouble newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Element, "", "TileDrawDistanceFactor", newValue.ToString());
			return null;
		}

		public void InsertTileDrawDistanceFactorAt(SchemaDouble newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "TileDrawDistanceFactor", index, newValue.ToString());
		}

		public void ReplaceTileDrawDistanceFactorAt(SchemaDouble newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "TileDrawDistanceFactor", index, newValue.ToString());
		}
		#endregion // TileDrawDistanceFactor accessor methods

		#region TileDrawDistanceFactor collection
        public TileDrawDistanceFactorCollection	MyTileDrawDistanceFactors = new TileDrawDistanceFactorCollection( );

        public class TileDrawDistanceFactorCollection: IEnumerable
        {
            Type_QuadTileSet parent;
            public Type_QuadTileSet Parent
			{
				set
				{
					parent = value;
				}
			}
			public TileDrawDistanceFactorEnumerator GetEnumerator() 
			{
				return new TileDrawDistanceFactorEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class TileDrawDistanceFactorEnumerator: IEnumerator 
        {
			int nIndex;
			Type_QuadTileSet parent;
			public TileDrawDistanceFactorEnumerator(Type_QuadTileSet par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.TileDrawDistanceFactorCount );
			}
			public SchemaDouble  Current 
			{
				get 
				{
					return(parent.GetTileDrawDistanceFactorAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // TileDrawDistanceFactor collection

		#region TileSpreadFactor Documentation
		public static string GetTileSpreadFactorAnnoDocumentation()
		{
			return "";		
		}
		public static string GetTileSpreadFactorDefault()
		{
			return "";		
		}
		#endregion

		#region TileSpreadFactor accessor methods
		public static int GetTileSpreadFactorMinCount()
		{
			return 0;
		}

		public static int TileSpreadFactorMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetTileSpreadFactorMaxCount()
		{
			return 1;
		}

		public static int TileSpreadFactorMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetTileSpreadFactorCount()
		{
			return DomChildCount(NodeType.Element, "", "TileSpreadFactor");
		}

		public int TileSpreadFactorCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "TileSpreadFactor");
			}
		}

		public bool HasTileSpreadFactor()
		{
			return HasDomChild(NodeType.Element, "", "TileSpreadFactor");
		}

		public SchemaDouble NewTileSpreadFactor()
		{
			return new SchemaDouble();
		}

		public SchemaDouble GetTileSpreadFactorAt(int index)
		{
			return new SchemaDouble(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "TileSpreadFactor", index)));
		}

		public XmlNode GetStartingTileSpreadFactorCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "TileSpreadFactor" );
		}

		public XmlNode GetAdvancedTileSpreadFactorCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "TileSpreadFactor", curNode );
		}

		public SchemaDouble GetTileSpreadFactorValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaDouble( curNode.InnerText );
		}


		public SchemaDouble GetTileSpreadFactor()
		{
			return GetTileSpreadFactorAt(0);
		}

		public SchemaDouble TileSpreadFactor
		{
			get
			{
				return GetTileSpreadFactorAt(0);
			}
		}

		public void RemoveTileSpreadFactorAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "TileSpreadFactor", index);
		}

		public void RemoveTileSpreadFactor()
		{
			RemoveTileSpreadFactorAt(0);
		}

		public XmlNode AddTileSpreadFactor(SchemaDouble newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Element, "", "TileSpreadFactor", newValue.ToString());
			return null;
		}

		public void InsertTileSpreadFactorAt(SchemaDouble newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "TileSpreadFactor", index, newValue.ToString());
		}

		public void ReplaceTileSpreadFactorAt(SchemaDouble newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "TileSpreadFactor", index, newValue.ToString());
		}
		#endregion // TileSpreadFactor accessor methods

		#region TileSpreadFactor collection
        public TileSpreadFactorCollection	MyTileSpreadFactors = new TileSpreadFactorCollection( );

        public class TileSpreadFactorCollection: IEnumerable
        {
            Type_QuadTileSet parent;
            public Type_QuadTileSet Parent
			{
				set
				{
					parent = value;
				}
			}
			public TileSpreadFactorEnumerator GetEnumerator() 
			{
				return new TileSpreadFactorEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class TileSpreadFactorEnumerator: IEnumerator 
        {
			int nIndex;
			Type_QuadTileSet parent;
			public TileSpreadFactorEnumerator(Type_QuadTileSet par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.TileSpreadFactorCount );
			}
			public SchemaDouble  Current 
			{
				get 
				{
					return(parent.GetTileSpreadFactorAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // TileSpreadFactor collection

		#region TransparentColor Documentation
		public static string GetTransparentColorAnnoDocumentation()
		{
			return "";		
		}
		public static string GetTransparentColorDefault()
		{
			return "";		
		}
		#endregion

		#region TransparentColor accessor methods
		public static int GetTransparentColorMinCount()
		{
			return 0;
		}

		public static int TransparentColorMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetTransparentColorMaxCount()
		{
			return 1;
		}

		public static int TransparentColorMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetTransparentColorCount()
		{
			return DomChildCount(NodeType.Element, "", "TransparentColor");
		}

		public int TransparentColorCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "TransparentColor");
			}
		}

		public bool HasTransparentColor()
		{
			return HasDomChild(NodeType.Element, "", "TransparentColor");
		}

		public Type_RGBColor NewTransparentColor()
		{
			return new Type_RGBColor(domNode.OwnerDocument.CreateElement("TransparentColor", ""));
		}

		public Type_RGBColor GetTransparentColorAt(int index)
		{
			return new Type_RGBColor(GetDomChildAt(NodeType.Element, "", "TransparentColor", index));
		}

		public XmlNode GetStartingTransparentColorCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "TransparentColor" );
		}

		public XmlNode GetAdvancedTransparentColorCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "TransparentColor", curNode );
		}

		public Type_RGBColor GetTransparentColorValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new Type_RGBColor( curNode );
		}


		public Type_RGBColor GetTransparentColor()
		{
			return GetTransparentColorAt(0);
		}

		public Type_RGBColor TransparentColor
		{
			get
			{
				return GetTransparentColorAt(0);
			}
		}

		public void RemoveTransparentColorAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "TransparentColor", index);
		}

		public void RemoveTransparentColor()
		{
			RemoveTransparentColorAt(0);
		}

		public XmlNode AddTransparentColor(Type_RGBColor newValue)
		{
			return AppendDomElement("", "TransparentColor", newValue);
		}

		public void InsertTransparentColorAt(Type_RGBColor newValue, int index)
		{
			InsertDomElementAt("", "TransparentColor", index, newValue);
		}

		public void ReplaceTransparentColorAt(Type_RGBColor newValue, int index)
		{
			ReplaceDomElementAt("", "TransparentColor", index, newValue);
		}
		#endregion // TransparentColor accessor methods

		#region TransparentColor collection
        public TransparentColorCollection	MyTransparentColors = new TransparentColorCollection( );

        public class TransparentColorCollection: IEnumerable
        {
            Type_QuadTileSet parent;
            public Type_QuadTileSet Parent
			{
				set
				{
					parent = value;
				}
			}
			public TransparentColorEnumerator GetEnumerator() 
			{
				return new TransparentColorEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class TransparentColorEnumerator: IEnumerator 
        {
			int nIndex;
			Type_QuadTileSet parent;
			public TransparentColorEnumerator(Type_QuadTileSet par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.TransparentColorCount );
			}
			public Type_RGBColor  Current 
			{
				get 
				{
					return(parent.GetTransparentColorAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // TransparentColor collection

		#region ExtendedInformation Documentation
		public static string GetExtendedInformationAnnoDocumentation()
		{
			return "";		
		}
		public static string GetExtendedInformationDefault()
		{
			return "";		
		}
		#endregion

		#region ExtendedInformation accessor methods
		public static int GetExtendedInformationMinCount()
		{
			return 0;
		}

		public static int ExtendedInformationMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetExtendedInformationMaxCount()
		{
			return 1;
		}

		public static int ExtendedInformationMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetExtendedInformationCount()
		{
			return DomChildCount(NodeType.Element, "", "ExtendedInformation");
		}

		public int ExtendedInformationCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "ExtendedInformation");
			}
		}

		public bool HasExtendedInformation()
		{
			return HasDomChild(NodeType.Element, "", "ExtendedInformation");
		}

		public Type_ExtendedInformation NewExtendedInformation()
		{
			return new Type_ExtendedInformation(domNode.OwnerDocument.CreateElement("ExtendedInformation", ""));
		}

		public Type_ExtendedInformation GetExtendedInformationAt(int index)
		{
			return new Type_ExtendedInformation(GetDomChildAt(NodeType.Element, "", "ExtendedInformation", index));
		}

		public XmlNode GetStartingExtendedInformationCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "ExtendedInformation" );
		}

		public XmlNode GetAdvancedExtendedInformationCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "ExtendedInformation", curNode );
		}

		public Type_ExtendedInformation GetExtendedInformationValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new Type_ExtendedInformation( curNode );
		}


		public Type_ExtendedInformation GetExtendedInformation()
		{
			return GetExtendedInformationAt(0);
		}

		public Type_ExtendedInformation ExtendedInformation
		{
			get
			{
				return GetExtendedInformationAt(0);
			}
		}

		public void RemoveExtendedInformationAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "ExtendedInformation", index);
		}

		public void RemoveExtendedInformation()
		{
			RemoveExtendedInformationAt(0);
		}

		public XmlNode AddExtendedInformation(Type_ExtendedInformation newValue)
		{
			return AppendDomElement("", "ExtendedInformation", newValue);
		}

		public void InsertExtendedInformationAt(Type_ExtendedInformation newValue, int index)
		{
			InsertDomElementAt("", "ExtendedInformation", index, newValue);
		}

		public void ReplaceExtendedInformationAt(Type_ExtendedInformation newValue, int index)
		{
			ReplaceDomElementAt("", "ExtendedInformation", index, newValue);
		}
		#endregion // ExtendedInformation accessor methods

		#region ExtendedInformation collection
        public ExtendedInformationCollection	MyExtendedInformations = new ExtendedInformationCollection( );

        public class ExtendedInformationCollection: IEnumerable
        {
            Type_QuadTileSet parent;
            public Type_QuadTileSet Parent
			{
				set
				{
					parent = value;
				}
			}
			public ExtendedInformationEnumerator GetEnumerator() 
			{
				return new ExtendedInformationEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class ExtendedInformationEnumerator: IEnumerator 
        {
			int nIndex;
			Type_QuadTileSet parent;
			public ExtendedInformationEnumerator(Type_QuadTileSet par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.ExtendedInformationCount );
			}
			public Type_ExtendedInformation  Current 
			{
				get 
				{
					return(parent.GetExtendedInformationAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // ExtendedInformation collection

        private void SetCollectionParents()
        {
            MyShowAtStartups.Parent = this; 
            MyNames.Parent = this; 
            MyDescriptions.Parent = this; 
            MyEffects.Parent = this; 
            MyDistanceAboveSurfaces.Parent = this; 
            MyBoundingBoxs.Parent = this; 
            MyOpacitys.Parent = this; 
            MyTerrainMappeds.Parent = this; 
            MyRenderStrutss.Parent = this; 
            MyImageAccessors.Parent = this; 
            MyImageAccessorLists.Parent = this; 
            MyTransparentMinValues.Parent = this; 
            MyTransparentMaxValues.Parent = this; 
            MyTileDrawDistanceFactors.Parent = this; 
            MyTileSpreadFactors.Parent = this; 
            MyTransparentColors.Parent = this; 
            MyExtendedInformations.Parent = this; 
	}
}
}
