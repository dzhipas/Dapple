//
// Type_WMSAccessor.cs
//
// This file was generated by XMLSpy 2007r3 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//


using System;
using System.Collections;
using System.Xml;
using Altova.Types;

namespace LayerSet
{
	public class Type_WMSAccessor : Altova.Xml.Node
	{
		#region Documentation
		public static string GetAnnoDocumentation() { return ""; }
		#endregion

		#region Forward constructors

		public Type_WMSAccessor() : base() { SetCollectionParents(); }

		public Type_WMSAccessor(XmlDocument doc) : base(doc) { SetCollectionParents(); }
		public Type_WMSAccessor(XmlNode node) : base(node) { SetCollectionParents(); }
		public Type_WMSAccessor(Altova.Xml.Node node) : base(node) { SetCollectionParents(); }
		public Type_WMSAccessor(Altova.Xml.Document doc, string namespaceURI, string prefix, string name) : base(doc, namespaceURI, prefix, name) { SetCollectionParents(); }
		#endregion // Forward constructors

		public override void AdjustPrefix()
		{

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "Username" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "Username", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "Password" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "Password", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "ServerGetMapUrl" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "ServerGetMapUrl", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "ServiceName" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "ServiceName", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "Version" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "Version", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "ImageFormat" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "ImageFormat", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "WMSLayerName" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "WMSLayerName", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "WMSLayerStyle" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "WMSLayerStyle", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "UseTransparency" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "UseTransparency", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "Opacity" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "Opacity", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "CacheExpirationTime" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "CacheExpirationTime", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
				new Type_SimpleTimeSpan(DOMNode).AdjustPrefix();
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "BoundingBoxOverlap" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "BoundingBoxOverlap", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "ServerLogoFilePath" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "ServerLogoFilePath", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}
		}

		public void SetXsiType()
		{
 			XmlElement el = (XmlElement) domNode;
			el.SetAttribute("type", "http://www.w3.org/2001/XMLSchema-instance", "Type_WMSAccessor");
		}


		#region Username Documentation
		public static string GetUsernameAnnoDocumentation()
		{
			return "";		
		}
		public static string GetUsernameDefault()
		{
			return "";		
		}
		#endregion

		#region Username accessor methods
		public static int GetUsernameMinCount()
		{
			return 0;
		}

		public static int UsernameMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetUsernameMaxCount()
		{
			return 1;
		}

		public static int UsernameMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetUsernameCount()
		{
			return DomChildCount(NodeType.Element, "", "Username");
		}

		public int UsernameCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Username");
			}
		}

		public bool HasUsername()
		{
			return HasDomChild(NodeType.Element, "", "Username");
		}

		public SchemaString NewUsername()
		{
			return new SchemaString();
		}

		public SchemaString GetUsernameAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "Username", index)));
		}

		public XmlNode GetStartingUsernameCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "Username" );
		}

		public XmlNode GetAdvancedUsernameCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "Username", curNode );
		}

		public SchemaString GetUsernameValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.InnerText );
		}


		public SchemaString GetUsername()
		{
			return GetUsernameAt(0);
		}

		public SchemaString Username
		{
			get
			{
				return GetUsernameAt(0);
			}
		}

		public void RemoveUsernameAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Username", index);
		}

		public void RemoveUsername()
		{
			RemoveUsernameAt(0);
		}

		public XmlNode AddUsername(SchemaString newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Element, "", "Username", newValue.ToString());
			return null;
		}

		public void InsertUsernameAt(SchemaString newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "Username", index, newValue.ToString());
		}

		public void ReplaceUsernameAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "Username", index, newValue.ToString());
		}
		#endregion // Username accessor methods

		#region Username collection
        public UsernameCollection	MyUsernames = new UsernameCollection( );

        public class UsernameCollection: IEnumerable
        {
            Type_WMSAccessor parent;
            public Type_WMSAccessor Parent
			{
				set
				{
					parent = value;
				}
			}
			public UsernameEnumerator GetEnumerator() 
			{
				return new UsernameEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class UsernameEnumerator: IEnumerator 
        {
			int nIndex;
			Type_WMSAccessor parent;
			public UsernameEnumerator(Type_WMSAccessor par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.UsernameCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetUsernameAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // Username collection

		#region Password Documentation
		public static string GetPasswordAnnoDocumentation()
		{
			return "";		
		}
		public static string GetPasswordDefault()
		{
			return "";		
		}
		#endregion

		#region Password accessor methods
		public static int GetPasswordMinCount()
		{
			return 0;
		}

		public static int PasswordMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetPasswordMaxCount()
		{
			return 1;
		}

		public static int PasswordMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetPasswordCount()
		{
			return DomChildCount(NodeType.Element, "", "Password");
		}

		public int PasswordCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Password");
			}
		}

		public bool HasPassword()
		{
			return HasDomChild(NodeType.Element, "", "Password");
		}

		public SchemaString NewPassword()
		{
			return new SchemaString();
		}

		public SchemaString GetPasswordAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "Password", index)));
		}

		public XmlNode GetStartingPasswordCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "Password" );
		}

		public XmlNode GetAdvancedPasswordCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "Password", curNode );
		}

		public SchemaString GetPasswordValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.InnerText );
		}


		public SchemaString GetPassword()
		{
			return GetPasswordAt(0);
		}

		public SchemaString Password
		{
			get
			{
				return GetPasswordAt(0);
			}
		}

		public void RemovePasswordAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Password", index);
		}

		public void RemovePassword()
		{
			RemovePasswordAt(0);
		}

		public XmlNode AddPassword(SchemaString newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Element, "", "Password", newValue.ToString());
			return null;
		}

		public void InsertPasswordAt(SchemaString newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "Password", index, newValue.ToString());
		}

		public void ReplacePasswordAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "Password", index, newValue.ToString());
		}
		#endregion // Password accessor methods

		#region Password collection
        public PasswordCollection	MyPasswords = new PasswordCollection( );

        public class PasswordCollection: IEnumerable
        {
            Type_WMSAccessor parent;
            public Type_WMSAccessor Parent
			{
				set
				{
					parent = value;
				}
			}
			public PasswordEnumerator GetEnumerator() 
			{
				return new PasswordEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class PasswordEnumerator: IEnumerator 
        {
			int nIndex;
			Type_WMSAccessor parent;
			public PasswordEnumerator(Type_WMSAccessor par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.PasswordCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetPasswordAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // Password collection

		#region ServerGetMapUrl Documentation
		public static string GetServerGetMapUrlAnnoDocumentation()
		{
			return "";		
		}
		public static string GetServerGetMapUrlDefault()
		{
			return "";		
		}
		#endregion

		#region ServerGetMapUrl accessor methods
		public static int GetServerGetMapUrlMinCount()
		{
			return 1;
		}

		public static int ServerGetMapUrlMinCount
		{
			get
			{
				return 1;
			}
		}

		public static int GetServerGetMapUrlMaxCount()
		{
			return 1;
		}

		public static int ServerGetMapUrlMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetServerGetMapUrlCount()
		{
			return DomChildCount(NodeType.Element, "", "ServerGetMapUrl");
		}

		public int ServerGetMapUrlCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "ServerGetMapUrl");
			}
		}

		public bool HasServerGetMapUrl()
		{
			return HasDomChild(NodeType.Element, "", "ServerGetMapUrl");
		}

		public SchemaString NewServerGetMapUrl()
		{
			return new SchemaString();
		}

		public SchemaString GetServerGetMapUrlAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "ServerGetMapUrl", index)));
		}

		public XmlNode GetStartingServerGetMapUrlCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "ServerGetMapUrl" );
		}

		public XmlNode GetAdvancedServerGetMapUrlCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "ServerGetMapUrl", curNode );
		}

		public SchemaString GetServerGetMapUrlValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.InnerText );
		}


		public SchemaString GetServerGetMapUrl()
		{
			return GetServerGetMapUrlAt(0);
		}

		public SchemaString ServerGetMapUrl
		{
			get
			{
				return GetServerGetMapUrlAt(0);
			}
		}

		public void RemoveServerGetMapUrlAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "ServerGetMapUrl", index);
		}

		public void RemoveServerGetMapUrl()
		{
			RemoveServerGetMapUrlAt(0);
		}

		public XmlNode AddServerGetMapUrl(SchemaString newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Element, "", "ServerGetMapUrl", newValue.ToString());
			return null;
		}

		public void InsertServerGetMapUrlAt(SchemaString newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "ServerGetMapUrl", index, newValue.ToString());
		}

		public void ReplaceServerGetMapUrlAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "ServerGetMapUrl", index, newValue.ToString());
		}
		#endregion // ServerGetMapUrl accessor methods

		#region ServerGetMapUrl collection
        public ServerGetMapUrlCollection	MyServerGetMapUrls = new ServerGetMapUrlCollection( );

        public class ServerGetMapUrlCollection: IEnumerable
        {
            Type_WMSAccessor parent;
            public Type_WMSAccessor Parent
			{
				set
				{
					parent = value;
				}
			}
			public ServerGetMapUrlEnumerator GetEnumerator() 
			{
				return new ServerGetMapUrlEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class ServerGetMapUrlEnumerator: IEnumerator 
        {
			int nIndex;
			Type_WMSAccessor parent;
			public ServerGetMapUrlEnumerator(Type_WMSAccessor par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.ServerGetMapUrlCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetServerGetMapUrlAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // ServerGetMapUrl collection

		#region ServiceName Documentation
		public static string GetServiceNameAnnoDocumentation()
		{
			return "";		
		}
		public static string GetServiceNameDefault()
		{
			return "";		
		}
		#endregion

		#region ServiceName accessor methods
		public static int GetServiceNameMinCount()
		{
			return 0;
		}

		public static int ServiceNameMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetServiceNameMaxCount()
		{
			return 1;
		}

		public static int ServiceNameMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetServiceNameCount()
		{
			return DomChildCount(NodeType.Element, "", "ServiceName");
		}

		public int ServiceNameCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "ServiceName");
			}
		}

		public bool HasServiceName()
		{
			return HasDomChild(NodeType.Element, "", "ServiceName");
		}

		public SchemaString NewServiceName()
		{
			return new SchemaString();
		}

		public SchemaString GetServiceNameAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "ServiceName", index)));
		}

		public XmlNode GetStartingServiceNameCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "ServiceName" );
		}

		public XmlNode GetAdvancedServiceNameCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "ServiceName", curNode );
		}

		public SchemaString GetServiceNameValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.InnerText );
		}


		public SchemaString GetServiceName()
		{
			return GetServiceNameAt(0);
		}

		public SchemaString ServiceName
		{
			get
			{
				return GetServiceNameAt(0);
			}
		}

		public void RemoveServiceNameAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "ServiceName", index);
		}

		public void RemoveServiceName()
		{
			RemoveServiceNameAt(0);
		}

		public XmlNode AddServiceName(SchemaString newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Element, "", "ServiceName", newValue.ToString());
			return null;
		}

		public void InsertServiceNameAt(SchemaString newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "ServiceName", index, newValue.ToString());
		}

		public void ReplaceServiceNameAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "ServiceName", index, newValue.ToString());
		}
		#endregion // ServiceName accessor methods

		#region ServiceName collection
        public ServiceNameCollection	MyServiceNames = new ServiceNameCollection( );

        public class ServiceNameCollection: IEnumerable
        {
            Type_WMSAccessor parent;
            public Type_WMSAccessor Parent
			{
				set
				{
					parent = value;
				}
			}
			public ServiceNameEnumerator GetEnumerator() 
			{
				return new ServiceNameEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class ServiceNameEnumerator: IEnumerator 
        {
			int nIndex;
			Type_WMSAccessor parent;
			public ServiceNameEnumerator(Type_WMSAccessor par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.ServiceNameCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetServiceNameAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // ServiceName collection

		#region Version Documentation
		public static string GetVersionAnnoDocumentation()
		{
			return "";		
		}
		public static string GetVersionDefault()
		{
			return "";		
		}
		#endregion

		#region Version accessor methods
		public static int GetVersionMinCount()
		{
			return 1;
		}

		public static int VersionMinCount
		{
			get
			{
				return 1;
			}
		}

		public static int GetVersionMaxCount()
		{
			return 1;
		}

		public static int VersionMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetVersionCount()
		{
			return DomChildCount(NodeType.Element, "", "Version");
		}

		public int VersionCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Version");
			}
		}

		public bool HasVersion()
		{
			return HasDomChild(NodeType.Element, "", "Version");
		}

		public SchemaString NewVersion()
		{
			return new SchemaString();
		}

		public SchemaString GetVersionAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "Version", index)));
		}

		public XmlNode GetStartingVersionCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "Version" );
		}

		public XmlNode GetAdvancedVersionCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "Version", curNode );
		}

		public SchemaString GetVersionValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.InnerText );
		}


		public SchemaString GetVersion()
		{
			return GetVersionAt(0);
		}

		public SchemaString Version
		{
			get
			{
				return GetVersionAt(0);
			}
		}

		public void RemoveVersionAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Version", index);
		}

		public void RemoveVersion()
		{
			RemoveVersionAt(0);
		}

		public XmlNode AddVersion(SchemaString newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Element, "", "Version", newValue.ToString());
			return null;
		}

		public void InsertVersionAt(SchemaString newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "Version", index, newValue.ToString());
		}

		public void ReplaceVersionAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "Version", index, newValue.ToString());
		}
		#endregion // Version accessor methods

		#region Version collection
        public VersionCollection	MyVersions = new VersionCollection( );

        public class VersionCollection: IEnumerable
        {
            Type_WMSAccessor parent;
            public Type_WMSAccessor Parent
			{
				set
				{
					parent = value;
				}
			}
			public VersionEnumerator GetEnumerator() 
			{
				return new VersionEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class VersionEnumerator: IEnumerator 
        {
			int nIndex;
			Type_WMSAccessor parent;
			public VersionEnumerator(Type_WMSAccessor par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.VersionCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetVersionAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // Version collection

		#region ImageFormat Documentation
		public static string GetImageFormatAnnoDocumentation()
		{
			return "";		
		}
		public static string GetImageFormatDefault()
		{
			return "";		
		}
		#endregion

		#region ImageFormat accessor methods
		public static int GetImageFormatMinCount()
		{
			return 1;
		}

		public static int ImageFormatMinCount
		{
			get
			{
				return 1;
			}
		}

		public static int GetImageFormatMaxCount()
		{
			return 1;
		}

		public static int ImageFormatMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetImageFormatCount()
		{
			return DomChildCount(NodeType.Element, "", "ImageFormat");
		}

		public int ImageFormatCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "ImageFormat");
			}
		}

		public bool HasImageFormat()
		{
			return HasDomChild(NodeType.Element, "", "ImageFormat");
		}

		public SchemaString NewImageFormat()
		{
			return new SchemaString();
		}

		public SchemaString GetImageFormatAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "ImageFormat", index)));
		}

		public XmlNode GetStartingImageFormatCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "ImageFormat" );
		}

		public XmlNode GetAdvancedImageFormatCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "ImageFormat", curNode );
		}

		public SchemaString GetImageFormatValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.InnerText );
		}


		public SchemaString GetImageFormat()
		{
			return GetImageFormatAt(0);
		}

		public SchemaString ImageFormat
		{
			get
			{
				return GetImageFormatAt(0);
			}
		}

		public void RemoveImageFormatAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "ImageFormat", index);
		}

		public void RemoveImageFormat()
		{
			RemoveImageFormatAt(0);
		}

		public XmlNode AddImageFormat(SchemaString newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Element, "", "ImageFormat", newValue.ToString());
			return null;
		}

		public void InsertImageFormatAt(SchemaString newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "ImageFormat", index, newValue.ToString());
		}

		public void ReplaceImageFormatAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "ImageFormat", index, newValue.ToString());
		}
		#endregion // ImageFormat accessor methods

		#region ImageFormat collection
        public ImageFormatCollection	MyImageFormats = new ImageFormatCollection( );

        public class ImageFormatCollection: IEnumerable
        {
            Type_WMSAccessor parent;
            public Type_WMSAccessor Parent
			{
				set
				{
					parent = value;
				}
			}
			public ImageFormatEnumerator GetEnumerator() 
			{
				return new ImageFormatEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class ImageFormatEnumerator: IEnumerator 
        {
			int nIndex;
			Type_WMSAccessor parent;
			public ImageFormatEnumerator(Type_WMSAccessor par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.ImageFormatCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetImageFormatAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // ImageFormat collection

		#region WMSLayerName Documentation
		public static string GetWMSLayerNameAnnoDocumentation()
		{
			return "";		
		}
		public static string GetWMSLayerNameDefault()
		{
			return "";		
		}
		#endregion

		#region WMSLayerName accessor methods
		public static int GetWMSLayerNameMinCount()
		{
			return 1;
		}

		public static int WMSLayerNameMinCount
		{
			get
			{
				return 1;
			}
		}

		public static int GetWMSLayerNameMaxCount()
		{
			return 1;
		}

		public static int WMSLayerNameMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetWMSLayerNameCount()
		{
			return DomChildCount(NodeType.Element, "", "WMSLayerName");
		}

		public int WMSLayerNameCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "WMSLayerName");
			}
		}

		public bool HasWMSLayerName()
		{
			return HasDomChild(NodeType.Element, "", "WMSLayerName");
		}

		public SchemaString NewWMSLayerName()
		{
			return new SchemaString();
		}

		public SchemaString GetWMSLayerNameAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "WMSLayerName", index)));
		}

		public XmlNode GetStartingWMSLayerNameCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "WMSLayerName" );
		}

		public XmlNode GetAdvancedWMSLayerNameCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "WMSLayerName", curNode );
		}

		public SchemaString GetWMSLayerNameValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.InnerText );
		}


		public SchemaString GetWMSLayerName()
		{
			return GetWMSLayerNameAt(0);
		}

		public SchemaString WMSLayerName
		{
			get
			{
				return GetWMSLayerNameAt(0);
			}
		}

		public void RemoveWMSLayerNameAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "WMSLayerName", index);
		}

		public void RemoveWMSLayerName()
		{
			RemoveWMSLayerNameAt(0);
		}

		public XmlNode AddWMSLayerName(SchemaString newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Element, "", "WMSLayerName", newValue.ToString());
			return null;
		}

		public void InsertWMSLayerNameAt(SchemaString newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "WMSLayerName", index, newValue.ToString());
		}

		public void ReplaceWMSLayerNameAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "WMSLayerName", index, newValue.ToString());
		}
		#endregion // WMSLayerName accessor methods

		#region WMSLayerName collection
        public WMSLayerNameCollection	MyWMSLayerNames = new WMSLayerNameCollection( );

        public class WMSLayerNameCollection: IEnumerable
        {
            Type_WMSAccessor parent;
            public Type_WMSAccessor Parent
			{
				set
				{
					parent = value;
				}
			}
			public WMSLayerNameEnumerator GetEnumerator() 
			{
				return new WMSLayerNameEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class WMSLayerNameEnumerator: IEnumerator 
        {
			int nIndex;
			Type_WMSAccessor parent;
			public WMSLayerNameEnumerator(Type_WMSAccessor par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.WMSLayerNameCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetWMSLayerNameAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // WMSLayerName collection

		#region WMSLayerStyle Documentation
		public static string GetWMSLayerStyleAnnoDocumentation()
		{
			return "";		
		}
		public static string GetWMSLayerStyleDefault()
		{
			return "";		
		}
		#endregion

		#region WMSLayerStyle accessor methods
		public static int GetWMSLayerStyleMinCount()
		{
			return 0;
		}

		public static int WMSLayerStyleMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetWMSLayerStyleMaxCount()
		{
			return 1;
		}

		public static int WMSLayerStyleMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetWMSLayerStyleCount()
		{
			return DomChildCount(NodeType.Element, "", "WMSLayerStyle");
		}

		public int WMSLayerStyleCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "WMSLayerStyle");
			}
		}

		public bool HasWMSLayerStyle()
		{
			return HasDomChild(NodeType.Element, "", "WMSLayerStyle");
		}

		public SchemaString NewWMSLayerStyle()
		{
			return new SchemaString();
		}

		public SchemaString GetWMSLayerStyleAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "WMSLayerStyle", index)));
		}

		public XmlNode GetStartingWMSLayerStyleCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "WMSLayerStyle" );
		}

		public XmlNode GetAdvancedWMSLayerStyleCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "WMSLayerStyle", curNode );
		}

		public SchemaString GetWMSLayerStyleValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.InnerText );
		}


		public SchemaString GetWMSLayerStyle()
		{
			return GetWMSLayerStyleAt(0);
		}

		public SchemaString WMSLayerStyle
		{
			get
			{
				return GetWMSLayerStyleAt(0);
			}
		}

		public void RemoveWMSLayerStyleAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "WMSLayerStyle", index);
		}

		public void RemoveWMSLayerStyle()
		{
			RemoveWMSLayerStyleAt(0);
		}

		public XmlNode AddWMSLayerStyle(SchemaString newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Element, "", "WMSLayerStyle", newValue.ToString());
			return null;
		}

		public void InsertWMSLayerStyleAt(SchemaString newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "WMSLayerStyle", index, newValue.ToString());
		}

		public void ReplaceWMSLayerStyleAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "WMSLayerStyle", index, newValue.ToString());
		}
		#endregion // WMSLayerStyle accessor methods

		#region WMSLayerStyle collection
        public WMSLayerStyleCollection	MyWMSLayerStyles = new WMSLayerStyleCollection( );

        public class WMSLayerStyleCollection: IEnumerable
        {
            Type_WMSAccessor parent;
            public Type_WMSAccessor Parent
			{
				set
				{
					parent = value;
				}
			}
			public WMSLayerStyleEnumerator GetEnumerator() 
			{
				return new WMSLayerStyleEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class WMSLayerStyleEnumerator: IEnumerator 
        {
			int nIndex;
			Type_WMSAccessor parent;
			public WMSLayerStyleEnumerator(Type_WMSAccessor par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.WMSLayerStyleCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetWMSLayerStyleAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // WMSLayerStyle collection

		#region UseTransparency Documentation
		public static string GetUseTransparencyAnnoDocumentation()
		{
			return "";		
		}
		public static string GetUseTransparencyDefault()
		{
			return "";		
		}
		#endregion

		#region UseTransparency accessor methods
		public static int GetUseTransparencyMinCount()
		{
			return 1;
		}

		public static int UseTransparencyMinCount
		{
			get
			{
				return 1;
			}
		}

		public static int GetUseTransparencyMaxCount()
		{
			return 1;
		}

		public static int UseTransparencyMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetUseTransparencyCount()
		{
			return DomChildCount(NodeType.Element, "", "UseTransparency");
		}

		public int UseTransparencyCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "UseTransparency");
			}
		}

		public bool HasUseTransparency()
		{
			return HasDomChild(NodeType.Element, "", "UseTransparency");
		}

		public SchemaBoolean NewUseTransparency()
		{
			return new SchemaBoolean();
		}

		public SchemaBoolean GetUseTransparencyAt(int index)
		{
			return new SchemaBoolean(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "UseTransparency", index)));
		}

		public XmlNode GetStartingUseTransparencyCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "UseTransparency" );
		}

		public XmlNode GetAdvancedUseTransparencyCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "UseTransparency", curNode );
		}

		public SchemaBoolean GetUseTransparencyValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaBoolean( curNode.InnerText );
		}


		public SchemaBoolean GetUseTransparency()
		{
			return GetUseTransparencyAt(0);
		}

		public SchemaBoolean UseTransparency
		{
			get
			{
				return GetUseTransparencyAt(0);
			}
		}

		public void RemoveUseTransparencyAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "UseTransparency", index);
		}

		public void RemoveUseTransparency()
		{
			RemoveUseTransparencyAt(0);
		}

		public XmlNode AddUseTransparency(SchemaBoolean newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Element, "", "UseTransparency", newValue.ToString());
			return null;
		}

		public void InsertUseTransparencyAt(SchemaBoolean newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "UseTransparency", index, newValue.ToString());
		}

		public void ReplaceUseTransparencyAt(SchemaBoolean newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "UseTransparency", index, newValue.ToString());
		}
		#endregion // UseTransparency accessor methods

		#region UseTransparency collection
        public UseTransparencyCollection	MyUseTransparencys = new UseTransparencyCollection( );

        public class UseTransparencyCollection: IEnumerable
        {
            Type_WMSAccessor parent;
            public Type_WMSAccessor Parent
			{
				set
				{
					parent = value;
				}
			}
			public UseTransparencyEnumerator GetEnumerator() 
			{
				return new UseTransparencyEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class UseTransparencyEnumerator: IEnumerator 
        {
			int nIndex;
			Type_WMSAccessor parent;
			public UseTransparencyEnumerator(Type_WMSAccessor par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.UseTransparencyCount );
			}
			public SchemaBoolean  Current 
			{
				get 
				{
					return(parent.GetUseTransparencyAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // UseTransparency collection

		#region Opacity Documentation
		public static string GetOpacityAnnoDocumentation()
		{
			return "";		
		}
		public static string GetOpacityDefault()
		{
			return "";		
		}
		#endregion

		#region Opacity accessor methods
		public static int GetOpacityMinCount()
		{
			return 0;
		}

		public static int OpacityMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetOpacityMaxCount()
		{
			return 1;
		}

		public static int OpacityMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetOpacityCount()
		{
			return DomChildCount(NodeType.Element, "", "Opacity");
		}

		public int OpacityCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Opacity");
			}
		}

		public bool HasOpacity()
		{
			return HasDomChild(NodeType.Element, "", "Opacity");
		}

		public OpacityType NewOpacity()
		{
			return new OpacityType();
		}

		public OpacityType GetOpacityAt(int index)
		{
			return new OpacityType(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "Opacity", index)));
		}

		public XmlNode GetStartingOpacityCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "Opacity" );
		}

		public XmlNode GetAdvancedOpacityCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "Opacity", curNode );
		}

		public OpacityType GetOpacityValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new OpacityType( curNode.InnerText );
		}


		public OpacityType GetOpacity()
		{
			return GetOpacityAt(0);
		}

		public OpacityType Opacity
		{
			get
			{
				return GetOpacityAt(0);
			}
		}

		public void RemoveOpacityAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Opacity", index);
		}

		public void RemoveOpacity()
		{
			RemoveOpacityAt(0);
		}

		public XmlNode AddOpacity(OpacityType newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Element, "", "Opacity", newValue.ToString());
			return null;
		}

		public void InsertOpacityAt(OpacityType newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "Opacity", index, newValue.ToString());
		}

		public void ReplaceOpacityAt(OpacityType newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "Opacity", index, newValue.ToString());
		}
		#endregion // Opacity accessor methods

		#region Opacity collection
        public OpacityCollection	MyOpacitys = new OpacityCollection( );

        public class OpacityCollection: IEnumerable
        {
            Type_WMSAccessor parent;
            public Type_WMSAccessor Parent
			{
				set
				{
					parent = value;
				}
			}
			public OpacityEnumerator GetEnumerator() 
			{
				return new OpacityEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class OpacityEnumerator: IEnumerator 
        {
			int nIndex;
			Type_WMSAccessor parent;
			public OpacityEnumerator(Type_WMSAccessor par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.OpacityCount );
			}
			public OpacityType  Current 
			{
				get 
				{
					return(parent.GetOpacityAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // Opacity collection

		#region CacheExpirationTime Documentation
		public static string GetCacheExpirationTimeAnnoDocumentation()
		{
			return "";		
		}
		public static string GetCacheExpirationTimeDefault()
		{
			return "";		
		}
		#endregion

		#region CacheExpirationTime accessor methods
		public static int GetCacheExpirationTimeMinCount()
		{
			return 0;
		}

		public static int CacheExpirationTimeMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetCacheExpirationTimeMaxCount()
		{
			return 1;
		}

		public static int CacheExpirationTimeMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetCacheExpirationTimeCount()
		{
			return DomChildCount(NodeType.Element, "", "CacheExpirationTime");
		}

		public int CacheExpirationTimeCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "CacheExpirationTime");
			}
		}

		public bool HasCacheExpirationTime()
		{
			return HasDomChild(NodeType.Element, "", "CacheExpirationTime");
		}

		public Type_SimpleTimeSpan NewCacheExpirationTime()
		{
			return new Type_SimpleTimeSpan(domNode.OwnerDocument.CreateElement("CacheExpirationTime", ""));
		}

		public Type_SimpleTimeSpan GetCacheExpirationTimeAt(int index)
		{
			return new Type_SimpleTimeSpan(GetDomChildAt(NodeType.Element, "", "CacheExpirationTime", index));
		}

		public XmlNode GetStartingCacheExpirationTimeCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "CacheExpirationTime" );
		}

		public XmlNode GetAdvancedCacheExpirationTimeCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "CacheExpirationTime", curNode );
		}

		public Type_SimpleTimeSpan GetCacheExpirationTimeValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new Type_SimpleTimeSpan( curNode );
		}


		public Type_SimpleTimeSpan GetCacheExpirationTime()
		{
			return GetCacheExpirationTimeAt(0);
		}

		public Type_SimpleTimeSpan CacheExpirationTime
		{
			get
			{
				return GetCacheExpirationTimeAt(0);
			}
		}

		public void RemoveCacheExpirationTimeAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "CacheExpirationTime", index);
		}

		public void RemoveCacheExpirationTime()
		{
			RemoveCacheExpirationTimeAt(0);
		}

		public XmlNode AddCacheExpirationTime(Type_SimpleTimeSpan newValue)
		{
			return AppendDomElement("", "CacheExpirationTime", newValue);
		}

		public void InsertCacheExpirationTimeAt(Type_SimpleTimeSpan newValue, int index)
		{
			InsertDomElementAt("", "CacheExpirationTime", index, newValue);
		}

		public void ReplaceCacheExpirationTimeAt(Type_SimpleTimeSpan newValue, int index)
		{
			ReplaceDomElementAt("", "CacheExpirationTime", index, newValue);
		}
		#endregion // CacheExpirationTime accessor methods

		#region CacheExpirationTime collection
        public CacheExpirationTimeCollection	MyCacheExpirationTimes = new CacheExpirationTimeCollection( );

        public class CacheExpirationTimeCollection: IEnumerable
        {
            Type_WMSAccessor parent;
            public Type_WMSAccessor Parent
			{
				set
				{
					parent = value;
				}
			}
			public CacheExpirationTimeEnumerator GetEnumerator() 
			{
				return new CacheExpirationTimeEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class CacheExpirationTimeEnumerator: IEnumerator 
        {
			int nIndex;
			Type_WMSAccessor parent;
			public CacheExpirationTimeEnumerator(Type_WMSAccessor par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.CacheExpirationTimeCount );
			}
			public Type_SimpleTimeSpan  Current 
			{
				get 
				{
					return(parent.GetCacheExpirationTimeAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // CacheExpirationTime collection

		#region BoundingBoxOverlap Documentation
		public static string GetBoundingBoxOverlapAnnoDocumentation()
		{
			return "";		
		}
		public static string GetBoundingBoxOverlapDefault()
		{
			return "";		
		}
		#endregion

		#region BoundingBoxOverlap accessor methods
		public static int GetBoundingBoxOverlapMinCount()
		{
			return 0;
		}

		public static int BoundingBoxOverlapMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetBoundingBoxOverlapMaxCount()
		{
			return 1;
		}

		public static int BoundingBoxOverlapMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetBoundingBoxOverlapCount()
		{
			return DomChildCount(NodeType.Element, "", "BoundingBoxOverlap");
		}

		public int BoundingBoxOverlapCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "BoundingBoxOverlap");
			}
		}

		public bool HasBoundingBoxOverlap()
		{
			return HasDomChild(NodeType.Element, "", "BoundingBoxOverlap");
		}

		public BoundingBoxOverlapType NewBoundingBoxOverlap()
		{
			return new BoundingBoxOverlapType();
		}

		public BoundingBoxOverlapType GetBoundingBoxOverlapAt(int index)
		{
			return new BoundingBoxOverlapType(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "BoundingBoxOverlap", index)));
		}

		public XmlNode GetStartingBoundingBoxOverlapCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "BoundingBoxOverlap" );
		}

		public XmlNode GetAdvancedBoundingBoxOverlapCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "BoundingBoxOverlap", curNode );
		}

		public BoundingBoxOverlapType GetBoundingBoxOverlapValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new BoundingBoxOverlapType( curNode.InnerText );
		}


		public BoundingBoxOverlapType GetBoundingBoxOverlap()
		{
			return GetBoundingBoxOverlapAt(0);
		}

		public BoundingBoxOverlapType BoundingBoxOverlap
		{
			get
			{
				return GetBoundingBoxOverlapAt(0);
			}
		}

		public void RemoveBoundingBoxOverlapAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "BoundingBoxOverlap", index);
		}

		public void RemoveBoundingBoxOverlap()
		{
			RemoveBoundingBoxOverlapAt(0);
		}

		public XmlNode AddBoundingBoxOverlap(BoundingBoxOverlapType newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Element, "", "BoundingBoxOverlap", newValue.ToString());
			return null;
		}

		public void InsertBoundingBoxOverlapAt(BoundingBoxOverlapType newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "BoundingBoxOverlap", index, newValue.ToString());
		}

		public void ReplaceBoundingBoxOverlapAt(BoundingBoxOverlapType newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "BoundingBoxOverlap", index, newValue.ToString());
		}
		#endregion // BoundingBoxOverlap accessor methods

		#region BoundingBoxOverlap collection
        public BoundingBoxOverlapCollection	MyBoundingBoxOverlaps = new BoundingBoxOverlapCollection( );

        public class BoundingBoxOverlapCollection: IEnumerable
        {
            Type_WMSAccessor parent;
            public Type_WMSAccessor Parent
			{
				set
				{
					parent = value;
				}
			}
			public BoundingBoxOverlapEnumerator GetEnumerator() 
			{
				return new BoundingBoxOverlapEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class BoundingBoxOverlapEnumerator: IEnumerator 
        {
			int nIndex;
			Type_WMSAccessor parent;
			public BoundingBoxOverlapEnumerator(Type_WMSAccessor par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.BoundingBoxOverlapCount );
			}
			public BoundingBoxOverlapType  Current 
			{
				get 
				{
					return(parent.GetBoundingBoxOverlapAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // BoundingBoxOverlap collection

		#region ServerLogoFilePath Documentation
		public static string GetServerLogoFilePathAnnoDocumentation()
		{
			return "";		
		}
		public static string GetServerLogoFilePathDefault()
		{
			return "";		
		}
		#endregion

		#region ServerLogoFilePath accessor methods
		public static int GetServerLogoFilePathMinCount()
		{
			return 0;
		}

		public static int ServerLogoFilePathMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetServerLogoFilePathMaxCount()
		{
			return 1;
		}

		public static int ServerLogoFilePathMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetServerLogoFilePathCount()
		{
			return DomChildCount(NodeType.Element, "", "ServerLogoFilePath");
		}

		public int ServerLogoFilePathCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "ServerLogoFilePath");
			}
		}

		public bool HasServerLogoFilePath()
		{
			return HasDomChild(NodeType.Element, "", "ServerLogoFilePath");
		}

		public SchemaString NewServerLogoFilePath()
		{
			return new SchemaString();
		}

		public SchemaString GetServerLogoFilePathAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "ServerLogoFilePath", index)));
		}

		public XmlNode GetStartingServerLogoFilePathCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "ServerLogoFilePath" );
		}

		public XmlNode GetAdvancedServerLogoFilePathCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "ServerLogoFilePath", curNode );
		}

		public SchemaString GetServerLogoFilePathValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.InnerText );
		}


		public SchemaString GetServerLogoFilePath()
		{
			return GetServerLogoFilePathAt(0);
		}

		public SchemaString ServerLogoFilePath
		{
			get
			{
				return GetServerLogoFilePathAt(0);
			}
		}

		public void RemoveServerLogoFilePathAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "ServerLogoFilePath", index);
		}

		public void RemoveServerLogoFilePath()
		{
			RemoveServerLogoFilePathAt(0);
		}

		public XmlNode AddServerLogoFilePath(SchemaString newValue)
		{
			if( newValue.IsNull() == false )
				return AppendDomChild(NodeType.Element, "", "ServerLogoFilePath", newValue.ToString());
			return null;
		}

		public void InsertServerLogoFilePathAt(SchemaString newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "ServerLogoFilePath", index, newValue.ToString());
		}

		public void ReplaceServerLogoFilePathAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "ServerLogoFilePath", index, newValue.ToString());
		}
		#endregion // ServerLogoFilePath accessor methods

		#region ServerLogoFilePath collection
        public ServerLogoFilePathCollection	MyServerLogoFilePaths = new ServerLogoFilePathCollection( );

        public class ServerLogoFilePathCollection: IEnumerable
        {
            Type_WMSAccessor parent;
            public Type_WMSAccessor Parent
			{
				set
				{
					parent = value;
				}
			}
			public ServerLogoFilePathEnumerator GetEnumerator() 
			{
				return new ServerLogoFilePathEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class ServerLogoFilePathEnumerator: IEnumerator 
        {
			int nIndex;
			Type_WMSAccessor parent;
			public ServerLogoFilePathEnumerator(Type_WMSAccessor par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.ServerLogoFilePathCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetServerLogoFilePathAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // ServerLogoFilePath collection

        private void SetCollectionParents()
        {
            MyUsernames.Parent = this; 
            MyPasswords.Parent = this; 
            MyServerGetMapUrls.Parent = this; 
            MyServiceNames.Parent = this; 
            MyVersions.Parent = this; 
            MyImageFormats.Parent = this; 
            MyWMSLayerNames.Parent = this; 
            MyWMSLayerStyles.Parent = this; 
            MyUseTransparencys.Parent = this; 
            MyOpacitys.Parent = this; 
            MyCacheExpirationTimes.Parent = this; 
            MyBoundingBoxOverlaps.Parent = this; 
            MyServerLogoFilePaths.Parent = this; 
	}
}
}
