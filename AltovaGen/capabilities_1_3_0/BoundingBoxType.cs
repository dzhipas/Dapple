//
// BoundingBoxType.cs
//
// This file was generated by XMLSpy 2006r3 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//


using System;
using System.Collections;
using System.Xml;
using Altova.Types;

namespace capabilities_1_3_0.wms
{
	public class BoundingBoxType : Altova.Xml.Node
	{
		#region Forward constructors

		public BoundingBoxType(XmlDocument doc) : base(doc) { SetCollectionParents(); }
		public BoundingBoxType(XmlNode node) : base(node) { SetCollectionParents(); }
		public BoundingBoxType(Altova.Xml.Node node) : base(node) { SetCollectionParents(); }
		public BoundingBoxType(Altova.Xml.Document doc, string namespaceURI, string prefix, string name) : base(doc, namespaceURI, prefix, name) { SetCollectionParents(); }
		#endregion // Forward constructors

		public override void AdjustPrefix()
		{

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Attribute, "", "CRS" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Attribute, "", "CRS", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, false);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Attribute, "", "minx" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Attribute, "", "minx", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, false);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Attribute, "", "miny" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Attribute, "", "miny", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, false);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Attribute, "", "maxx" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Attribute, "", "maxx", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, false);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Attribute, "", "maxy" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Attribute, "", "maxy", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, false);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Attribute, "", "resx" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Attribute, "", "resx", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, false);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Attribute, "", "resy" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Attribute, "", "resy", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, false);
			}
		}



		#region CRS accessor methods
		public static int GetCRSMinCount()
		{
			return 1;
		}

		public static int CRSMinCount
		{
			get
			{
				return 1;
			}
		}

		public static int GetCRSMaxCount()
		{
			return 1;
		}

		public static int CRSMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetCRSCount()
		{
			return DomChildCount(NodeType.Attribute, "", "CRS");
		}

		public int CRSCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "CRS");
			}
		}

		public bool HasCRS()
		{
			return HasDomChild(NodeType.Attribute, "", "CRS");
		}

		public SchemaString NewCRS()
		{
			return new SchemaString();
		}

		public SchemaString GetCRSAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "CRS", index)));
		}

		public XmlNode GetStartingCRSCursor()
		{
			return GetDomFirstChild( NodeType.Attribute, "", "CRS" );
		}

		public XmlNode GetAdvancedCRSCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Attribute, "", "CRS", curNode );
		}

		public SchemaString GetCRSValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.Value );
		}


		public SchemaString GetCRS()
		{
			return GetCRSAt(0);
		}

		public SchemaString CRS
		{
			get
			{
				return GetCRSAt(0);
			}
		}

		public void RemoveCRSAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "CRS", index);
		}

		public void RemoveCRS()
		{
			while (HasCRS())
				RemoveCRSAt(0);
		}

		public void AddCRS(SchemaString newValue)
		{
			if( newValue.IsNull() == false )
				AppendDomChild(NodeType.Attribute, "", "CRS", newValue.ToString());
		}

		public void InsertCRSAt(SchemaString newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Attribute, "", "CRS", index, newValue.ToString());
		}

		public void ReplaceCRSAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "CRS", index, newValue.ToString());
		}
		#endregion // CRS accessor methods

		#region CRS collection
        public CRSCollection	MyCRSs = new CRSCollection( );

        public class CRSCollection: IEnumerable
        {
            BoundingBoxType parent;
            public BoundingBoxType Parent
			{
				set
				{
					parent = value;
				}
			}
			public CRSEnumerator GetEnumerator() 
			{
				return new CRSEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class CRSEnumerator: IEnumerator 
        {
			int nIndex;
			BoundingBoxType parent;
			public CRSEnumerator(BoundingBoxType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.CRSCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetCRSAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // CRS collection

		#region minx accessor methods
		public static int GetminxMinCount()
		{
			return 1;
		}

		public static int minxMinCount
		{
			get
			{
				return 1;
			}
		}

		public static int GetminxMaxCount()
		{
			return 1;
		}

		public static int minxMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetminxCount()
		{
			return DomChildCount(NodeType.Attribute, "", "minx");
		}

		public int minxCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "minx");
			}
		}

		public bool Hasminx()
		{
			return HasDomChild(NodeType.Attribute, "", "minx");
		}

		public SchemaDouble Newminx()
		{
			return new SchemaDouble();
		}

		public SchemaDouble GetminxAt(int index)
		{
			return new SchemaDouble(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "minx", index)));
		}

		public XmlNode GetStartingminxCursor()
		{
			return GetDomFirstChild( NodeType.Attribute, "", "minx" );
		}

		public XmlNode GetAdvancedminxCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Attribute, "", "minx", curNode );
		}

		public SchemaDouble GetminxValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaDouble( curNode.Value );
		}


		public SchemaDouble Getminx()
		{
			return GetminxAt(0);
		}

		public SchemaDouble minx
		{
			get
			{
				return GetminxAt(0);
			}
		}

		public void RemoveminxAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "minx", index);
		}

		public void Removeminx()
		{
			while (Hasminx())
				RemoveminxAt(0);
		}

		public void Addminx(SchemaDouble newValue)
		{
			if( newValue.IsNull() == false )
				AppendDomChild(NodeType.Attribute, "", "minx", newValue.ToString());
		}

		public void InsertminxAt(SchemaDouble newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Attribute, "", "minx", index, newValue.ToString());
		}

		public void ReplaceminxAt(SchemaDouble newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "minx", index, newValue.ToString());
		}
		#endregion // minx accessor methods

		#region minx collection
        public minxCollection	Myminxs = new minxCollection( );

        public class minxCollection: IEnumerable
        {
            BoundingBoxType parent;
            public BoundingBoxType Parent
			{
				set
				{
					parent = value;
				}
			}
			public minxEnumerator GetEnumerator() 
			{
				return new minxEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class minxEnumerator: IEnumerator 
        {
			int nIndex;
			BoundingBoxType parent;
			public minxEnumerator(BoundingBoxType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.minxCount );
			}
			public SchemaDouble  Current 
			{
				get 
				{
					return(parent.GetminxAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // minx collection

		#region miny accessor methods
		public static int GetminyMinCount()
		{
			return 1;
		}

		public static int minyMinCount
		{
			get
			{
				return 1;
			}
		}

		public static int GetminyMaxCount()
		{
			return 1;
		}

		public static int minyMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetminyCount()
		{
			return DomChildCount(NodeType.Attribute, "", "miny");
		}

		public int minyCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "miny");
			}
		}

		public bool Hasminy()
		{
			return HasDomChild(NodeType.Attribute, "", "miny");
		}

		public SchemaDouble Newminy()
		{
			return new SchemaDouble();
		}

		public SchemaDouble GetminyAt(int index)
		{
			return new SchemaDouble(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "miny", index)));
		}

		public XmlNode GetStartingminyCursor()
		{
			return GetDomFirstChild( NodeType.Attribute, "", "miny" );
		}

		public XmlNode GetAdvancedminyCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Attribute, "", "miny", curNode );
		}

		public SchemaDouble GetminyValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaDouble( curNode.Value );
		}


		public SchemaDouble Getminy()
		{
			return GetminyAt(0);
		}

		public SchemaDouble miny
		{
			get
			{
				return GetminyAt(0);
			}
		}

		public void RemoveminyAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "miny", index);
		}

		public void Removeminy()
		{
			while (Hasminy())
				RemoveminyAt(0);
		}

		public void Addminy(SchemaDouble newValue)
		{
			if( newValue.IsNull() == false )
				AppendDomChild(NodeType.Attribute, "", "miny", newValue.ToString());
		}

		public void InsertminyAt(SchemaDouble newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Attribute, "", "miny", index, newValue.ToString());
		}

		public void ReplaceminyAt(SchemaDouble newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "miny", index, newValue.ToString());
		}
		#endregion // miny accessor methods

		#region miny collection
        public minyCollection	Myminys = new minyCollection( );

        public class minyCollection: IEnumerable
        {
            BoundingBoxType parent;
            public BoundingBoxType Parent
			{
				set
				{
					parent = value;
				}
			}
			public minyEnumerator GetEnumerator() 
			{
				return new minyEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class minyEnumerator: IEnumerator 
        {
			int nIndex;
			BoundingBoxType parent;
			public minyEnumerator(BoundingBoxType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.minyCount );
			}
			public SchemaDouble  Current 
			{
				get 
				{
					return(parent.GetminyAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // miny collection

		#region maxx accessor methods
		public static int GetmaxxMinCount()
		{
			return 1;
		}

		public static int maxxMinCount
		{
			get
			{
				return 1;
			}
		}

		public static int GetmaxxMaxCount()
		{
			return 1;
		}

		public static int maxxMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetmaxxCount()
		{
			return DomChildCount(NodeType.Attribute, "", "maxx");
		}

		public int maxxCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "maxx");
			}
		}

		public bool Hasmaxx()
		{
			return HasDomChild(NodeType.Attribute, "", "maxx");
		}

		public SchemaDouble Newmaxx()
		{
			return new SchemaDouble();
		}

		public SchemaDouble GetmaxxAt(int index)
		{
			return new SchemaDouble(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "maxx", index)));
		}

		public XmlNode GetStartingmaxxCursor()
		{
			return GetDomFirstChild( NodeType.Attribute, "", "maxx" );
		}

		public XmlNode GetAdvancedmaxxCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Attribute, "", "maxx", curNode );
		}

		public SchemaDouble GetmaxxValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaDouble( curNode.Value );
		}


		public SchemaDouble Getmaxx()
		{
			return GetmaxxAt(0);
		}

		public SchemaDouble maxx
		{
			get
			{
				return GetmaxxAt(0);
			}
		}

		public void RemovemaxxAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "maxx", index);
		}

		public void Removemaxx()
		{
			while (Hasmaxx())
				RemovemaxxAt(0);
		}

		public void Addmaxx(SchemaDouble newValue)
		{
			if( newValue.IsNull() == false )
				AppendDomChild(NodeType.Attribute, "", "maxx", newValue.ToString());
		}

		public void InsertmaxxAt(SchemaDouble newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Attribute, "", "maxx", index, newValue.ToString());
		}

		public void ReplacemaxxAt(SchemaDouble newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "maxx", index, newValue.ToString());
		}
		#endregion // maxx accessor methods

		#region maxx collection
        public maxxCollection	Mymaxxs = new maxxCollection( );

        public class maxxCollection: IEnumerable
        {
            BoundingBoxType parent;
            public BoundingBoxType Parent
			{
				set
				{
					parent = value;
				}
			}
			public maxxEnumerator GetEnumerator() 
			{
				return new maxxEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class maxxEnumerator: IEnumerator 
        {
			int nIndex;
			BoundingBoxType parent;
			public maxxEnumerator(BoundingBoxType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.maxxCount );
			}
			public SchemaDouble  Current 
			{
				get 
				{
					return(parent.GetmaxxAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // maxx collection

		#region maxy accessor methods
		public static int GetmaxyMinCount()
		{
			return 1;
		}

		public static int maxyMinCount
		{
			get
			{
				return 1;
			}
		}

		public static int GetmaxyMaxCount()
		{
			return 1;
		}

		public static int maxyMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetmaxyCount()
		{
			return DomChildCount(NodeType.Attribute, "", "maxy");
		}

		public int maxyCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "maxy");
			}
		}

		public bool Hasmaxy()
		{
			return HasDomChild(NodeType.Attribute, "", "maxy");
		}

		public SchemaDouble Newmaxy()
		{
			return new SchemaDouble();
		}

		public SchemaDouble GetmaxyAt(int index)
		{
			return new SchemaDouble(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "maxy", index)));
		}

		public XmlNode GetStartingmaxyCursor()
		{
			return GetDomFirstChild( NodeType.Attribute, "", "maxy" );
		}

		public XmlNode GetAdvancedmaxyCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Attribute, "", "maxy", curNode );
		}

		public SchemaDouble GetmaxyValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaDouble( curNode.Value );
		}


		public SchemaDouble Getmaxy()
		{
			return GetmaxyAt(0);
		}

		public SchemaDouble maxy
		{
			get
			{
				return GetmaxyAt(0);
			}
		}

		public void RemovemaxyAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "maxy", index);
		}

		public void Removemaxy()
		{
			while (Hasmaxy())
				RemovemaxyAt(0);
		}

		public void Addmaxy(SchemaDouble newValue)
		{
			if( newValue.IsNull() == false )
				AppendDomChild(NodeType.Attribute, "", "maxy", newValue.ToString());
		}

		public void InsertmaxyAt(SchemaDouble newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Attribute, "", "maxy", index, newValue.ToString());
		}

		public void ReplacemaxyAt(SchemaDouble newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "maxy", index, newValue.ToString());
		}
		#endregion // maxy accessor methods

		#region maxy collection
        public maxyCollection	Mymaxys = new maxyCollection( );

        public class maxyCollection: IEnumerable
        {
            BoundingBoxType parent;
            public BoundingBoxType Parent
			{
				set
				{
					parent = value;
				}
			}
			public maxyEnumerator GetEnumerator() 
			{
				return new maxyEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class maxyEnumerator: IEnumerator 
        {
			int nIndex;
			BoundingBoxType parent;
			public maxyEnumerator(BoundingBoxType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.maxyCount );
			}
			public SchemaDouble  Current 
			{
				get 
				{
					return(parent.GetmaxyAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // maxy collection

		#region resx accessor methods
		public static int GetresxMinCount()
		{
			return 0;
		}

		public static int resxMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetresxMaxCount()
		{
			return 1;
		}

		public static int resxMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetresxCount()
		{
			return DomChildCount(NodeType.Attribute, "", "resx");
		}

		public int resxCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "resx");
			}
		}

		public bool Hasresx()
		{
			return HasDomChild(NodeType.Attribute, "", "resx");
		}

		public SchemaDouble Newresx()
		{
			return new SchemaDouble();
		}

		public SchemaDouble GetresxAt(int index)
		{
			return new SchemaDouble(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "resx", index)));
		}

		public XmlNode GetStartingresxCursor()
		{
			return GetDomFirstChild( NodeType.Attribute, "", "resx" );
		}

		public XmlNode GetAdvancedresxCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Attribute, "", "resx", curNode );
		}

		public SchemaDouble GetresxValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaDouble( curNode.Value );
		}


		public SchemaDouble Getresx()
		{
			return GetresxAt(0);
		}

		public SchemaDouble resx
		{
			get
			{
				return GetresxAt(0);
			}
		}

		public void RemoveresxAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "resx", index);
		}

		public void Removeresx()
		{
			while (Hasresx())
				RemoveresxAt(0);
		}

		public void Addresx(SchemaDouble newValue)
		{
			if( newValue.IsNull() == false )
				AppendDomChild(NodeType.Attribute, "", "resx", newValue.ToString());
		}

		public void InsertresxAt(SchemaDouble newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Attribute, "", "resx", index, newValue.ToString());
		}

		public void ReplaceresxAt(SchemaDouble newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "resx", index, newValue.ToString());
		}
		#endregion // resx accessor methods

		#region resx collection
        public resxCollection	Myresxs = new resxCollection( );

        public class resxCollection: IEnumerable
        {
            BoundingBoxType parent;
            public BoundingBoxType Parent
			{
				set
				{
					parent = value;
				}
			}
			public resxEnumerator GetEnumerator() 
			{
				return new resxEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class resxEnumerator: IEnumerator 
        {
			int nIndex;
			BoundingBoxType parent;
			public resxEnumerator(BoundingBoxType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.resxCount );
			}
			public SchemaDouble  Current 
			{
				get 
				{
					return(parent.GetresxAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // resx collection

		#region resy accessor methods
		public static int GetresyMinCount()
		{
			return 0;
		}

		public static int resyMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetresyMaxCount()
		{
			return 1;
		}

		public static int resyMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetresyCount()
		{
			return DomChildCount(NodeType.Attribute, "", "resy");
		}

		public int resyCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "resy");
			}
		}

		public bool Hasresy()
		{
			return HasDomChild(NodeType.Attribute, "", "resy");
		}

		public SchemaDouble Newresy()
		{
			return new SchemaDouble();
		}

		public SchemaDouble GetresyAt(int index)
		{
			return new SchemaDouble(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "resy", index)));
		}

		public XmlNode GetStartingresyCursor()
		{
			return GetDomFirstChild( NodeType.Attribute, "", "resy" );
		}

		public XmlNode GetAdvancedresyCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Attribute, "", "resy", curNode );
		}

		public SchemaDouble GetresyValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaDouble( curNode.Value );
		}


		public SchemaDouble Getresy()
		{
			return GetresyAt(0);
		}

		public SchemaDouble resy
		{
			get
			{
				return GetresyAt(0);
			}
		}

		public void RemoveresyAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "resy", index);
		}

		public void Removeresy()
		{
			while (Hasresy())
				RemoveresyAt(0);
		}

		public void Addresy(SchemaDouble newValue)
		{
			if( newValue.IsNull() == false )
				AppendDomChild(NodeType.Attribute, "", "resy", newValue.ToString());
		}

		public void InsertresyAt(SchemaDouble newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Attribute, "", "resy", index, newValue.ToString());
		}

		public void ReplaceresyAt(SchemaDouble newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "resy", index, newValue.ToString());
		}
		#endregion // resy accessor methods

		#region resy collection
        public resyCollection	Myresys = new resyCollection( );

        public class resyCollection: IEnumerable
        {
            BoundingBoxType parent;
            public BoundingBoxType Parent
			{
				set
				{
					parent = value;
				}
			}
			public resyEnumerator GetEnumerator() 
			{
				return new resyEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class resyEnumerator: IEnumerator 
        {
			int nIndex;
			BoundingBoxType parent;
			public resyEnumerator(BoundingBoxType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.resyCount );
			}
			public SchemaDouble  Current 
			{
				get 
				{
					return(parent.GetresyAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // resy collection

        private void SetCollectionParents()
        {
            MyCRSs.Parent = this; 
            Myminxs.Parent = this; 
            Myminys.Parent = this; 
            Mymaxxs.Parent = this; 
            Mymaxys.Parent = this; 
            Myresxs.Parent = this; 
            Myresys.Parent = this; 
	}
}
}
