//
// SchemaTypes.cs
//
// This file was generated by XMLSpy 2007r3 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//


using System;
using System.Globalization;
using System.Text;
using Altova;


namespace Altova.Types
{
	#region Interfaces
	/// <summary>
	/// Common interface for all schema-types.
	/// </summary>
	public interface ISchemaType : IComparable, ICloneable
	{
		bool BoolValue(); // returns the value as bool if possible, otherwise false.
		bool IsEmpty();
		void SetEmpty( bool bIsEmpty );
		bool IsNull();
		void SetNull( bool bIsNull );
		

	}

	/// <summary>
	/// Interface for all schema-types containing (or may contain) numeric values.
	/// Used for type-casts.
	/// </summary>
	public enum ENumericTypes { ValueInt=1, ValueLong, ValueDouble, ValueDecimal };
	public interface ISchemaTypeNumber : ISchemaType 
	{
		ENumericTypes NumericType(); // returns if the value is nummeric and up to which degree.

		int IntValue();
		long LongValue();
		double DoubleValue();
		decimal DecimalValue();
	}

	/// <summary>
	/// Interface for all schema-types containing (or may contain) date/time/dateTime or duration values.
	/// </summary>
	public enum ECalendarTypes { Undefined=-1, Duration=0, DateTime, Date, Time };
	public interface ISchemaTypeCalendar : ISchemaType
	{
		ECalendarTypes CalendarType();

		SchemaDuration DurationValue();
		SchemaDateTime DateTimeValue();
		SchemaDate DateValue();
		SchemaTime TimeValue();
	}

	/// <summary>
	/// Interface for all schema-types containing (or may contain) binary values.
	/// Used for type-casts.
	/// </summary>
	public enum EBinaryTypes { Base64=1, Hex };
	public interface ISchemaTypeBinary : ISchemaType 
	{
		EBinaryTypes BinaryType(); // returns if the value is binary and to which base.
	}
	#endregion //Interfaces

	#region Base classes
	/// <summary>
	/// Common base-class for all schema-types containing date/time/dateTime values
	/// </summary>
	public abstract class SchemaCalendarBase : ISchemaTypeCalendar
	{
		public enum ETZ { Missing, UTC, Offset };

		protected System.DateTime myValue;
		protected ETZ eTZ;
		protected int offsetTZ; // offset in minutes
		protected bool isEmpty;
		protected bool isNull;

		[Flags]
		protected enum DateTimePart
		{
			Year = 1 << 0,
			Month = 1 << 1,
			Day = 1 << 2,
			Date = Year|Month|Day,
			Time = 1 << 3,
		}

		class ParseContext
		{
			string source;
			int index;

			public ParseContext(string source) 
			{
				this.source = source;
				this.index = 0;
			}

			public bool IsValid() 
			{
				return index < source.Length;
			}

			public bool Check(char expect)
			{
				if (!IsValid()) return false;
				return source[index] == expect;
			}

			public bool CheckAndAdvance(char expect)
			{
				if (!Check(expect)) return false;
				Advance();
				return true;
			}

			public void Advance()
			{
				++index;
			}

			public bool ReadDigitAndAdvance(ref int value, int scale, int maxdigit)
			{
				if (!IsValid()) return false;
				char c = source[index];
				if (c < '0' || c > '9')
					return false;
				int val = (int)c - (int)'0';
				if (val > maxdigit)
					return false;
				value += val * scale;
				Advance();
				return true;
			}
		}

		protected bool ParseDateTime(string s, DateTimePart part)
		{
			ParseContext context = new ParseContext(s);

			bool bDatePart = ( part & DateTimePart.Date ) != 0;
			bool bTimePart = ( part & DateTimePart.Time ) != 0;

			int year = 0, month = 0, day = 0;
			int hour = 0, minute = 0;
			double second = 0;
			
			eTZ = ETZ.Missing;
			offsetTZ = 0;

			if ( bDatePart )
			{
				// parse date
				bool bNegative = context.CheckAndAdvance( '-' );

				if ( (part & DateTimePart.Year ) != 0 )
				{
					int digits = 0;
					int temp = 0;						
					while ( context.ReadDigitAndAdvance( ref temp, 1, 9 ) )
					{
						year = year * 10 + temp;
						digits += 1;
						temp = 0;
						if (digits >= 8) // overflow
							return false;
					}			 
					if ( digits < 4 ) // invalid.
						return false;
					if ( digits > 4 && year < 10000 )
						return false;
					if (bNegative) 
						year = -year;
				} 

				if ( (part & ( DateTimePart.Month | DateTimePart.Day )) != 0 ) 
				{
					if ( !context.CheckAndAdvance( '-' ) ) return false;

					if ( ( part & DateTimePart.Month ) != 0 )
					{
						if ( !context.ReadDigitAndAdvance( ref month, 10, 1 ) ) return false;
						if ( !context.ReadDigitAndAdvance( ref month, 1, month < 10 ? 9 : 2 ) ) return false;
						if ( month == 0 ) return false;						
					}

					if ( ( part & DateTimePart.Day ) != 0 ) 
					{
						if ( !context.CheckAndAdvance(  '-') ) return false;

						int maxFirstDigit = month != 2 ? 3 : 2;

						// complicate things by making them complicated.
						if ( !context.ReadDigitAndAdvance( ref day, 10, maxFirstDigit ) ) return false;
						if ( !context.ReadDigitAndAdvance( ref day, 1, 9 ) ) return false;
						if ( day == 0 || day > 31 ) return false;
						
						if ( ( part & DateTimePart.Month ) != 0 )
						{
							bool b1 = month <= 7;
							bool b2 = ( month & 1 ) == 0;

							// month 1, 3, 5, 7, 8, 10, 12
							if ( b1 == b2 && day > 30 )
								return false;

							// february.
							if ( month == 2 && day > 29 )
								return false;

							// leap years.
							if ( month == 2 && ( part & DateTimePart.Year ) != 0 && 
								( year % 4 != 0 || year % 100 == 0 ) && year % 400 != 0 &&
								day > 28 )
								return false;
						}
					}
				}	

				if ( bTimePart )
				{
					// a 'T' must follow
					if ( !context.CheckAndAdvance( 'T') ) return false;
				}
			}

			if ( bTimePart )
			{
				// check format here
				
				// hour from 0 to 2
				if ( !context.ReadDigitAndAdvance( ref hour, 10, 2 ) ) return false;
				if ( !context.ReadDigitAndAdvance( ref hour, 1, hour < 20 ? 9 : 4 ) ) return false;
				if ( !context.CheckAndAdvance( ':' ) ) return false;
				int maxFirstDigit = hour == 24 ? 0 : 5;
				int maxSecondDigit = hour == 24 ? 0 : 9;
				if ( !context.ReadDigitAndAdvance( ref minute, 10, maxFirstDigit ) ) return false;
				if ( !context.ReadDigitAndAdvance( ref minute, 1, maxSecondDigit ) ) return false;
				if ( !context.CheckAndAdvance( ':' ) ) return false;
				int secondInt = 0;
				if ( !context.ReadDigitAndAdvance( ref secondInt, 10, maxFirstDigit ) ) return false;
				if ( !context.ReadDigitAndAdvance( ref secondInt, 1, maxSecondDigit ) ) return false;

				second = secondInt;

				if ( context.CheckAndAdvance( '.' ) )
				{
					// fraction. do whatever seems fit.
					int val = 0;
					int digits = 0;
					while ( context.ReadDigitAndAdvance( ref val, 1, 9) )
					{
						val *= 10;
						digits += 1;
						if ( digits >= 8 ) // precision loss - ignore
							break;
					}

					if ( digits == 0 )
						return false;

					second += val * Math.Pow( 10.0, -digits - 1 );

					// skip any further digits.
					while ( context.ReadDigitAndAdvance( ref val, 0, 9) ) 
						;		
				}
			}

			// timezone
			if ( context.CheckAndAdvance('Z') )
			{
				// timezone specified, it is UTC.
				eTZ = ETZ.UTC;
				offsetTZ = 0;				
			}
			else if ( context.Check('+') || context.Check('-' ) )
			{
				// timezone offset, in hour:minute format
				bool bNegative = context.Check('-');
				context.Advance();
				
				// do not check the hour part, for those who are obscure.
				int temp = 0;
				if ( !context.ReadDigitAndAdvance( ref temp, 600, 9 ) ) return false;
				if ( !context.ReadDigitAndAdvance( ref temp, 60, 9 ) ) return false;
				if ( !context.CheckAndAdvance( ':' ) ) return false;
				if ( !context.ReadDigitAndAdvance( ref temp, 10, 5 ) ) return false;
				if ( !context.ReadDigitAndAdvance( ref temp, 1, 9 ) ) return false;

				eTZ = ETZ.Offset;
				offsetTZ = bNegative ? -temp : temp;
			}

			if ( context.IsValid() )
				return false;

			// C# specific
			if (year <= 0) year = 1;
			if (month == 0) month = 1;
			bool badjust = false;
            if (hour == 24)
            {
                hour = 0;
                badjust = true;
            }
			if (day == 0) day = 1;
			try {
				myValue = new System.DateTime(year, month, day, hour, minute, (int)second,
					(int)(second * 1000) % 1000);
				if (badjust)
                    myValue.AddDays(1);
			}
			catch 
			{
				return false;
			}
			return true;

		}

		#region Constructors
		public SchemaCalendarBase() 
		{
			Reset();
			isEmpty = true;
			isNull = false;
			eTZ = ETZ.Missing;
		}

		public SchemaCalendarBase(SchemaCalendarBase obj)
		{
			myValue = obj.myValue;
			eTZ = obj.eTZ;
			offsetTZ = obj.offsetTZ;
			isEmpty = obj.isEmpty;
			isNull = obj.isNull;
		}

		public SchemaCalendarBase(System.DateTime newvalue)
		{
			myValue = newvalue;
			eTZ = ETZ.Missing;
			offsetTZ = 0;
			isEmpty = false;
			isNull = false;
		}

		public SchemaCalendarBase(int year, int month, int day, int hour, int minute, int second, double newpartsecond, bool newhasTZ, int newoffsetTZ)
		{
			myValue = new System.DateTime(year, month, day, hour, minute, second, (int)(newpartsecond*1000) );
			eTZ = newhasTZ ? ( newoffsetTZ == 0 ? ETZ.UTC : ETZ.Offset ) : ETZ.Missing;
			offsetTZ = newoffsetTZ;
			isEmpty = false;
			isNull = false;
		}

		#endregion //Constructors

		#region Get, Set
		public System.DateTime Value
		{
			get
			{
				return myValue;
			}
			set
			{
				myValue = value;
				isEmpty = false;
			}
		}

		public ETZ HasTimezone
		{
			get
			{
				return eTZ;
			}
			set
			{
				eTZ = value;
				isEmpty = false;
			}
		}

		public int TimezoneOffset
		{
			get
			{
				return offsetTZ;
			}
			set
			{
				offsetTZ = value;
				eTZ = (offsetTZ != 0) ? ETZ.Offset : ETZ.UTC;
				isEmpty = false;
			}
		}

		#endregion //Get, Set

		#region implemented Interfaces
		// System.IComparable
		public override bool Equals(object obj) 
		{
			if (! (obj is SchemaCalendarBase))
				return false;
			SchemaCalendarBase dt = (SchemaCalendarBase)obj;
			if( myValue.CompareTo(dt.myValue)!=0 )
				return false;
			if( !(eTZ == dt.eTZ) )
				return false;
			if( !(offsetTZ == dt.offsetTZ) )
				return false;
			return true;
		}

		public override int GetHashCode()
		{
			return myValue.GetHashCode();
		}

		public int CompareTo(object obj)
		{
			return CompareTo( (SchemaCalendarBase)obj );
		}

		public int CompareTo(SchemaCalendarBase obj)
		{
			System.DateTime a = GetDateTime( true );
			System.DateTime b = obj.GetDateTime( true );
			return a.CompareTo( b );
		}

		// ISchemaType
		public bool BoolValue() 
		{
			return true;
		}

		public bool IsEmpty()
		{
			return isEmpty;
		}

		public void SetEmpty( bool bIsEmpty )
		{
			isEmpty = bIsEmpty;
			if( bIsEmpty )
				myValue = System.DateTime.Now;
		}

		public bool IsNull()
		{
			return isNull;
		}

		public void SetNull( bool bIsNull )
		{
			isNull = bIsNull;
			if( bIsNull )
				SetEmpty( true );
		}

		// ISchemaTypeCalendar
		public SchemaDuration DurationValue()
		{
			throw new TypesIncompatibleException(this, new SchemaDuration( "PT" ) );
		}
		#endregion //Implemented interfaces

		#region Utility functions
		public string ToDateString() 
		{
			string s = "";
			s += myValue.Year.ToString("0000");
			s += "-";
			s += myValue.Month.ToString("00");
			s += "-";
			s += myValue.Day.ToString("00");
			return s;
		}

		public string ToTimeString() 
		{
			string s = "";
			s += myValue.Hour.ToString("00");
			s += ":";
			s += myValue.Minute.ToString("00");
			s += ":";
			s += myValue.Second.ToString("00");
			double partsecond = (double)myValue.Millisecond / 1000.0;
			if( partsecond > 0 && partsecond < 1) 
			{
				string sPartSecond = partsecond.ToString("0.0###############");
				s += ".";
				s += sPartSecond.Substring( 2, sPartSecond.Length-2 );
			}
			if( eTZ == ETZ.UTC )
			{
				s += "Z";
			}
			else if( eTZ == ETZ.Offset ) 
			{
				int absOffsetTZ = offsetTZ;
				if (offsetTZ < 0) 
				{
					s += "-";
					absOffsetTZ = -offsetTZ;
				}
				else
					s += "+";
				s += ((int)(absOffsetTZ / 60)).ToString("00");
				s += ":";
				s += ((int)(absOffsetTZ % 60)).ToString("00");
			}
			return s;
		}

		protected void ParseDate(string newvalue) //throws StringParseException 
		{
			if ( newvalue == null || newvalue.Length == 0 ) 
				return;
			else if (newvalue.Length < 10)
				throw new StringParseException("date-part of string is too short");
			else
			{
				try 
				{
					int nStart = 0;
					if( newvalue.Substring(0,1).Equals("-") )
						nStart = 1;
					int year = Convert.ToInt32(newvalue.Substring(0, 4));
					if( !newvalue.Substring(nStart+4, 1).Equals("-"))
						throw new StringParseException("invalid date format");
					int month = Convert.ToInt32(newvalue.Substring(nStart+5, 2));
					if( !newvalue.Substring(nStart+7, 1).Equals("-"))
						throw new StringParseException("invalid date format");
					int day = Convert.ToInt32(newvalue.Substring(nStart+8, newvalue.Length-nStart-8));
					myValue = new System.DateTime( year, month, day, myValue.Hour, myValue.Minute, myValue.Second, myValue.Millisecond);
				}
				catch (FormatException) 
				{
					throw new StringParseException("invalid date format");
				}
				isEmpty = false;
			}
		}

		protected void ParseTime(string newvalue) //throws StringParseException 
		{
			if ( newvalue == null || newvalue.Length == 0 ) 
				return;
			if (newvalue.Length < 8)
				throw new StringParseException("time-part of string is too short");
			try 
			{
				int nStart = 0;
				int hour = Convert.ToInt32(newvalue.Substring(nStart, 2));
				if( !newvalue.Substring(nStart+2, 1).Equals(":"))
					throw new StringParseException("invalid date format");
				int minute = Convert.ToInt32(newvalue.Substring(nStart+3, 2));
				if( !newvalue.Substring(nStart+5, 1).Equals(":"))
					throw new StringParseException("invalid date format");
				int second = Convert.ToInt32(newvalue.Substring(nStart+6, 2));
				int nTZStartPosition = nStart+8;
				double partsecond = 0.0;
				if (newvalue.Length>(nStart+8) ) 
				{
					nStart = nTZStartPosition;
					int nEnd = newvalue.Length;
					int nMSecEnd = newvalue.IndexOf("Z", nStart);
					if( nMSecEnd > -1  &&  nMSecEnd < nEnd )
						nEnd = nMSecEnd;
					nMSecEnd = newvalue.IndexOf("+", nStart);
					if( nMSecEnd > -1  &&  nMSecEnd < nEnd )
						nEnd = nMSecEnd;
					nMSecEnd = newvalue.IndexOf("-", nStart);
					if( nMSecEnd > -1  &&  nMSecEnd < nEnd )
						nEnd = nMSecEnd;
					nTZStartPosition = nEnd;
					partsecond = Convert.ToDouble( "0" + newvalue.Substring(nStart, nEnd-nStart), CultureInfo.InvariantCulture);
				}
				eTZ = ETZ.Missing;
				offsetTZ = 0;
				if (newvalue.Length>nTZStartPosition && newvalue.Substring(nTZStartPosition, 1).Equals("Z"))
					eTZ = ETZ.UTC;
				else if (newvalue.Length == nTZStartPosition + 6) 
				{
					eTZ = ETZ.Offset;
					offsetTZ = Convert.ToInt32(newvalue.Substring(nTZStartPosition+1, 2)) * 60 +
						Convert.ToInt32(newvalue.Substring(nTZStartPosition+4, 2));
					if( newvalue.Substring(nTZStartPosition, 1).Equals("-"))
						offsetTZ = -offsetTZ;
				}
				myValue = new System.DateTime( myValue.Year, myValue.Month, myValue.Day, hour, minute, second, (int)(partsecond * 1000.0));
			}
			catch (FormatException) 
			{
				throw new StringParseException("invalid number format");
			}
			isEmpty = false;
		}

		public System.DateTime GetDateTime(bool correctTZ) 
		{
			System.DateTime result = myValue;
			if( correctTZ && eTZ == ETZ.Offset )
				result.AddMinutes( offsetTZ );

			return	result;
		}

		public void Reset()
		{
			//myValue = System.DateTime.Now;
			myValue = new System.DateTime();
			eTZ = ETZ.Missing;
			offsetTZ = 0;
		}

		#endregion //Utility functions

		#region Abstract interfaces
		

		// ISchemaTypeCalendar
		public abstract ECalendarTypes CalendarType();
		public abstract SchemaDateTime DateTimeValue();
		public abstract SchemaDate DateValue();
		public abstract SchemaTime TimeValue();
		// System.ICloneable
		public abstract object Clone();
		#endregion //Abstract interfaces

	}

	/// <summary>
	/// Common base-class for all schema-types containing binary values
	/// </summary>
	public abstract class SchemaBinaryBase : ISchemaTypeBinary
	{
		protected byte[] myValue;
		protected bool isEmpty;
		protected bool isNull;

		#region Constructors
		public SchemaBinaryBase() 
		{
			isEmpty = true;
			isNull = false;
		}

		public SchemaBinaryBase(SchemaBinaryBase obj)
		{
			myValue = obj.myValue;
			isEmpty = obj.isEmpty;
			isNull = obj.isNull;
		}

		public SchemaBinaryBase(byte[] newvalue)
		{
			myValue = newvalue;
			isEmpty = false;
			isNull = false;
		}





		#endregion //Constructors

		#region Get, Set
		public byte[] Value
		{
			get
			{
				return myValue;
			}
			set
			{
				myValue = value;
				isEmpty = false;
			}
		}

		public void Assign( ISchemaType newvalue )
		{
			if( newvalue == null )
			{
				SetNull(true);
				SetEmpty(true);
				return;
			}

			if( newvalue.IsEmpty() )
			{
				SetEmpty(true);
				SetNull(newvalue.IsNull());
				return;
			}

			if( newvalue is SchemaBinaryBase )
			{
				SchemaBinaryBase obj = ((SchemaBinaryBase)newvalue);
				myValue = obj.Value;
				isEmpty = obj.IsEmpty();
			}
			else 
			{
				try
				{
					Parse( newvalue.ToString() );
				}
				catch (StringParseException)
				{
					throw new TypesIncompatibleException( newvalue, this );
				}
			}
		}

		#endregion //Get, Set

		#region implemented Interfaces
		// System.IComparable
		public override bool Equals(object obj) 
		{
			if (! (obj is SchemaBinaryBase))
				return false;
			SchemaBinaryBase data = (SchemaBinaryBase)obj;
			if( myValue.Length != data.Value.Length )
				return false;
			for( long l = 0; l < myValue.Length; l++ )
				if( myValue[l] != data.Value[l] )
					return false;
			return true;
		}

		public override int GetHashCode()
		{
			if( myValue.Length > 0 )
				return myValue[0].GetHashCode();
			return 1243;
		}

		public int CompareTo(object obj)
		{
			return CompareTo( (SchemaBinaryBase)obj );
		}

		public int CompareTo(SchemaBinaryBase obj)
		{
			long l = 0;
			while( l < myValue.Length && l < obj.Value.Length && myValue[l]==obj.Value[l] )
				l++;
			if( l < myValue.Length && l < obj.Value.Length )
				return myValue[l].CompareTo( obj.Value[l] );
			return myValue.Length.CompareTo( obj.Value.Length );
		}



		// ISchemaType
		public bool BoolValue() 
		{
			return true;
		}

		public bool IsEmpty() 
		{
			return isEmpty;
		}

		public void SetEmpty( bool bIsEmpty )
		{
			isEmpty = bIsEmpty;
		}

		public bool IsNull()
		{
			return isNull;
		}

		public void SetNull( bool bIsNull )
		{
			isNull = bIsNull;
		}

		#endregion //Implemented interfaces

		#region Abstract interfaces
		public abstract void Parse( string newvalue );

		// ISchemaTypeBinary
		public abstract EBinaryTypes BinaryType();

		// System.ICloneable
		public abstract object Clone();
		#endregion //Abstract interfaces
	}
	#endregion //Base classes
	class FormatSpecifiers
	{
		public readonly static string DecimalNumberFormat= "###############################0.#############################";
	}
	#region Schema types
	public class SchemaBoolean : ISchemaTypeNumber
	{
		protected bool myValue = false;
		protected bool isEmpty = true;
		protected bool isNull = true;

		#region Constructors
		public SchemaBoolean()
		{
			isNull = false;
		}

		public SchemaBoolean(SchemaBoolean obj)
		{
			myValue = obj.Value;
			isEmpty = obj.isEmpty;
			isNull = obj.isNull;
		}

		public SchemaBoolean(bool newvalue)
		{
			this.myValue = newvalue;
			this.isEmpty = false;
			this.isNull = false;
		}

		public SchemaBoolean(string newvalue)
		{
			Parse( newvalue );
		}
		public SchemaBoolean(ISchemaType newvalue)
		{
			Assign(newvalue);
		}


		#endregion //Constructors

		#region Get, Set
		public bool Value
		{
			get
			{
				return myValue;
			}
			set
			{
				myValue = value;
				isEmpty = false;
				isNull = false;
			}
		}

		public void Parse( string s )
		{
			string newvalue = SchemaString.normalize(SchemaString.WhitespaceFacet.Collapse, s);
			if( newvalue == null ) 
			{
				isEmpty = true;
				myValue = false;
				isNull = true;
				return;
			}
			if( newvalue.Length > 0 )
			{
				myValue = new SchemaString(newvalue).BoolValue();
				isEmpty = false;
				isNull = false;
			}
			else
			{
				isEmpty = true;
				isNull = false;
			}
		}

		public void Assign( ISchemaType newvalue )
		{
			if( newvalue == null )
			{
				SetNull(true);
				SetEmpty(true);
				return;
			}

			if( newvalue.IsEmpty() )
			{
				SetEmpty(true);
				SetNull( newvalue.IsNull() );
				return;
			}

			Parse(newvalue.ToString());
		}
		#endregion //Get, Set

		public override string ToString()
		{
			if( isEmpty )
				return "";
			return Value ? "true" : "false";	// when converting to an string-value, than XML-Schema would expect "" for false.
		}


		#region Implemented interfaces
		// System.IComparable
		public override int GetHashCode()
		{
			return Value ? 1231 : 1237;
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
				return false;
			if (!(obj is SchemaBoolean))
				return false;
			return Value == ((SchemaBoolean)obj).Value;
		}

		public static bool operator==(SchemaBoolean obj1, SchemaBoolean obj2)
		{
			if ((null==(object) obj1) && (null==(object) obj2)) return true;
			if ((null==(object) obj1) || (null==(object) obj2)) return false;
			return obj1.BoolValue() == obj2.BoolValue();
		}

		public static bool operator!=(SchemaBoolean obj1, SchemaBoolean obj2)
		{
			if ((null==(object) obj1) && (null==(object) obj2)) return false;
			if ((null==(object) obj1) || (null==(object) obj2)) return true;
			return obj1.BoolValue() != obj2.BoolValue();
		}

		public int CompareTo(object obj)
		{
			return Value.CompareTo(((SchemaBoolean)obj).Value);
		}

		// System.ICloneable
		public object Clone()
		{
			return new SchemaBoolean(Value);
		}
		// ISchemaType
		public bool IsEmpty()
		{
			return isEmpty;
		}

		public void SetEmpty( bool bIsEmpty )
		{
			isEmpty = bIsEmpty;
			if( bIsEmpty )
			{
				myValue = false;
			}
			else
			{
				isNull = false;
			}
		}

		public bool IsNull()
		{
			return isNull;
		}

		public void SetNull( bool bIsNull )
		{
			isNull = bIsNull;
			if( bIsNull )
				SetEmpty(true);
		}
		
		public bool BoolValue()
		{
			return myValue;
		}


		// ISchemaTypeNumber
		public ENumericTypes NumericType()
		{
			return ENumericTypes.ValueInt;
		}

		public int IntValue()
		{
			return myValue ? 1 : 0;
		}

		public long LongValue()
		{
			return myValue ? 1 : 0;
		}

		public double DoubleValue()
		{
			return myValue ? 1.0 : 0;
		}

		public decimal DecimalValue()
		{
			return myValue ? (decimal)1 : (decimal)0;
		}

		#endregion //Implemented interfaces
	}

	public class SchemaInt : ISchemaTypeNumber
	{
		protected int myValue = 0;
		protected bool isEmpty = true;
		protected bool isNull = true;

		#region Constructors
		public SchemaInt()
		{
			isNull = false;
		}

		public SchemaInt(SchemaInt obj)
		{
			myValue = obj.myValue;
			isEmpty = obj.isEmpty;
			isNull = obj.isNull;
		}

		public SchemaInt(int newvalue)
		{
			myValue = newvalue;
			isEmpty = false;
			isNull = false;
		}

		public SchemaInt(string newvalue)
		{
			Parse( newvalue );
		}

		public SchemaInt(ISchemaType newvalue)
		{
			Assign( newvalue );
		}



		#endregion //Constructors

		public override string ToString()
		{
			if( isEmpty )
				return "";
			return myValue.ToString();
		}


		#region Get, Set
		public int Value
		{
			get
			{
				return myValue;
			}
			set
			{
				myValue = value;
				isEmpty = false;
				isNull = false;
			}
		}

		public void Parse( string s )
		{
			string newvalue = SchemaString.normalize(SchemaString.WhitespaceFacet.Collapse, s);
			if( newvalue == null  || newvalue == "" )
			{
				myValue = 0;
				isEmpty = true;
				isNull = true;
				return;
			}
			try
			{
				myValue = Convert.ToInt32(newvalue);
				isEmpty = false;
				isNull = false;
			}
			catch( FormatException e )
			{
				throw new StringParseException(e);
			}
		}

		public void Assign( ISchemaType newvalue )
		{
			if( newvalue == null )
			{
				SetNull( true );
				SetEmpty( true );
				return;
			}
			if( newvalue.IsEmpty() )
			{
				SetEmpty( true );
				SetNull( newvalue.IsNull() );
				return;
			}

			if( newvalue is ISchemaTypeNumber )
			{
				isEmpty = false;
				isNull = false;
				myValue = ((ISchemaTypeNumber)newvalue).IntValue();
			}
			else
				throw new TypesIncompatibleException(newvalue, this);
		}

		#endregion //Get, Set

		#region Implemented interfaces
		// System.IComparable
		public override int GetHashCode()
		{
			return Value;
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
				return false;
			if (!(obj is SchemaInt))
				return false;
			return Value == ((SchemaInt)obj).Value;
		}

		public static bool operator==(SchemaInt obj1, SchemaInt obj2)
		{
			if ((null==(object) obj1) && (null==(object) obj2)) return true;
			if ((null==(object) obj1) || (null==(object) obj2)) return false;
			return obj1.Value == obj2.Value;
		}

		public static bool operator!=(SchemaInt obj1, SchemaInt obj2)
		{
			if ((null==(object) obj1) && (null==(object) obj2)) return false;
			if ((null==(object) obj1) || (null==(object) obj2)) return true;
			return obj1.Value != obj2.Value;
		}

		public int CompareTo(object obj)
		{
			return Value.CompareTo(((SchemaInt)obj).Value);
		}

		// System.ICloneable
		public object Clone()
		{
			return new SchemaInt(Value);
		}
		// ISchemaType
		public bool BoolValue()
		{
			return myValue != 0;
		}

		public bool IsEmpty()
		{
			return isEmpty;
		}

		public void SetEmpty( bool bIsEmpty )
		{
			isEmpty = bIsEmpty;
			if( bIsEmpty )
				myValue = 0;
		}

		public bool IsNull()
		{
			return isNull;
		}

		public void SetNull( bool bIsNull )
		{
			isNull = bIsNull;
			if( bIsNull )
				SetEmpty( true );
		}
		

		// ISchemaTypeNumber
		public ENumericTypes NumericType()
		{
			return ENumericTypes.ValueInt;
		}

		public int IntValue()
		{
			return myValue;
		}

		public long LongValue()
		{
			return myValue;
		}

		public double DoubleValue()
		{
			return myValue;
		}

		public decimal DecimalValue()
		{
			return myValue;
		}

		#endregion //Implemented interfaces
	}

	public class SchemaLong : ISchemaTypeNumber
	{
		protected long myValue = 0;
		protected bool isEmpty = true;
		protected bool isNull = true;

		#region Constructors
		public SchemaLong()
		{
			isNull = false;
		}

		public SchemaLong(SchemaLong obj)
		{
			myValue = obj.myValue;
			isEmpty = obj.isEmpty;
			isNull = obj.isNull;
		}

		public SchemaLong(long newvalue)
		{
			myValue = newvalue;
			isEmpty = false;
			isNull = false;
		}

		public SchemaLong(string newvalue)
		{
			Parse( newvalue );
		}

		public SchemaLong(ISchemaType newvalue)
		{
			Assign( newvalue );
		}



		#endregion //Constructors

		#region Get, Set
		public long Value
		{
			get
			{
				return myValue;
			}
			set
			{
				myValue = value;
				isEmpty = false;
				isNull = false;
			}
		}

		public void Parse( string s )
		{
			string newvalue = SchemaString.normalize(SchemaString.WhitespaceFacet.Collapse, s);
			if( newvalue == null  || newvalue == "" )
			{
				myValue = 0;
				isEmpty = true;
				isNull = true;
				return;
			}
			try
			{
				myValue = Convert.ToInt64(newvalue);
				isEmpty = false;
				isNull = false;
			}
			catch(FormatException e)
			{
				throw new StringParseException(e);
			}
		}

		public void Assign( ISchemaType newvalue )
		{
			if( newvalue == null )
			{
				SetNull( true );
				SetEmpty( true );
				return;
			}

			if( newvalue.IsEmpty() )
			{
				myValue = 0;
				SetNull( newvalue.IsNull() );
				SetEmpty( true );
				return;
			}
			if( newvalue is ISchemaTypeNumber )
			{
				isEmpty = false;
				isNull = false;
				myValue = ((ISchemaTypeNumber)newvalue).LongValue();
			}
			else
				throw new TypesIncompatibleException(newvalue, this);
		}

		#endregion // Get, Set

		public override string ToString()
		{
			if( isEmpty )
				return "";
			return myValue.ToString();
		}

		#region Implemented interfaces
		// System.IComparable
		public override int GetHashCode()
		{
			return (int)Value;
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
				return false;
			if (!(obj is SchemaLong))
				return false;
			return Value == ((SchemaLong)obj).Value;
		}

		public static bool operator==(SchemaLong obj1, SchemaLong obj2)
		{
			if ((null==(object) obj1) && (null==(object) obj2)) return true;
			if ((null==(object) obj1) || (null==(object) obj2)) return false;
			return obj1.Value == obj2.Value;
		}

		public static bool operator!=(SchemaLong obj1, SchemaLong obj2)
		{
			if ((null==(object) obj1) && (null==(object) obj2)) return false;
			if ((null==(object) obj1) || (null==(object) obj2)) return true;
			return obj1.Value != obj2.Value;
		}

		public int CompareTo(object obj)
		{
			return Value.CompareTo(((SchemaLong)obj).Value);
		}

		// System.ICloneable
		public object Clone()
		{
			return new SchemaLong(Value);
		}

		// ISchemaType
		public bool BoolValue()
		{
			return myValue != 0;
		}

		public bool IsEmpty()
		{
			return isEmpty;
		}

		public void SetEmpty( bool bIsEmpty )
		{
			isEmpty = bIsEmpty;
			if( bIsEmpty )
				myValue = 0;
		}

		public bool IsNull()
		{
			return isNull;
		}

		public void SetNull( bool bIsNull )
		{
			isNull = bIsNull;
			if( bIsNull )
				SetEmpty( true );
		}
		

		// ISchemaTypeNumber
		public ENumericTypes NumericType()
		{
			return ENumericTypes.ValueLong;
		}

		public int IntValue()
		{
			return (int)myValue;
		}

		public long LongValue()
		{
			return myValue;
		}

		public double DoubleValue()
		{
			return myValue;
		}

		public decimal DecimalValue()
		{
			return myValue;
		}

		#endregion // Implemented interfaces
	}

	public class SchemaDouble : ISchemaTypeNumber
	{
		protected double myValue = 0.0;
		protected bool isEmpty = true;
		protected bool isNull = true;

		#region Constructors
		public SchemaDouble()
		{
			isNull = false;
		}

		public SchemaDouble(SchemaDouble obj)
		{
			myValue = obj.myValue;
			isEmpty = obj.isEmpty;
			isNull = obj.isNull;
		}

		public SchemaDouble(double newvalue)
		{
			myValue = (double)newvalue;
			isEmpty = false;
			isNull = false;
		}

		public SchemaDouble(int newvalue)
		{
			myValue = (double)newvalue;
			isEmpty = false;
			isNull = false;
		}

		public SchemaDouble(string newvalue)
		{
			Parse(newvalue);
		}

		public SchemaDouble(ISchemaType obj)
		{
			Assign( obj );
		}


		#endregion //Constructors

		#region Get, Set
		public double Value
		{
			get
			{
				return myValue;
			}
			set
			{
				myValue = value;
				isEmpty = false;
				isNull = false;
			}
		}

		public void Parse( string s )
		{
			string newvalue = SchemaString.normalize(SchemaString.WhitespaceFacet.Collapse, s);
			if( newvalue == null  ||  newvalue == "" )
			{
				myValue = 0;
				isEmpty = true;
				isNull = true;
				return;
			}
			try
			{
				myValue = Convert.ToDouble(newvalue, CultureInfo.InvariantCulture );
				isEmpty = false;
				isNull = false;
			}
			catch( FormatException e )
			{
				throw new StringParseException(e);
			}
		}

		public void Assign( ISchemaType newvalue )
		{
			if( newvalue == null )
			{
				SetNull(true);
				SetEmpty(true);
				return;
			}

			if( newvalue.IsEmpty() )
			{
				myValue = 0;
				isEmpty = true;
				SetNull( newvalue.IsNull() );

				return;
			}

			if( newvalue is ISchemaTypeNumber )
			{
				isEmpty = false;
				isNull = false;
				myValue = ((ISchemaTypeNumber)newvalue).DoubleValue();
			}
			else
				throw new TypesIncompatibleException(newvalue, this);
		}

		#endregion // Get, Set

		public override string ToString()
		{
			if( isEmpty )
				return "";
			return myValue.ToString(FormatSpecifiers.DecimalNumberFormat, CultureInfo.InvariantCulture);
		}

		#region Implemented interfaces
		// System.IComparable
		public override int GetHashCode()
		{
			return myValue.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
				return false;
			if (!(obj is SchemaDouble))
				return false;
			return Value == ((SchemaDouble)obj).Value;
		}

		public static bool operator==(SchemaDouble obj1, SchemaDouble obj2)
		{
			if ((null==(object) obj1) && (null==(object) obj2)) return true;
			if ((null==(object) obj1) || (null==(object) obj2)) return false;
			return obj1.Value == obj2.Value;
		}

		public static bool operator!=(SchemaDouble obj1, SchemaDouble obj2)
		{
			if ((null==(object) obj1) && (null==(object) obj2)) return false;
			if ((null==(object) obj1) || (null==(object) obj2)) return true;
			return obj1.Value != obj2.Value;
		}

		public int CompareTo(object obj)
		{
			return Value.CompareTo(((SchemaDouble)obj).Value);
		}

		// System.ICloneable
		public object Clone()
		{
			return new SchemaDouble(Value);
		}

		// ISchemaType
		public bool BoolValue()
		{
			return myValue != 0.0;
		}

		public bool IsEmpty()
		{
			return isEmpty;
		}

		public void SetEmpty( bool bIsEmpty )
		{
			isEmpty = bIsEmpty;
			if( bIsEmpty )
				myValue = 0.0;
		}

		public bool IsNull()
		{
			return isNull;
		}

		public void SetNull( bool bIsNull )
		{
			isNull = bIsNull;
			if( bIsNull )
				SetEmpty( true );
		}
		

		// ISchemaTypeNumber
		public ENumericTypes NumericType()
		{
			return ENumericTypes.ValueDouble;
		}

		public int IntValue()
		{
			return (int)myValue;
		}

		public long LongValue()
		{
			return (long)myValue;
		}

		public double DoubleValue()
		{
			return myValue;
		}

		public decimal DecimalValue()
		{
			return Convert.ToDecimal(myValue, CultureInfo.InvariantCulture);
		}

		#endregion // Implemented interfaces
	}

	public class SchemaDecimal : ISchemaTypeNumber
	{
		protected decimal myValue = 0M;
		protected bool isEmpty = true;
		protected bool isNull = true;

		#region Constructors
		public SchemaDecimal()
		{
			isNull = false;
		}

		public SchemaDecimal(SchemaDecimal obj)
		{
			myValue = obj.myValue;
			isEmpty = obj.isEmpty;
			isNull = obj.isNull;
		}

		public SchemaDecimal(decimal newvalue)
		{
			myValue = newvalue;
			isEmpty = false;
			isNull = false;
		}

		public SchemaDecimal(double newvalue)
		{
			myValue = (decimal)newvalue;
			isEmpty = false;
			isNull = false;
		}

		public SchemaDecimal(int newvalue)
		{
			myValue = (decimal)newvalue;
			isEmpty = false;
			isNull = false;
		}

		public SchemaDecimal(string newvalue)
		{
			Parse(newvalue);
		}

		public SchemaDecimal(ISchemaType obj)
		{
			Assign( obj );
		}

		#endregion //Constructors

		#region Get, Set
		public decimal Value
		{
			get
			{
				return myValue;
			}
			set
			{
				myValue = value;
				isEmpty = false;
				isNull = false;
			}
		}

		public void Parse( string s )
		{
			string newvalue = SchemaString.normalize(SchemaString.WhitespaceFacet.Collapse, s);
			if( newvalue == null  ||  newvalue == "" )
			{
				myValue = 0;
				isEmpty = true;
				isNull = (newvalue == null);
				return;
			}
			try
			{
				myValue = Convert.ToDecimal(newvalue, CultureInfo.InvariantCulture);
				isEmpty = false;
				isNull = false;
			}
			catch( FormatException e )
			{
				throw new StringParseException(e);
			}
		}

		public void Assign( ISchemaType newvalue )
		{
			if( newvalue == null )
			{
				SetNull(true);
				SetEmpty(true);
				return;
			}

			if( newvalue.IsEmpty() )
			{
				myValue = 0;
				isEmpty = true;
				SetNull( newvalue.IsNull() );
				return;
			}
			if( newvalue is ISchemaTypeNumber )
			{
				isEmpty = false;
				isNull = false;
				myValue = ((ISchemaTypeNumber)newvalue).DecimalValue();
			}
			else
				throw new TypesIncompatibleException(newvalue, this);
		}

		#endregion // Get, Set

		public override string ToString()
		{
			if( isEmpty )
				return "";
			return myValue.ToString(FormatSpecifiers.DecimalNumberFormat, CultureInfo.InvariantCulture);
		}

		#region Implemented interfaces
		// System.IComparable
		public override int GetHashCode()
		{
			return Value.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
				return false;
			if (!(obj is SchemaDecimal))
				return false;
			return Value == ((SchemaDecimal)obj).Value;
		}

		public static bool operator==(SchemaDecimal obj1, SchemaDecimal obj2)
		{
			if ((null==(object) obj1) && (null==(object) obj2)) return true;
			if ((null==(object) obj1) || (null==(object) obj2)) return false;
			return obj1.Value == obj2.Value;
		}

		public static bool operator!=(SchemaDecimal obj1, SchemaDecimal obj2)
		{
			if ((null==(object) obj1) && (null==(object) obj2)) return false;
			if ((null==(object) obj1) || (null==(object) obj2)) return true;
			return obj1.Value != obj2.Value;
		}

		public int CompareTo(object obj)
		{
			return Value.CompareTo(((SchemaDecimal)obj).Value);
		}

		// System.ICloneable
		public object Clone()
		{
			return new SchemaDecimal(Value);
		}

		// ISchemaType
		public bool BoolValue()
		{
			return myValue != 0M;
		}

		public bool IsEmpty()
		{
			return isEmpty;
		}

		public void SetEmpty( bool bIsEmpty )
		{
			isEmpty = bIsEmpty;
			if( bIsEmpty )
				myValue = 0M;
		}

		public bool IsNull()
		{
			return isNull;
		}

		public void SetNull( bool bIsNull )
		{
			isNull = bIsNull;
			if( bIsNull )
				SetEmpty( true );
		}
		

		// ISchemaTypeNumber
		public ENumericTypes NumericType()
		{
			return ENumericTypes.ValueDecimal;
		}

		public int IntValue()
		{
			return (int)myValue;
		}

		public long LongValue()
		{
			return (long)myValue;
		}

		public double DoubleValue()
		{
			return Convert.ToDouble(myValue);
		}

		public decimal DecimalValue()
		{
			return myValue;
		}

		#endregion // Implemented interfaces
	}

	public class SchemaDateTime : SchemaCalendarBase
	{
		#region Constructors
		public SchemaDateTime()
			: base()
		{
		}

		public SchemaDateTime(SchemaDateTime obj)
			: base( (SchemaCalendarBase)obj )
		{
		}

		public SchemaDateTime(System.DateTime Value)
			: base( Value )
		{
		}

		public SchemaDateTime(int newyear, int newmonth, int newday, int newhour, int newminute, int newsecond, double newpartsecond, int newoffsetTZ )
		{
			myValue = new System.DateTime(newyear, newmonth, newday, newhour, newminute, newsecond, (int)(newpartsecond * 1000.0));
			eTZ =  ETZ.Offset;
			offsetTZ = newoffsetTZ;
			isEmpty = false;
			isNull = false;
		}
		
		public SchemaDateTime(int newyear, int newweek, int newhour, int newminute, int newsecond, double newpartsecond)
        {
            myValue = new System.DateTime();
            myValue = myValue.AddYears(newyear - 1);
            myValue = myValue.AddDays(newweek * 7);
            myValue = myValue.AddHours(newhour);
            myValue = myValue.AddMinutes(newminute);
            myValue = myValue.AddSeconds(newsecond);
            myValue = myValue.AddMilliseconds(newpartsecond);
            eTZ = ETZ.Missing;
            offsetTZ = 0;
            isEmpty = false;
            isNull = false;
        }

		public SchemaDateTime(int newyear, int newmonth, int newday, int newhour, int newminute, int newsecond, double newpartsecond )
		{
			// allows to pass values outside range
			myValue = new System.DateTime();
			myValue = myValue.AddYears(newyear - 1);
			myValue = myValue.AddMonths(newmonth - 1);
			myValue = myValue.AddDays(newday - 1);
			myValue = myValue.AddHours(newhour);
			myValue = myValue.AddMinutes(newminute);
			myValue = myValue.AddSeconds(newsecond);
			myValue = myValue.AddMilliseconds((int)(newpartsecond * 1000.0));
			eTZ = ETZ.Missing;
			offsetTZ = 0;
			isEmpty = false;
			isNull = false;
		}

		public SchemaDateTime(int newyear, int newmonth, int newday)
		{
			myValue = new System.DateTime(newyear, newmonth, newday);
			eTZ = ETZ.Missing;
			offsetTZ = 0;
			isEmpty = false;
			isNull = false;
		}

		public SchemaDateTime(string newvalue)
		{
			Parse( newvalue );
		}

		public SchemaDateTime(ISchemaType obj)
		{
			Assign( obj );
		}

		#endregion //Constructors;

		#region Get, Set
		public void Parse( string s )
		{
			string newvalue = SchemaString.normalize(SchemaString.WhitespaceFacet.Collapse, s);
			if ( newvalue == null ) 
			{
				isEmpty = true;
				isNull = true;
				return;
			}
			else if ( newvalue.Length == 0 )
			{
				isEmpty = true;
				isNull = false;
				return;
			}				

			if (!ParseDateTime(newvalue, DateTimePart.Date|DateTimePart.Time))
				throw new StringParseException(newvalue + " cannot be converted to a dateTime value");
			isEmpty = false;
			isNull = false;
		}

		public void Assign( ISchemaType newvalue )
		{
			if( newvalue == null )
			{
				SetNull(true);
				SetEmpty(true);
				return;
			}

			if( newvalue.IsEmpty() ) 
			{
				Value = System.DateTime.Now; // actual date and time
				isEmpty = true;
				SetNull( newvalue.IsNull() );
				return;
			}
			if( newvalue is SchemaDateTime )
			{
				SchemaDateTime dt = ((SchemaDateTime)newvalue);
				myValue = dt.myValue;
				eTZ = dt.eTZ;
				offsetTZ = dt.offsetTZ;
				isEmpty = dt.isEmpty;
				isNull = dt.isNull;
			}
			else if( newvalue is SchemaDate )
			{
				System.DateTime dt = ((SchemaDate)newvalue).Value;
				myValue = new System.DateTime( dt.Year, dt.Month, dt.Day, 0, 0, 0);
				eTZ = ETZ.Missing;
				offsetTZ = 0;
				isEmpty = newvalue.IsEmpty();
				isNull = newvalue.IsNull();
			}
			else 
			{
				try
				{
					Parse( newvalue.ToString() );
				}
				catch (StringParseException)
				{
					throw new TypesIncompatibleException( newvalue, this );
				}
			}
		}

		#endregion // Get, Set

		public override string ToString()
		{
			if( isEmpty )
				return "";
			return ToDateString() + "T" + ToTimeString();
		}

		public static SchemaDateTime Now
		{
			get
			{
				return new SchemaDateTime( System.DateTime.Now );
			}
		}

		#region Implemented interfaces
		// ISchemaType

		// System.ICloneable
		public override object Clone()
		{
			return new SchemaDateTime(this);
		}

		// SchemaCalendarBase
		public override ECalendarTypes CalendarType()
		{
			return ECalendarTypes.DateTime;
		}

		public override SchemaDateTime DateTimeValue()
		{
			return (SchemaDateTime)Clone();
		}

		public override SchemaDate DateValue()
		{
			if ( isNull )
			{
				SchemaDate	result = new SchemaDate();
				result.SetNull( true );
				return result;
			}
			else if ( isEmpty )
				return new SchemaDate();
			else
				return new SchemaDate( myValue.Year, myValue.Month, myValue.Day );
		}

		public override SchemaTime TimeValue()
		{
			if ( isNull )
			{
				SchemaTime	result = new SchemaTime();
				result.SetNull( true );
				return result;
			}
			else if ( isEmpty )
				return new SchemaTime();
			else if( eTZ == ETZ.Offset )
				return new SchemaTime( myValue.Hour, myValue.Minute, myValue.Second, (double)myValue.Millisecond / 1000.0, offsetTZ );
			else
				return new SchemaTime( myValue.Hour, myValue.Minute, myValue.Second, (double)myValue.Millisecond / 1000.0 );
		}


		#endregion Implemented interfaces
	}

	public class SchemaDate : SchemaCalendarBase
	{
		#region Constructors
		public SchemaDate()
			: base()
		{
			myValue = new System.DateTime(myValue.Year, myValue.Month, myValue.Day);	// set time to 0
		}

		public SchemaDate( SchemaDate obj )
			: base( (SchemaCalendarBase)obj )
		{
			myValue = new System.DateTime(myValue.Year, myValue.Month, myValue.Day);	// set time to 0
		}

		public SchemaDate( System.DateTime newvalue )
			: base( newvalue.Year, newvalue.Month, newvalue.Day, 0,0,0,0.0, false, 0 )
		{
		}

		public SchemaDate(int newyear, int newmonth, int newday)
			: base( newyear, newmonth, newday, 0,0,0,0.0, false, 0 )
		{
			isEmpty = false;
			isNull = false;
		}

		public SchemaDate(string newvalue)
		{
			Parse( newvalue );
		}

		public SchemaDate(ISchemaType obj)
		{
			Assign( obj );
		}

		#endregion // Constructors

		#region Get, Set
		public void Parse( string s )
		{
			string newvalue = SchemaString.normalize(SchemaString.WhitespaceFacet.Collapse, s);
			if( newvalue==null )
			{
				Reset();
				isEmpty = true;
				isNull = true;
				return;
			} 
			else if ( newvalue.Length == 0 )
			{
				Reset();
				isEmpty = true;
				isNull = false;
				return;
			}
			if (!ParseDateTime( newvalue, DateTimePart.Date ))
				throw new StringParseException(newvalue + " cannot be converted to a date value");
			isEmpty = false;
			isNull = false;
		}

		public void Assign( ISchemaType newvalue )
		{
			if( newvalue == null )
			{
				SetNull(true);
				SetEmpty(true);
				return;
			}

			if( newvalue.IsEmpty() ) 
			{
				Reset();
				isEmpty = true;
				SetNull( newvalue.IsNull() );
				return;
			}
			isEmpty = false;
			isNull = false;
			if( newvalue is SchemaDate ) 
			{
				System.DateTime dt = ((SchemaDate)newvalue).Value;
				myValue = new System.DateTime( dt.Year, dt.Month, dt.Day );
				eTZ = ETZ.Missing;
				offsetTZ = 0;
			}
			else if( newvalue is SchemaDateTime ) 
			{
				System.DateTime dt = ((SchemaDateTime)newvalue).Value;
				myValue = new System.DateTime( dt.Year, dt.Month, dt.Day );
				eTZ = ETZ.Missing;
				offsetTZ = 0;
			}
			else if( newvalue is SchemaString ) 
			{
				Parse( newvalue.ToString() );
			}
			else 
			{
				try
				{
					Parse( newvalue.ToString() );
				}
				catch (StringParseException)
				{
					throw new TypesIncompatibleException( newvalue, this );
				}
			}
		}

		#endregion // Get, Set

		public override string ToString()
		{
			if( isEmpty )
				return "";
			return ToDateString();
		}

		public static SchemaDate Now
		{
			get
			{
				System.DateTime d = System.DateTime.Now;
				return new SchemaDate( d.Year, d.Month, d.Second );
			}
		}

		#region Implemented interfaces
		// ISchemaType

		// System.ICloneable
		public override object Clone()
		{
			return new SchemaDate(this);
		}

		// SchemaCalendarBase
		public override ECalendarTypes CalendarType()
		{
			return ECalendarTypes.Date;
		}

		public override SchemaDateTime DateTimeValue()
		{
			if ( isNull )
			{
				SchemaDateTime	result = new SchemaDateTime();
				result.SetNull( true );
				return result;
			}
			else if ( isEmpty )
				return new SchemaDateTime();
			else
				return new SchemaDateTime( myValue.Year, myValue.Month, myValue.Day);
		}

		public override SchemaDate DateValue()
		{
			return (SchemaDate)Clone();
		}

		public override SchemaTime TimeValue()
		{
			throw new TypesIncompatibleException(this, new SchemaTime());
		}

		#endregion //Implemented interfaces
	}

	public class SchemaTime : SchemaCalendarBase
	{
		#region Constructors
		public SchemaTime()
			: base()
		{
		}

		public SchemaTime(SchemaTime obj)
			: base( obj )
		{
		}

		public SchemaTime(System.DateTime newvalue)
			: base( newvalue )
		{
		}

		public SchemaTime(int newhour, int newminute, int newsecond, double newpartsecond, int newoffsetTZ)
		{
			System.DateTime dt = System.DateTime.Now;
			myValue = new System.DateTime( dt.Year, dt.Month, dt.Day, newhour, newminute, newsecond, (int)(newpartsecond*100.0));
			eTZ = ETZ.Offset;
			offsetTZ = newoffsetTZ;
			isEmpty = false;
		}

		public SchemaTime(int newhour, int newminute, int newsecond, double newpartsecond)
		{
			System.DateTime dt = System.DateTime.Now;
			myValue = new System.DateTime( dt.Year, dt.Month, dt.Day, newhour, newminute, newsecond, (int)(newpartsecond*100.0));
			eTZ = ETZ.Missing;
			offsetTZ = 0;
			isEmpty = false;
		}

		public SchemaTime(int newhour, int newminute, int newsecond)
		{
			System.DateTime dt = System.DateTime.Now;
			myValue = new System.DateTime( dt.Year, dt.Month, dt.Day, newhour, newminute, newsecond);
			eTZ = ETZ.Missing;
			offsetTZ = 0;
			isEmpty = false;
		}

		public SchemaTime(string newvalue)
		{
			Parse( newvalue );
		}

		public SchemaTime( ISchemaType obj )
		{
			Assign( obj );
		}


		#endregion //Constructors

		#region Get, Set
		public void Parse( string s )
		{
			string newvalue = SchemaString.normalize(SchemaString.WhitespaceFacet.Collapse, s);
			if( newvalue == null )
			{
				Reset();
				isEmpty = true;
				isNull = true;
				return;
			}
			else if ( newvalue.Length == 0 )
			{
				Reset();
				isEmpty = true;
				isNull = false;
				return;
			}
			if (!ParseDateTime( newvalue, DateTimePart.Time ))
				throw new StringParseException(newvalue + " cannot be converted to a time value");
			isEmpty = false;
			isNull = false;
		}

		public void Assign( ISchemaType newvalue )
		{
			if( newvalue == null )
			{
				SetEmpty(true);
				SetNull(true);
				return;
			}

			if( newvalue.IsEmpty() )
			{
				Reset();
				SetEmpty(true);
				SetNull(newvalue.IsNull());
				return;
			}
			isEmpty = false;
			isNull = false;
			if( newvalue is SchemaDateTime )
			{
				System.DateTime dtNow = System.DateTime.Now;
				System.DateTime dt = ((SchemaDateTime)newvalue).Value;
				myValue = new System.DateTime( dtNow.Year, dtNow.Month, dtNow.Day, dt.Hour, dt.Minute, dt.Second, dt.Millisecond );
				eTZ = ((SchemaDateTime)newvalue).HasTimezone;
				offsetTZ = ((SchemaDateTime)newvalue).TimezoneOffset;	
			}
			else if( newvalue is SchemaTime )
			{
				System.DateTime dtNow = System.DateTime.Now;
				System.DateTime dt = ((SchemaTime)newvalue).Value;
				myValue = new System.DateTime( dtNow.Year, dtNow.Month, dtNow.Day, dt.Hour, dt.Minute, dt.Second, dt.Millisecond );
				eTZ = ((SchemaTime)newvalue).HasTimezone;
				offsetTZ = ((SchemaTime)newvalue).offsetTZ;
			}
			else if( newvalue is SchemaString )
				Parse( newvalue.ToString() );
			else 
			{
				try
				{
					Parse( newvalue.ToString() );
				}
				catch (StringParseException)
				{
					throw new TypesIncompatibleException( newvalue, this );
				}
			}
		}
		#endregion // Get, Set

		public override string ToString()
		{
			if( isEmpty )
				return "";
			return ToTimeString();
		}

		public static SchemaTime Now
		{
			get
			{
				System.DateTime t = System.DateTime.Now;
				return new SchemaTime(t.Hour, t.Minute, t.Second, t.Millisecond * 1000.0);
			}
		}

		#region Implemented interfaces
		// ISchemaType

		// System.ICloneable
		public override object Clone()
		{
			return new SchemaTime(this);
		}
	
		// SchemaCalendarBase
		public override ECalendarTypes CalendarType()
		{
			return ECalendarTypes.Time;
		}

		public override SchemaDateTime DateTimeValue()
		{
			throw new TypesIncompatibleException(this, new SchemaDateTime());
		}

		public override SchemaDate DateValue()
		{
			throw new TypesIncompatibleException(this, new SchemaDateTime());
		}

		public override SchemaTime TimeValue()
		{
			return (SchemaTime)Clone();
		}

		#endregion //Implemented interfaces
	}

	public class SchemaDuration : ISchemaTypeCalendar
	{
		protected TimeSpan myValue = new TimeSpan(0);
		protected int months = 0;
		protected int years = 0;
		protected bool isEmpty = true;
		protected bool isNull = true;

		#region Constructors
		public SchemaDuration()
		{
			isNull = false;
		}

		public SchemaDuration(SchemaDuration obj)
		{
			myValue = obj.myValue;
			months = obj.months;
			years = obj.years;
			isEmpty = obj.isEmpty;
			isNull = obj.isNull;
		}

		public SchemaDuration(TimeSpan newvalue)
		{
			myValue = newvalue;
			/*
			myValue = new TimeSpan(newvalue.Days % 31, newvalue.Hours, newvalue.Minutes, newvalue.Seconds, newvalue.Milliseconds);
			months = (newvalue.Days / 31) % 12;
			years = newvalue.Days / 31 / 12;
			*/
			isEmpty = false;
			isNull = false;
		}

		public SchemaDuration(long ticks)
		{
			myValue = new TimeSpan( ticks );
		}

		public SchemaDuration(int newyears, int newmonths, int days, int hours, int minutes, int seconds, double partseconds, bool bnegative)
		{
			years = newyears;
			months = newmonths;
			myValue = new TimeSpan( days, hours, minutes, seconds, (int)(partseconds * 1000.0) );
			isEmpty = isNull = false;
			if( bnegative )
			{
				myValue = -myValue;
				years = -years;
				months = -months;
			}
		}

		public SchemaDuration(string newvalue)
		{
			Parse( newvalue );
		}

		public SchemaDuration(ISchemaType obj)
		{
			Assign( obj );
		}

	#endregion //Constructors

		#region Get, Set
		public TimeSpan Value
		{
			get
			{
				return myValue;
			}
			set
			{
				myValue = value;
				isEmpty = false;
				isNull = false;
			}
		}
		public int Years
		{
			get
			{
				return years;
			}
			set
			{
				years = value;
				isEmpty = false;
				isNull = false;
			}
		}
		public int Months
		{
			get
			{
				return months;
			}
			set
			{
				months = value;
				isEmpty = false;
				isNull = false;
			}
		}

		public void Parse( string s )
		{
			string newvalue = SchemaString.normalize(SchemaString.WhitespaceFacet.Collapse, s);
			
			if ( newvalue == null )
			{
				isEmpty = true;
				isNull = true;
				return;
			}
			else if ( newvalue.Length == 0 )
			{
				isEmpty = true;
				isNull = false;
				return;
			}

			int pos = 0;
			bool bNegative = false;
			int day = 0;
			int hour = 0;
			int minute = 0;
			int second = 0;
			double partsecond = 0.0;
			months = 0;	
			years = 0;
			
			if (newvalue[pos] == '-') 
			{
				bNegative = true;
				++pos;
			}

			if (pos == newvalue.Length || newvalue[pos] != 'P') 
				throw new StringParseException("Duration must start with P or -P followed by a duration value.");
			++pos;

			int state = 0;	// year component
			while ( pos != newvalue.Length )
			{
				// no more data allowed?
				if (state == 8) 
					throw new StringParseException("Extra data after duration value.");
						
				// check if ymd part is over
				if (newvalue[pos] == 'T') 
				{
					if (state >= 4) // hour
						throw new StringParseException("Multiple Ts inside duration value.");
					state = 4;
					++pos;			
				}

				if (state == 3) // 'T' separator
					throw new StringParseException("Extra data after duration value.");

				// now a digit has to follow, and probably more than one
				if (pos == newvalue.Length || newvalue[pos] < '0' || newvalue[pos] > '9') 
					throw new StringParseException("Invalid numeric data in duration value.");

				int val = 0;
				int digits = 0;
				while (pos != newvalue.Length && newvalue[pos] >= '0' && newvalue[pos] <= '9')
				{
					if (val >= 100000000) 
						throw new StringParseException("Numeric overflow in duration value.");
					val = val * 10 + (newvalue[pos] - '0');
					digits += 1;
					++pos;
				}

				if (pos == newvalue.Length) 
					throw new StringParseException("Duration value missing component designator.");
				
				int foundState = 8;	// bad
				switch (newvalue[pos]) 
				{
				case 'Y': if (state >= 4) foundState = 8; else foundState = 0; break;
				case 'M': if (state >= 4) foundState = 5; else foundState = 1; break;
				case 'D': if (state >= 4) foundState = 8; else foundState = 2; break;
				case 'H': if (state >= 4) foundState = 4; else foundState = 8; break;
				case 'S': if (state >= 7) foundState = 7; else if (state >= 4) foundState = 6; else foundState = 8; break;
				case '.': if (state >= 4) foundState = 6; else foundState = 8; break;
				}

				if (foundState == 8 || foundState < state) 
					throw new StringParseException("Invalid or duplicate component designator.");

				++pos;

				switch ( foundState )
				{
				case 0: years = val; break;
				case 1: months = val; break;
				case 2: day = val; break;
				case 4: hour = val; break;
				case 5: minute = val; break;
				case 6: second = val; break;
				case 7: partsecond = val * Math.Pow(0.1, digits); break;
				}
		
				state = foundState + 1;
			}					
			if (state == 0) 
				throw new StringParseException("No components given after P in duration value.");

			myValue = new TimeSpan(day, hour, minute, second, (int)(partsecond * 1000));
			if (bNegative) 
			{
				myValue = -myValue;
				years = -years;
				months = -months;
			}
			isEmpty = false;
			isNull = false;
		}

		public void Assign( ISchemaType newvalue )
		{
			if( newvalue == null )
			{
				SetEmpty(true);
				SetNull(true);
				return;
			}

			if( newvalue.IsEmpty() )
			{
				myValue = new TimeSpan(0);
				months = 0;
				years = 0;
				SetEmpty( true );
				SetNull( newvalue.IsNull() );
				return;
			}
			isEmpty = false;
			if( newvalue is SchemaDuration )
			{
				myValue = ((SchemaDuration)newvalue).myValue;
				months = ((SchemaDuration)newvalue).months;
				years = ((SchemaDuration)newvalue).years;
				isEmpty = ((SchemaDuration)newvalue).isEmpty;
				isNull = ((SchemaDuration)newvalue).isNull;
			}
			else if( newvalue is SchemaString )
				Parse( newvalue.ToString() );
			else 
			{
				try
				{
					Parse( newvalue.ToString() );
				}
				catch (StringParseException)
				{
					throw new TypesIncompatibleException( newvalue, this );
				}
			}
		}

		#endregion // Get, Set

		public override string ToString()
		{
			if (isEmpty)
				return "";
			string s = "";
			if (myValue.Ticks < 0 )
				s += "-";
			s += "P";
			if (years != 0) 
				s += Math.Abs(years).ToString() + "Y";
			if (months != 0) 
				s += Math.Abs(months).ToString() + "M";
			if (myValue.Days != 0) 
				s += Math.Abs(myValue.Days).ToString() + "D";
			double partsecond = (Math.Abs(myValue.Ticks) / 10000000.0) % 1.0;
			if (myValue.Hours!=0 || myValue.Minutes!=0 || myValue.Seconds!=0 || partsecond>0.0 )
			{
				s += "T";
				if (myValue.Hours != 0) 
					s += Math.Abs(myValue.Hours).ToString() + "H";
				if (myValue.Minutes != 0) 
					s += Math.Abs(myValue.Minutes).ToString() + "M";
				if (myValue.Seconds != 0)
					s += Math.Abs(myValue.Seconds).ToString("#0");
				if (partsecond > 0.0 && partsecond < 1.0) 
				{
					string sPartSecond = partsecond.ToString("0.##########");
					s += "." + sPartSecond.Substring(2, sPartSecond.Length-2);
				}
				if (myValue.Seconds != 0 || (partsecond > 0 && partsecond < 1))
					s += "S";
			}
			if (s[s.Length-1] == 'P')
				s += "T0S";			
			return s;
		}

		public bool IsNegative()
		{
			return ( myValue.Ticks < 0 );
		}


		#region Implemented interfaces
		// System.IComparable
		public override int GetHashCode()
		{
			return myValue.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
				return false;
			if (!(obj is SchemaDuration))
				return false;
			SchemaDuration dur = (SchemaDuration)obj;
			if( myValue != dur.myValue )
				return false;
			if( months != dur.months )
				return false;
			if( years != dur.years )
				return false;
			return true;
		}

		public static bool operator==(SchemaDuration obj1, SchemaDuration obj2)
		{
			if ((null==(object) obj1) && (null==(object) obj2)) return true;
			if ((null==(object) obj1) || (null==(object) obj2)) return false;
			if( (obj1.myValue == obj2.myValue)  &&
				(obj1.months == obj2.months)  &&
				(obj1.years == obj2.years) )
				return true;
			return false;
		}

		public static bool operator!=(SchemaDuration obj1, SchemaDuration obj2)
		{
			return !(obj1 == obj2);
		}

		public int CompareTo(object newvalue)
		{
			SchemaDuration obj = (SchemaDuration)newvalue;
			if( years > obj.years )
				return 1;
			if( years < obj.years )
				return -1;
			if( months > obj.months )
				return 1;
			if( months < obj.months )
				return -1;
			return myValue.CompareTo(((SchemaDuration)obj).myValue);
		}

		// System.ICloneable
		public object Clone()
		{
			return new SchemaDuration(this);
		}

		// ISchemaType
		public bool BoolValue()
		{
			return myValue.Ticks != 0;
		}

		public bool IsEmpty()
		{
			return isEmpty;
		}

		public void SetEmpty( bool bIsEmpty )
		{
			isEmpty = bIsEmpty;
			if( bIsEmpty )
				myValue = TimeSpan.Zero;
		}

		public bool IsNull()
		{
			return isNull;
		}

		public void SetNull( bool bIsNull )
		{
			isNull = bIsNull;
			if( bIsNull )
				SetEmpty(true);
		}


		// ISchemaTypeCalendar
		public ECalendarTypes CalendarType()
		{
			return ECalendarTypes.Duration;
		}

		public SchemaDateTime DateTimeValue()
		{
			throw new TypesIncompatibleException(this, new SchemaDateTime());
		}

		public SchemaDate DateValue()
		{
			throw new TypesIncompatibleException(this, new SchemaDateTime());
		}

		public SchemaTime TimeValue()
		{
			throw new TypesIncompatibleException(this, new SchemaDateTime());
		}

		public SchemaDuration DurationValue()
		{
			return (SchemaDuration)Clone();
		}

		#endregion // Implemented interfaces
	}

	public class SchemaBase64Binary : SchemaBinaryBase
	{
		#region Constructors
		public SchemaBase64Binary()
			: base()
		{
		}

		public SchemaBase64Binary(SchemaBase64Binary obj)
			: base( (SchemaBinaryBase)obj )
		{
		}

		public SchemaBase64Binary(byte[] Value)
			: base( Value )
		{
		}

		public SchemaBase64Binary(string newvalue)
		{
			Parse( newvalue );
		}

		public SchemaBase64Binary(ISchemaType obj)
		{
			Assign( obj );
		}


		#endregion //Constructors;

		#region Get, Set
		public override void Parse( string newvalue )
		{
			string sValue = "";
			for( int i=0; i < newvalue.Length; i++ )
			{
				char c = newvalue[i];

				if( System.Char.IsLetterOrDigit( c ) || c == '+' || c == '/' )
					sValue += c;
			}

			for( int i = sValue.Length % 4; i != 0 && i < 4; i++ )
				sValue += "="; // concat pad-chars up to a complete base64 number
			// convert to array of bytes

			myValue = Convert.FromBase64String( sValue );
			isEmpty = false;
			isNull = false;
		}
		#endregion // Get, Set

		public override string ToString()
		{
			if( isEmpty || (myValue == null) )
				return "";
			string sResult = Convert.ToBase64String( myValue );
			for( int i = 76; i < sResult.Length; i += 77 )
				sResult = sResult.Substring(0,i) + "\n" + sResult.Substring(i, sResult.Length-i );
			return sResult;
		}

		#region Implemented interfaces
		// ISchemaType

		// System.ICloneable
		public override object Clone()
		{
			return new SchemaBase64Binary(this);
		}

		// SchemaCalendarBase
		public override EBinaryTypes BinaryType()
		{
			return EBinaryTypes.Base64;
		}
		#endregion // Implemented interfaces
	}

	public class SchemaHexBinary : SchemaBinaryBase
	{
		protected static char[] s_cEncode = new char[16]
		{
			'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'
		};
		protected static sbyte[] s_cDecode = new sbyte[256]
		{
			-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			0,	 1,	 2,	 3,	 4,	 5,	 6,	 7,	 8,	 9,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	10,	11,	12,	13,	14,	15,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	10,	11,	12,	13,	14,	15,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1
		};

		#region Constructors
		public SchemaHexBinary()
			: base()
		{
		}

		public SchemaHexBinary(SchemaHexBinary obj)
			: base( (SchemaBinaryBase)obj )
		{
		}

		public SchemaHexBinary(byte[] Value)
			: base( Value )
		{
		}

		public SchemaHexBinary(string newvalue)
		{
			Parse( newvalue );
		}

		public SchemaHexBinary(ISchemaType obj)
		{
			Assign( obj );
		}

		#endregion //Constructors;

		#region Get, Set
		public override void Parse( string newvalue )
		{
			char[] cSrc = newvalue.ToCharArray();
			myValue = new byte[ cSrc.Length / 2 ];
			int nSrcIndex = 0;
			int nTarIndex = 0;
			while( nSrcIndex < cSrc.Length )
			{
				sbyte c = s_cDecode[ cSrc[ nSrcIndex++ ] ];
				if( c != -1 )
				{
					myValue[ nTarIndex >> 1 ] |= (byte)( (nTarIndex & 1) == 1 ? c : (c << 4) );
					nTarIndex++;
				}
			}
			isEmpty = false;
			isNull = false;
		}
		#endregion // Get, Set

		public override string ToString()
		{
			if( isEmpty )
				return "";
			char[] cResult = new char[ myValue.Length << 1 ];
			for( int i = 0; i < myValue.Length; i++ )
			{
				cResult[ i << 1 ] = s_cEncode[ (myValue[i] >> 4) & 15 ];
				cResult[ (i << 1) + 1 ] = s_cEncode[ myValue[i] & 15 ];
			}
			return new String( cResult );
		}

		#region Implemented interfaces
		// ISchemaType

		// System.ICloneable
		public override object Clone()
		{
			return new SchemaHexBinary(this);
		}

		// SchemaCalendarBase
		public override EBinaryTypes BinaryType()
		{
			return EBinaryTypes.Hex;
		}
		#endregion Implemented interfaces
	}


	public class SchemaString : ISchemaType , ISchemaTypeCalendar, ISchemaTypeNumber
	{
		public enum WhitespaceFacet  {Collapse, Replace, Preserve};

		public string myValue = "";
		public bool isEmpty = true;
		public bool isNull = true;

		 public static string normalize(WhitespaceFacet mode, string s)
        {
            if (mode == WhitespaceFacet.Collapse)
            {
                StringBuilder sb = new StringBuilder(normalize(WhitespaceFacet.Replace, s).Trim());

                for (int i=1; i< sb.Length;)
                {
                    if (sb[i] == ' ' && sb[i-1] == ' ')
                        sb.Remove(i, 1);
                    else
                        i++;
                }
                return sb.ToString();
            }

            if (mode == WhitespaceFacet.Replace)
            {
                return s.Replace('\n', ' ').Replace('\r', ' ').Replace('\t', ' ');
            }

            return s;
        }
		
		#region Constructors
		public SchemaString()
		{
			isNull = false;
		}

		public SchemaString(SchemaString obj)
		{
			myValue = obj.myValue;
			isEmpty = obj.isEmpty;
			isNull = obj.isNull;
		}

		public SchemaString(string newvalue)
		{
			myValue = newvalue;
			isEmpty = (newvalue.Length == 0 );
			isNull = false;
		}

		public SchemaString( ISchemaType obj )
		{
			Assign( obj );
		}

		#endregion Constructors

		#region Get, Set
		public string Value
		{
			get
			{
				return myValue;
			}
			set
			{
				myValue = value;
				isEmpty = (myValue.Length == 0 );
				isNull = false;
			}
		}

		public void Parse(string newvalue)
		{
			myValue = newvalue;
			isEmpty = (myValue.Length == 0 );
			isNull = false;
		}

		public void Assign( ISchemaType newvalue )
		{
			if( newvalue == null )
			{
				SetNull(true);
				SetEmpty(true);
				myValue = "";
				return;
			}

			if( newvalue.IsEmpty() ) 
			{
				isEmpty = true;
				SetNull( newvalue.IsNull() );
				myValue = "";
				return;
			}
			myValue = newvalue.ToString();
			isEmpty = (myValue.Length == 0 );
			isNull = false;
		}

		#endregion // Get, Set

		public override string ToString()
		{
			if( isEmpty )
				return "";
			return myValue;
		}

		public bool IsValueNumeric() 
		{
			try 
			{
				decimal tmp = Convert.ToDecimal(myValue, CultureInfo.InvariantCulture);
			}
			catch (FormatException) 
			{
				return false;
			}
			return true;
		}


		#region Implemented interfaces
		// System.Comparable
		public override int GetHashCode()
		{
			return myValue.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
				return false;
			if (!(obj is SchemaString))
				return false;
			return myValue == ((SchemaString)obj).myValue;
		}

		public static bool operator==(SchemaString obj1, SchemaString obj2)
		{
			if ((null==(object) obj1) && (null==(object) obj2)) return true;
			if ((null==(object) obj1) || (null==(object) obj2)) return false;
			return obj1.myValue == obj2.myValue;
		}

		public static bool operator!=(SchemaString obj1, SchemaString obj2)
		{
			if ((null==(object) obj1) && (null==(object) obj2)) return false;
			if ((null==(object) obj1) || (null==(object) obj2)) return true;
			return obj1.myValue != obj2.myValue;
		}

		public int CompareTo(object obj)
		{
			return myValue.CompareTo(((SchemaString)obj).myValue);
		}

		// System.ICloneable
		public object Clone()
		{
			return new SchemaString(myValue);
		}

		// ISchemaType
		public bool BoolValue()
		{
			if( myValue==null || myValue.Length==0 || myValue.ToLower().CompareTo("false")==0 )
				return false;
			if (IsValueNumeric())
				return DecimalValue().CompareTo(0.0m) != 0;
			return true;
		}

		public bool IsEmpty()
		{
			return isEmpty;
		}

		public void SetEmpty( bool bIsEmpty )
		{
			isEmpty = bIsEmpty;
			if( bIsEmpty )
				myValue = "";
		}

		public bool IsNull()
		{
			return isNull;
		}

		public void SetNull( bool bIsNull )
		{
			isNull = bIsNull;
			if( bIsNull )
				SetEmpty(true);
		}

		// ISchemaTypeNumber
		public ENumericTypes NumericType()
		{
			return ENumericTypes.ValueDecimal;
		}

		public int IntValue()
		{
			if( myValue=="" )
				return 0;
			try
			{
				return Convert.ToInt32( myValue );
			}
			catch( FormatException )
			{
				throw new ValuesNotConvertableException(this, new SchemaInt());
			}
		}

		public long LongValue()
		{
			if( myValue=="" )
				return 0;
			try
			{
				return Convert.ToInt64( myValue );
			}
			catch( FormatException )
			{
				throw new ValuesNotConvertableException(this, new SchemaLong());
			}
		}

		public double DoubleValue()
		{
			if( myValue=="" )
				return 0.0;
			try
			{
				return Convert.ToDouble( myValue, CultureInfo.InvariantCulture );
			}
			catch( FormatException )
			{
				throw new ValuesNotConvertableException(this, new SchemaDouble());
			}
		}

		public decimal DecimalValue()
		{
			if( myValue=="" )
				return 0;
			try
			{
				return Convert.ToDecimal( myValue, CultureInfo.InvariantCulture );
			}
			catch( FormatException )
			{
				throw new ValuesNotConvertableException(this, new SchemaDecimal());
			}
		}

		// ISchemaTypeCalendar
		public ECalendarTypes CalendarType()
		{
			return ECalendarTypes.Undefined;
		}

		public SchemaDateTime DateTimeValue()
		{
			try
			{
				return new SchemaDateTime( myValue );
			}
			catch( StringParseException )
			{
				throw new ValuesNotConvertableException(this, new SchemaDateTime() );
			}
		}

		public SchemaDate DateValue()
		{
			try
			{
				return new SchemaDate( myValue );
			}
			catch( StringParseException )
			{
				throw new ValuesNotConvertableException(this, new SchemaDate() );
			}
		}

		public SchemaTime TimeValue()
		{
			try
			{
				return new SchemaTime( myValue );
			}
			catch( StringParseException )
			{
				throw new ValuesNotConvertableException(this, new SchemaTime() );
			}
		}

		public SchemaDuration DurationValue()
		{
			try
			{
				return new SchemaDuration( myValue );
			}
			catch( StringParseException )
			{
				throw new ValuesNotConvertableException(this, new SchemaDuration() );
			}
		}

		#endregion // Implemented interfaces
	}
	#endregion // Schema Types
}
