//
// datasetType.cs
//
// This file was generated by XMLSpy 2006r3 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//


using System;
using System.Collections;
using System.Xml;
using Altova.Types;

namespace dappleview
{
	public class datasetType : Altova.Xml.Node
	{
		#region Forward constructors

		public datasetType(XmlDocument doc) : base(doc) { SetCollectionParents(); }
		public datasetType(XmlNode node) : base(node) { SetCollectionParents(); }
		public datasetType(Altova.Xml.Node node) : base(node) { SetCollectionParents(); }
		public datasetType(Altova.Xml.Document doc, string namespaceURI, string prefix, string name) : base(doc, namespaceURI, prefix, name) { SetCollectionParents(); }
		#endregion // Forward constructors

		public override void AdjustPrefix()
		{

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Attribute, "", "name" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Attribute, "", "name", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, false);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Attribute, "", "opacity" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Attribute, "", "opacity", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, false);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Attribute, "", "hierarchy" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Attribute, "", "hierarchy", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, false);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Attribute, "", "renderpriority" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Attribute, "", "renderpriority", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, false);
			}
		}



		#region name accessor methods
		public static int GetnameMinCount()
		{
			return 1;
		}

		public static int nameMinCount
		{
			get
			{
				return 1;
			}
		}

		public static int GetnameMaxCount()
		{
			return 1;
		}

		public static int nameMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetnameCount()
		{
			return DomChildCount(NodeType.Attribute, "", "name");
		}

		public int nameCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "name");
			}
		}

		public bool Hasname()
		{
			return HasDomChild(NodeType.Attribute, "", "name");
		}

		public SchemaString Newname()
		{
			return new SchemaString();
		}

		public SchemaString GetnameAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "name", index)));
		}

		public XmlNode GetStartingnameCursor()
		{
			return GetDomFirstChild( NodeType.Attribute, "", "name" );
		}

		public XmlNode GetAdvancednameCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Attribute, "", "name", curNode );
		}

		public SchemaString GetnameValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.Value );
		}


		public SchemaString Getname()
		{
			return GetnameAt(0);
		}

		public SchemaString name
		{
			get
			{
				return GetnameAt(0);
			}
		}

		public void RemovenameAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "name", index);
		}

		public void Removename()
		{
			while (Hasname())
				RemovenameAt(0);
		}

		public void Addname(SchemaString newValue)
		{
			if( newValue.IsNull() == false )
				AppendDomChild(NodeType.Attribute, "", "name", newValue.ToString());
		}

		public void InsertnameAt(SchemaString newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Attribute, "", "name", index, newValue.ToString());
		}

		public void ReplacenameAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "name", index, newValue.ToString());
		}
		#endregion // name accessor methods

		#region name collection
        public nameCollection	Mynames = new nameCollection( );

        public class nameCollection: IEnumerable
        {
            datasetType parent;
            public datasetType Parent
			{
				set
				{
					parent = value;
				}
			}
			public nameEnumerator GetEnumerator() 
			{
				return new nameEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class nameEnumerator: IEnumerator 
        {
			int nIndex;
			datasetType parent;
			public nameEnumerator(datasetType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.nameCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetnameAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // name collection

		#region opacity accessor methods
		public static int GetopacityMinCount()
		{
			return 0;
		}

		public static int opacityMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetopacityMaxCount()
		{
			return 1;
		}

		public static int opacityMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetopacityCount()
		{
			return DomChildCount(NodeType.Attribute, "", "opacity");
		}

		public int opacityCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "opacity");
			}
		}

		public bool Hasopacity()
		{
			return HasDomChild(NodeType.Attribute, "", "opacity");
		}

		public SchemaDouble Newopacity()
		{
			return new SchemaDouble();
		}

		public SchemaDouble GetopacityAt(int index)
		{
			return new SchemaDouble(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "opacity", index)));
		}

		public XmlNode GetStartingopacityCursor()
		{
			return GetDomFirstChild( NodeType.Attribute, "", "opacity" );
		}

		public XmlNode GetAdvancedopacityCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Attribute, "", "opacity", curNode );
		}

		public SchemaDouble GetopacityValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaDouble( curNode.Value );
		}


		public SchemaDouble Getopacity()
		{
			return GetopacityAt(0);
		}

		public SchemaDouble opacity
		{
			get
			{
				return GetopacityAt(0);
			}
		}

		public void RemoveopacityAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "opacity", index);
		}

		public void Removeopacity()
		{
			while (Hasopacity())
				RemoveopacityAt(0);
		}

		public void Addopacity(SchemaDouble newValue)
		{
			if( newValue.IsNull() == false )
				AppendDomChild(NodeType.Attribute, "", "opacity", newValue.ToString());
		}

		public void InsertopacityAt(SchemaDouble newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Attribute, "", "opacity", index, newValue.ToString());
		}

		public void ReplaceopacityAt(SchemaDouble newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "opacity", index, newValue.ToString());
		}
		#endregion // opacity accessor methods

		#region opacity collection
        public opacityCollection	Myopacitys = new opacityCollection( );

        public class opacityCollection: IEnumerable
        {
            datasetType parent;
            public datasetType Parent
			{
				set
				{
					parent = value;
				}
			}
			public opacityEnumerator GetEnumerator() 
			{
				return new opacityEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class opacityEnumerator: IEnumerator 
        {
			int nIndex;
			datasetType parent;
			public opacityEnumerator(datasetType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.opacityCount );
			}
			public SchemaDouble  Current 
			{
				get 
				{
					return(parent.GetopacityAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // opacity collection

		#region hierarchy accessor methods
		public static int GethierarchyMinCount()
		{
			return 0;
		}

		public static int hierarchyMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GethierarchyMaxCount()
		{
			return 1;
		}

		public static int hierarchyMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GethierarchyCount()
		{
			return DomChildCount(NodeType.Attribute, "", "hierarchy");
		}

		public int hierarchyCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "hierarchy");
			}
		}

		public bool Hashierarchy()
		{
			return HasDomChild(NodeType.Attribute, "", "hierarchy");
		}

		public SchemaString Newhierarchy()
		{
			return new SchemaString();
		}

		public SchemaString GethierarchyAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "hierarchy", index)));
		}

		public XmlNode GetStartinghierarchyCursor()
		{
			return GetDomFirstChild( NodeType.Attribute, "", "hierarchy" );
		}

		public XmlNode GetAdvancedhierarchyCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Attribute, "", "hierarchy", curNode );
		}

		public SchemaString GethierarchyValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.Value );
		}


		public SchemaString Gethierarchy()
		{
			return GethierarchyAt(0);
		}

		public SchemaString hierarchy
		{
			get
			{
				return GethierarchyAt(0);
			}
		}

		public void RemovehierarchyAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "hierarchy", index);
		}

		public void Removehierarchy()
		{
			while (Hashierarchy())
				RemovehierarchyAt(0);
		}

		public void Addhierarchy(SchemaString newValue)
		{
			if( newValue.IsNull() == false )
				AppendDomChild(NodeType.Attribute, "", "hierarchy", newValue.ToString());
		}

		public void InserthierarchyAt(SchemaString newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Attribute, "", "hierarchy", index, newValue.ToString());
		}

		public void ReplacehierarchyAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "hierarchy", index, newValue.ToString());
		}
		#endregion // hierarchy accessor methods

		#region hierarchy collection
        public hierarchyCollection	Myhierarchys = new hierarchyCollection( );

        public class hierarchyCollection: IEnumerable
        {
            datasetType parent;
            public datasetType Parent
			{
				set
				{
					parent = value;
				}
			}
			public hierarchyEnumerator GetEnumerator() 
			{
				return new hierarchyEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class hierarchyEnumerator: IEnumerator 
        {
			int nIndex;
			datasetType parent;
			public hierarchyEnumerator(datasetType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.hierarchyCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GethierarchyAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // hierarchy collection

		#region renderpriority accessor methods
		public static int GetrenderpriorityMinCount()
		{
			return 0;
		}

		public static int renderpriorityMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetrenderpriorityMaxCount()
		{
			return 1;
		}

		public static int renderpriorityMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetrenderpriorityCount()
		{
			return DomChildCount(NodeType.Attribute, "", "renderpriority");
		}

		public int renderpriorityCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "renderpriority");
			}
		}

		public bool Hasrenderpriority()
		{
			return HasDomChild(NodeType.Attribute, "", "renderpriority");
		}

		public SchemaInt Newrenderpriority()
		{
			return new SchemaInt();
		}

		public SchemaInt GetrenderpriorityAt(int index)
		{
			return new SchemaInt(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "renderpriority", index)));
		}

		public XmlNode GetStartingrenderpriorityCursor()
		{
			return GetDomFirstChild( NodeType.Attribute, "", "renderpriority" );
		}

		public XmlNode GetAdvancedrenderpriorityCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Attribute, "", "renderpriority", curNode );
		}

		public SchemaInt GetrenderpriorityValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaInt( curNode.Value );
		}


		public SchemaInt Getrenderpriority()
		{
			return GetrenderpriorityAt(0);
		}

		public SchemaInt renderpriority
		{
			get
			{
				return GetrenderpriorityAt(0);
			}
		}

		public void RemoverenderpriorityAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "renderpriority", index);
		}

		public void Removerenderpriority()
		{
			while (Hasrenderpriority())
				RemoverenderpriorityAt(0);
		}

		public void Addrenderpriority(SchemaInt newValue)
		{
			if( newValue.IsNull() == false )
				AppendDomChild(NodeType.Attribute, "", "renderpriority", newValue.ToString());
		}

		public void InsertrenderpriorityAt(SchemaInt newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Attribute, "", "renderpriority", index, newValue.ToString());
		}

		public void ReplacerenderpriorityAt(SchemaInt newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "renderpriority", index, newValue.ToString());
		}
		#endregion // renderpriority accessor methods

		#region renderpriority collection
        public renderpriorityCollection	Myrenderprioritys = new renderpriorityCollection( );

        public class renderpriorityCollection: IEnumerable
        {
            datasetType parent;
            public datasetType Parent
			{
				set
				{
					parent = value;
				}
			}
			public renderpriorityEnumerator GetEnumerator() 
			{
				return new renderpriorityEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class renderpriorityEnumerator: IEnumerator 
        {
			int nIndex;
			datasetType parent;
			public renderpriorityEnumerator(datasetType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.renderpriorityCount );
			}
			public SchemaInt  Current 
			{
				get 
				{
					return(parent.GetrenderpriorityAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // renderpriority collection

        private void SetCollectionParents()
        {
            Mynames.Parent = this; 
            Myopacitys.Parent = this; 
            Myhierarchys.Parent = this; 
            Myrenderprioritys.Parent = this; 
	}
}
}
