//
// CapabilityType.cs
//
// This file was generated by XMLSpy 2007r3 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//


using System;
using System.Collections;
using System.Xml;
using Altova.Types;

namespace WMS_MS_Capabilities
{
	public class CapabilityType : Altova.Xml.Node
	{
		#region Documentation
		public static string GetAnnoDocumentation() { return ""; }
		#endregion

		#region Forward constructors

		public CapabilityType() : base() { SetCollectionParents(); }

		public CapabilityType(XmlDocument doc) : base(doc) { SetCollectionParents(); }
		public CapabilityType(XmlNode node) : base(node) { SetCollectionParents(); }
		public CapabilityType(Altova.Xml.Node node) : base(node) { SetCollectionParents(); }
		public CapabilityType(Altova.Xml.Document doc, string namespaceURI, string prefix, string name) : base(doc, namespaceURI, prefix, name) { SetCollectionParents(); }
		#endregion // Forward constructors

		public override void AdjustPrefix()
		{

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "Request" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "Request", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, false);
				new RequestType(DOMNode).AdjustPrefix();
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "Exception" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "Exception", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, false);
				new ExceptionType(DOMNode).AdjustPrefix();
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "UserDefinedSymbolization" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "UserDefinedSymbolization", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, false);
				new UserDefinedSymbolizationType(DOMNode).AdjustPrefix();
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "Layer" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "Layer", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, false);
				new LayerType(DOMNode).AdjustPrefix();
			}
		}

		public void SetXsiType()
		{
 			XmlElement el = (XmlElement) domNode;
			el.SetAttribute("type", "http://www.w3.org/2001/XMLSchema-instance", "Capability");
		}


		#region Request Documentation
		public static string GetRequestAnnoDocumentation()
		{
			return "";		
		}
		public static string GetRequestDefault()
		{
			return "";		
		}
		#endregion

		#region Request accessor methods
		public static int GetRequestMinCount()
		{
			return 1;
		}

		public static int RequestMinCount
		{
			get
			{
				return 1;
			}
		}

		public static int GetRequestMaxCount()
		{
			return 1;
		}

		public static int RequestMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetRequestCount()
		{
			return DomChildCount(NodeType.Element, "", "Request");
		}

		public int RequestCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Request");
			}
		}

		public bool HasRequest()
		{
			return HasDomChild(NodeType.Element, "", "Request");
		}

		public RequestType NewRequest()
		{
			return new RequestType(domNode.OwnerDocument.CreateElement("Request", ""));
		}

		public RequestType GetRequestAt(int index)
		{
			return new RequestType(GetDomChildAt(NodeType.Element, "", "Request", index));
		}

		public XmlNode GetStartingRequestCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "Request" );
		}

		public XmlNode GetAdvancedRequestCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "Request", curNode );
		}

		public RequestType GetRequestValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new RequestType( curNode );
		}


		public RequestType GetRequest()
		{
			return GetRequestAt(0);
		}

		public RequestType Request
		{
			get
			{
				return GetRequestAt(0);
			}
		}

		public void RemoveRequestAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Request", index);
		}

		public void RemoveRequest()
		{
			RemoveRequestAt(0);
		}

		public XmlNode AddRequest(RequestType newValue)
		{
			return AppendDomElement("", "Request", newValue);
		}

		public void InsertRequestAt(RequestType newValue, int index)
		{
			InsertDomElementAt("", "Request", index, newValue);
		}

		public void ReplaceRequestAt(RequestType newValue, int index)
		{
			ReplaceDomElementAt("", "Request", index, newValue);
		}
		#endregion // Request accessor methods

		#region Request collection
        public RequestCollection	MyRequests = new RequestCollection( );

        public class RequestCollection: IEnumerable
        {
            CapabilityType parent;
            public CapabilityType Parent
			{
				set
				{
					parent = value;
				}
			}
			public RequestEnumerator GetEnumerator() 
			{
				return new RequestEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class RequestEnumerator: IEnumerator 
        {
			int nIndex;
			CapabilityType parent;
			public RequestEnumerator(CapabilityType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.RequestCount );
			}
			public RequestType  Current 
			{
				get 
				{
					return(parent.GetRequestAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // Request collection

		#region Exception Documentation
		public static string GetExceptionAnnoDocumentation()
		{
			return "";		
		}
		public static string GetExceptionDefault()
		{
			return "";		
		}
		#endregion

		#region Exception accessor methods
		public static int GetExceptionMinCount()
		{
			return 1;
		}

		public static int ExceptionMinCount
		{
			get
			{
				return 1;
			}
		}

		public static int GetExceptionMaxCount()
		{
			return 1;
		}

		public static int ExceptionMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetExceptionCount()
		{
			return DomChildCount(NodeType.Element, "", "Exception");
		}

		public int ExceptionCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Exception");
			}
		}

		public bool HasException()
		{
			return HasDomChild(NodeType.Element, "", "Exception");
		}

		public ExceptionType NewException()
		{
			return new ExceptionType(domNode.OwnerDocument.CreateElement("Exception", ""));
		}

		public ExceptionType GetExceptionAt(int index)
		{
			return new ExceptionType(GetDomChildAt(NodeType.Element, "", "Exception", index));
		}

		public XmlNode GetStartingExceptionCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "Exception" );
		}

		public XmlNode GetAdvancedExceptionCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "Exception", curNode );
		}

		public ExceptionType GetExceptionValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new ExceptionType( curNode );
		}


		public ExceptionType GetException()
		{
			return GetExceptionAt(0);
		}

		public ExceptionType Exception
		{
			get
			{
				return GetExceptionAt(0);
			}
		}

		public void RemoveExceptionAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Exception", index);
		}

		public void RemoveException()
		{
			RemoveExceptionAt(0);
		}

		public XmlNode AddException(ExceptionType newValue)
		{
			return AppendDomElement("", "Exception", newValue);
		}

		public void InsertExceptionAt(ExceptionType newValue, int index)
		{
			InsertDomElementAt("", "Exception", index, newValue);
		}

		public void ReplaceExceptionAt(ExceptionType newValue, int index)
		{
			ReplaceDomElementAt("", "Exception", index, newValue);
		}
		#endregion // Exception accessor methods

		#region Exception collection
        public ExceptionCollection	MyExceptions = new ExceptionCollection( );

        public class ExceptionCollection: IEnumerable
        {
            CapabilityType parent;
            public CapabilityType Parent
			{
				set
				{
					parent = value;
				}
			}
			public ExceptionEnumerator GetEnumerator() 
			{
				return new ExceptionEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class ExceptionEnumerator: IEnumerator 
        {
			int nIndex;
			CapabilityType parent;
			public ExceptionEnumerator(CapabilityType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.ExceptionCount );
			}
			public ExceptionType  Current 
			{
				get 
				{
					return(parent.GetExceptionAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // Exception collection

		#region UserDefinedSymbolization Documentation
		public static string GetUserDefinedSymbolizationAnnoDocumentation()
		{
			return "";		
		}
		public static string GetUserDefinedSymbolizationDefault()
		{
			return "";		
		}
		#endregion

		#region UserDefinedSymbolization accessor methods
		public static int GetUserDefinedSymbolizationMinCount()
		{
			return 0;
		}

		public static int UserDefinedSymbolizationMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetUserDefinedSymbolizationMaxCount()
		{
			return 1;
		}

		public static int UserDefinedSymbolizationMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetUserDefinedSymbolizationCount()
		{
			return DomChildCount(NodeType.Element, "", "UserDefinedSymbolization");
		}

		public int UserDefinedSymbolizationCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "UserDefinedSymbolization");
			}
		}

		public bool HasUserDefinedSymbolization()
		{
			return HasDomChild(NodeType.Element, "", "UserDefinedSymbolization");
		}

		public UserDefinedSymbolizationType NewUserDefinedSymbolization()
		{
			return new UserDefinedSymbolizationType(domNode.OwnerDocument.CreateElement("UserDefinedSymbolization", ""));
		}

		public UserDefinedSymbolizationType GetUserDefinedSymbolizationAt(int index)
		{
			return new UserDefinedSymbolizationType(GetDomChildAt(NodeType.Element, "", "UserDefinedSymbolization", index));
		}

		public XmlNode GetStartingUserDefinedSymbolizationCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "UserDefinedSymbolization" );
		}

		public XmlNode GetAdvancedUserDefinedSymbolizationCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "UserDefinedSymbolization", curNode );
		}

		public UserDefinedSymbolizationType GetUserDefinedSymbolizationValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new UserDefinedSymbolizationType( curNode );
		}


		public UserDefinedSymbolizationType GetUserDefinedSymbolization()
		{
			return GetUserDefinedSymbolizationAt(0);
		}

		public UserDefinedSymbolizationType UserDefinedSymbolization
		{
			get
			{
				return GetUserDefinedSymbolizationAt(0);
			}
		}

		public void RemoveUserDefinedSymbolizationAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "UserDefinedSymbolization", index);
		}

		public void RemoveUserDefinedSymbolization()
		{
			RemoveUserDefinedSymbolizationAt(0);
		}

		public XmlNode AddUserDefinedSymbolization(UserDefinedSymbolizationType newValue)
		{
			return AppendDomElement("", "UserDefinedSymbolization", newValue);
		}

		public void InsertUserDefinedSymbolizationAt(UserDefinedSymbolizationType newValue, int index)
		{
			InsertDomElementAt("", "UserDefinedSymbolization", index, newValue);
		}

		public void ReplaceUserDefinedSymbolizationAt(UserDefinedSymbolizationType newValue, int index)
		{
			ReplaceDomElementAt("", "UserDefinedSymbolization", index, newValue);
		}
		#endregion // UserDefinedSymbolization accessor methods

		#region UserDefinedSymbolization collection
        public UserDefinedSymbolizationCollection	MyUserDefinedSymbolizations = new UserDefinedSymbolizationCollection( );

        public class UserDefinedSymbolizationCollection: IEnumerable
        {
            CapabilityType parent;
            public CapabilityType Parent
			{
				set
				{
					parent = value;
				}
			}
			public UserDefinedSymbolizationEnumerator GetEnumerator() 
			{
				return new UserDefinedSymbolizationEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class UserDefinedSymbolizationEnumerator: IEnumerator 
        {
			int nIndex;
			CapabilityType parent;
			public UserDefinedSymbolizationEnumerator(CapabilityType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.UserDefinedSymbolizationCount );
			}
			public UserDefinedSymbolizationType  Current 
			{
				get 
				{
					return(parent.GetUserDefinedSymbolizationAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // UserDefinedSymbolization collection

		#region Layer Documentation
		public static string GetLayerAnnoDocumentation()
		{
			return "";		
		}
		public static string GetLayerDefault()
		{
			return "";		
		}
		#endregion

		#region Layer accessor methods
		public static int GetLayerMinCount()
		{
			return 0;
		}

		public static int LayerMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetLayerMaxCount()
		{
			return 1;
		}

		public static int LayerMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetLayerCount()
		{
			return DomChildCount(NodeType.Element, "", "Layer");
		}

		public int LayerCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Layer");
			}
		}

		public bool HasLayer()
		{
			return HasDomChild(NodeType.Element, "", "Layer");
		}

		public LayerType NewLayer()
		{
			return new LayerType(domNode.OwnerDocument.CreateElement("Layer", ""));
		}

		public LayerType GetLayerAt(int index)
		{
			return new LayerType(GetDomChildAt(NodeType.Element, "", "Layer", index));
		}

		public XmlNode GetStartingLayerCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "Layer" );
		}

		public XmlNode GetAdvancedLayerCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "Layer", curNode );
		}

		public LayerType GetLayerValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new LayerType( curNode );
		}


		public LayerType GetLayer()
		{
			return GetLayerAt(0);
		}

		public LayerType Layer
		{
			get
			{
				return GetLayerAt(0);
			}
		}

		public void RemoveLayerAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Layer", index);
		}

		public void RemoveLayer()
		{
			RemoveLayerAt(0);
		}

		public XmlNode AddLayer(LayerType newValue)
		{
			return AppendDomElement("", "Layer", newValue);
		}

		public void InsertLayerAt(LayerType newValue, int index)
		{
			InsertDomElementAt("", "Layer", index, newValue);
		}

		public void ReplaceLayerAt(LayerType newValue, int index)
		{
			ReplaceDomElementAt("", "Layer", index, newValue);
		}
		#endregion // Layer accessor methods

		#region Layer collection
        public LayerCollection	MyLayers = new LayerCollection( );

        public class LayerCollection: IEnumerable
        {
            CapabilityType parent;
            public CapabilityType Parent
			{
				set
				{
					parent = value;
				}
			}
			public LayerEnumerator GetEnumerator() 
			{
				return new LayerEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class LayerEnumerator: IEnumerator 
        {
			int nIndex;
			CapabilityType parent;
			public LayerEnumerator(CapabilityType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.LayerCount );
			}
			public LayerType  Current 
			{
				get 
				{
					return(parent.GetLayerAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // Layer collection

        private void SetCollectionParents()
        {
            MyRequests.Parent = this; 
            MyExceptions.Parent = this; 
            MyUserDefinedSymbolizations.Parent = this; 
            MyLayers.Parent = this; 
	}
}
}
